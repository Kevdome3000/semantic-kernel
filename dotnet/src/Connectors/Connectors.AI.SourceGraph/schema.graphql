schema {
    query: Query
    mutation: Mutation
}

"Access request"
type AccessRequest implements Node {
    "The unique identifier of the secret."
    id: ID!
    "Name of a person requested access"
    name: String!
    "Email of a person requested access"
    email: String!
    "The date and time when request access was created"
    createdAt: DateTime!
    "Additional information submitted by person requested access"
    additionalInfo: String
    "Access request status"
    status: AccessRequestStatus!
}

"A list of access requests"
type AccessRequestConnection {
    "Total count of access requests"
    totalCount: Int!
    "A list of access requests"
    nodes: [AccessRequest!]!
    "Pagination information."
    pageInfo: BidirectionalPageInfo!
}

"Access request status enum"
enum AccessRequestStatus {
    "Access request is submitted and waiting for actions"
    PENDING
    "Access request was approved"
    APPROVED
    "Access request was rejected"
    REJECTED
}

"An access token that grants to the holder the privileges of the user who created it."
type AccessToken implements Node {
    "The unique ID for the access token."
    id: ID!
    "The user whose privileges the access token grants."
    subject: User!
    "The scopes that define the allowed set of operations that can be performed using this access token."
    scopes: [String!]!
    "A user-supplied descriptive note for the access token."
    note: String!
    "The user who created the access token. This is either the subject user (if the access token\nwas created by the same user) or a site admin (who can create access tokens for any user)."
    creator: User!
    "The date when the access token was created."
    createdAt: DateTime!
    "The date when the access token was last used to authenticate a request."
    lastUsedAt: DateTime
}

"A list of access tokens."
type AccessTokenConnection {
    "A list of access tokens."
    nodes: [AccessToken!]!
    "The total count of access tokens in the connection. This total count may be larger than the number of nodes\nin this object when the result is paginated."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"A new external service."
input AddExternalServiceInput {
    "The kind of the external service."
    kind: ExternalServiceKind!
    "The display name of the external service."
    displayName: String!
    "The JSON configuration of the external service."
    config: String!
    "The namespace this external service belongs to.\nThis can be used both for a user and an organization."
    namespace: ID
}

"Input object for adding insight view to dashboard."
input AddInsightViewToDashboardInput {
    "ID of the insight view to attach to the dashboard"
    insightViewId: ID!
    "ID of the dashboard."
    dashboardId: ID!
}

"Information regarding the availablity of a SearchAggregationMode"
type AggregationGroup {
    "A label associated with the Aggregation for example a Repo name or Author name"
    label: String!
    "The number of hits for this search"
    count: Int!
    "A modified search query that would filter the orginal query to just the selected group"
    query: String
}

"Information regarding the availablity of a SearchAggregationMode"
type AggregationModeAvailability {
    "The SearchAggregationMode"
    mode: SearchAggregationMode!
    "Boolean indicating if the mode is available"
    available: Boolean!
    "If the mode is unavailable the reason why"
    reasonUnavailable: String
}

"An alert message shown to the viewer."
type Alert {
    "The group of this alert. Indicates what system it relates to."
    group: AlertGroup!
    "The type of this alert."
    type: AlertType!
    "The message body of this alert. Markdown is supported."
    message: String!
    "If set, this alert is dismissible. After being dismissed, no other alerts with the same\nisDismissibleWithKey value will be shown. If null, this alert is not dismissible."
    isDismissibleWithKey: String
}

"The group of alerts."
enum AlertGroup {
    AUTHENTICATION
    CODEHOST
    CODY
    LICENSE
    OBSERVABILITY
    SMTP
    UPDATE
    OTHER
}

"The possible types of alerts (Alert.type values)."
enum AlertType {
    INFO
    WARNING
    ERROR
}

"Analytics describes a new site statistics."
type Analytics {
    "Search statistics."
    search(dateRange: AnalyticsDateRange grouping: AnalyticsGrouping): AnalyticsSearchResult!
    "Notebooks statistics."
    notebooks(dateRange: AnalyticsDateRange grouping: AnalyticsGrouping): AnalyticsNotebooksResults!
    "Users statistics."
    users(dateRange: AnalyticsDateRange grouping: AnalyticsGrouping): AnalyticsUsersResult!
    "Code-intelligence statistics."
    codeIntel(dateRange: AnalyticsDateRange grouping: AnalyticsGrouping): AnalyticsCodeIntelResult!
    "Code-intelligence statistics grouped by language and precision."
    codeIntelByLanguage(dateRange: AnalyticsDateRange): [AnalyticsCodeIntelByLanguageResult!]!
    "Top repositories by code-intelligence events."
    codeIntelTopRepositories(dateRange: AnalyticsDateRange): [AnalyticsCodeIntelRepositoryResult!]!
    "Repositories summary statistics."
    repos: AnalyticsReposSummartResult!
    "Batch changes statistics"
    batchChanges(dateRange: AnalyticsDateRange grouping: AnalyticsGrouping): AnalyticsBatchChangesResult!
    "Extensions statistics"
    extensions(dateRange: AnalyticsDateRange grouping: AnalyticsGrouping): AnalyticsExtensionsResult!
    "Code insights statistics"
    codeInsights(dateRange: AnalyticsDateRange grouping: AnalyticsGrouping): AnalyticsCodesInsightsResult!
}

"Batch changes analytics."
type AnalyticsBatchChangesResult {
    "Changesets created"
    changesetsCreated: AnalyticsStatItem!
    "Changesets merged"
    changesetsMerged: AnalyticsStatItem!
}

"CodeIntelByLanguage analytics."
type AnalyticsCodeIntelByLanguageResult {
    "Language"
    language: String!
    "Precision"
    precision: String!
    "Count"
    count: Float!
}

"CodeIntelTopRepositories analytics."
type AnalyticsCodeIntelRepositoryResult {
    "Repository name"
    name: String!
    "Language"
    language: String!
    "Event kind"
    kind: String!
    "Event precision (either \"search-based\" or \"precise\")"
    precision: String!
    "Event count"
    events: Float!
    "Has precise"
    hasPrecise: Boolean!
}

"CodeIntel' analytics."
type AnalyticsCodeIntelResult {
    "\"GoToRef\" click"
    referenceClicks: AnalyticsStatItem!
    "\"GoToDef\" click"
    definitionClicks: AnalyticsStatItem!
    "Code Intel events made from web"
    inAppEvents: AnalyticsStatItem!
    "Code Intel events made from code host"
    codeHostEvents: AnalyticsStatItem!
    "Search based events"
    searchBasedEvents: AnalyticsStatItem!
    "Precise events"
    preciseEvents: AnalyticsStatItem!
    "Cross-repo events"
    crossRepoEvents: AnalyticsStatItem!
}

"Code insights analytics."
type AnalyticsCodesInsightsResult {
    "Insights hovers statistics."
    insightHovers: AnalyticsStatItem!
    "Insights data point clicks statistics."
    insightDataPointClicks: AnalyticsStatItem!
}

"A pre-defined periods to get site analytics."
enum AnalyticsDateRange {
    "Last 3 months date range."
    LAST_THREE_MONTHS
    "Last month date range."
    LAST_MONTH
    "Last week date range."
    LAST_WEEK
    "Custom date range."
    CUSTOM
}

"Extentions analytics."
type AnalyticsExtensionsResult {
    "JetBrains IDE plugin search events."
    jetbrains: AnalyticsStatItem!
    "VSCode IDE extension search events."
    vscode: AnalyticsStatItem!
    "Browser (chrome, firefox, safari) extensions code navigation events.\nThis includes events like \"Go to Def\", \"Find ref\" and \"Find implementation\""
    browser: AnalyticsStatItem!
}

"Group site analytics by period."
enum AnalyticsGrouping {
    "Group data by day."
    DAILY
    "Group data by week."
    WEEKLY
}

"Monthly active users"
type AnalyticsMonthlyActiveUsers {
    "year-month for which the total active users are calculated"
    date: String!
    "total count of active users"
    count: Float!
}

"Notebook analytics."
type AnalyticsNotebooksResults {
    "Notebooks creation analytics."
    creations: AnalyticsStatItem!
    "Notebooks views analytics."
    views: AnalyticsStatItem!
    "Notebooks block run analytics."
    blockRuns: AnalyticsStatItem!
}

"Repositories summary."
type AnalyticsReposSummartResult {
    "Total number of repositories."
    count: Float!
    "Total number of repositories with precise code-intel."
    preciseCodeIntelCount: Float!
}

"Search analytics."
type AnalyticsSearchResult {
    "Searches analytics"
    searches: AnalyticsStatItem!
    "Search result click analytics"
    resultClicks: AnalyticsStatItem!
    "File view analytics"
    fileViews: AnalyticsStatItem!
    "File open analytics"
    fileOpens: AnalyticsStatItem!
    "Code copied from search results analytics"
    codeCopied: AnalyticsStatItem!
}

"Analytics result item."
type AnalyticsStatItem {
    "Analytics summary."
    summary: AnalyticsStatItemSummary!
    "Array of analytics by period."
    nodes: [AnalyticsStatItemNode!]!
}

"Analytics for certain date."
type AnalyticsStatItemNode {
    "A date in ISO format"
    date: String!
    "Total number of events."
    count: Float!
    "Unique number of users who triggered event.\nThis counts deleted users as well as anonymous users."
    uniqueUsers: Float!
    "Unique number of currently registered users who triggered event."
    registeredUsers: Float!
}

"Analytics summary."
type AnalyticsStatItemSummary {
    "Total number of events."
    totalCount: Float!
    "Total unique number of users who triggered event.\nThis counts deleted users as well as anonymous users."
    totalUniqueUsers: Float!
    "Total unique number of currently registered users who triggered event."
    totalRegisteredUsers: Float!
}

"Users frequency by days used."
type AnalyticsUsersFrequencyItem {
    "Number of days used"
    daysUsed: Float!
    "Number of users."
    frequency: Float!
    "Percentage of users from total frequencies."
    percentage: Float!
}

"Users' analytics."
type AnalyticsUsersResult {
    "Users' activity analytics."
    activity: AnalyticsStatItem!
    "Frequency of usage by day."
    frequencies: [AnalyticsUsersFrequencyItem!]!
    "Monthly active users for last 3 months."
    monthlyActiveUsers: [AnalyticsMonthlyActiveUsers!]!
}

"AssignOwnerOrTeamInput represents the input for assigning or deleting an owner team or person."
input AssignOwnerOrTeamInput {
    "ID of an assigned owner or team."
    assignedOwnerID: ID!
    "ID of a repo, which (or which directory\/file) is assigned for ownership."
    repoID: ID!
    "Path of the file\/directory or a root path of the repo, which is assigned for ownership."
    absolutePath: String!
}

"Manually assigned owner."
type AssignedOwner {
    "Descriptive title to display in the UI for the determination."
    title: String!
    "More detailed description to display in the UI for the determination."
    description: String!
    "Whether or not this rule matches a path directly, or is inherited from a parent path."
    isDirectMatch: Boolean!
}

"Represents a state transition of a single column."
type AuditLogColumnChange {
    "The column that is changing."
    column: String!
    "The previous value of the column."
    old: String
    "The new value of the column"
    new: String
}

"Denotes the type of operation of a given log entry."
enum AuditLogOperation {
    "Denotes this log entry represents an INSERT query."
    CREATE
    "Denotes this log entry represents an UPDATE query."
    MODIFY
}

"A provider of user authentication, such as an external single-sign-on service (e.g., using OpenID Connect or\nSAML). The provider information in this type is visible to all viewers and does not contain any secret values."
type AuthProvider {
    "The type of the auth provider."
    serviceType: String!
    "An identifier for the service that the auth provider represents."
    serviceID: String!
    "An identifier for the client of the service that the auth provider represents."
    clientID: String!
    "The human-readable name of the provider."
    displayName: String!
    "Whether this auth provider is the builtin username-password auth provider."
    isBuiltin: Boolean!
    "A URL that, when visited, initiates the authentication process for this auth provider."
    authenticationURL: String
}

"A list of authentication providers."
type AuthProviderConnection {
    "A list of authentication providers."
    nodes: [AuthProvider!]!
    "The total count of authentication providers in the connection. This total count may be larger than the number of nodes\nin this object when the result is paginated."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"A description of an auto-indexing job inferred by the instance."
type AutoIndexJobDescription {
    "The project root."
    root: String!
    "The target indexer."
    indexer: CodeIntelIndexer
    "A hash of the root and indexer values.\n\nThis value can be used to quickly compare whether or not explicit configuration and inferred configuration\nrefer to the same \"project\" in a given repository. See `RootWithKey.comparisonKey`."
    comparisonKey: String!
    "The particular steps inferred for indexing."
    steps: IndexSteps!
}

"Result user returned by invite members autocomplete search."
type AutocompleteMemberSearchItem {
    "The unique ID for the user."
    id: ID!
    "The user's username."
    username: String!
    "The display name chosen by the user."
    displayName: String
    "The URL of the user's avatar image."
    avatarURL: String
    "If the user belongs to current Organization."
    inOrg: Boolean
}

"BackfillQueueOrderBy enumerates the ways a backfill queue list can be ordered."
enum BackfillQueueOrderBy {
    STATE
    QUEUE_POSITION
}

"The status of an insights backfill"
type BackfillStatus {
    "The current backfill queue state"
    state: InsightQueueItemState!
    "If the item is queued the position in the queue of"
    queuePosition: Int
    "A list of errors that have occurred during backfilling"
    errors: [String!]
    "The estimated cost of the backfill process"
    cost: Int
    "The percent complete of the backfill"
    percentComplete: Int
    "The date\/time when the backfill was created"
    createdAt: DateTime
    "The date\/time when the backfill started processing"
    startedAt: DateTime
    "The date\/time when the backfill completed processing"
    completedAt: DateTime
    "The actual runtime duration spent processing the backfill"
    runtime: String
}

"A single background job."
type BackgroundJob implements Node {
    "The background job ID."
    id: ID!
    "The name of the job."
    name: String!
    "The routines that run inside this job."
    routines: [BackgroundRoutine!]!
}

"A list of background jobs that are currently known in the system"
type BackgroundJobConnection {
    "A list of outbound requests."
    nodes: [BackgroundJob!]!
    "The total number of outbound request log items in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"A routine that runs inside a background job."
type BackgroundRoutine {
    "The name of the routine."
    name: String!
    "Tells whether this is a periodic goroutine, a DB worker, or something else"
    type: BackgroundRoutineType!
    "Explains what the routine does."
    description: String!
    "The interval at which the routine runs, if it's periodic."
    intervalMs: Int
    "The instances of this routine that are running or ran recently. An instance means one routine on one host."
    instances: [BackgroundRoutineInstance!]!
    "The recent runs of this routine."
    recentRuns: [BackgroundRoutineRecentRun!]!
    "Some stats of the runs of this routine in the past few days."
    stats: BackgroundRoutineStats!
}

"One instance of the background routine, running on a host."
type BackgroundRoutineInstance {
    "The ID of the instance."
    hostName: String!
    "The time the instance was last started. (If it's unknown, this will be null.)"
    lastStartedAt: DateTime
    "The time the instance was last stopped. (If it's unknown, this will be null.)"
    lastStoppedAt: DateTime
}

"A single run of the routine. A run is not the start\/stop event but the actual execution of the routine handler."
type BackgroundRoutineRecentRun {
    "The time the run started."
    at: DateTime!
    "The name of the host that ran the routine."
    hostName: String!
    "The duration of the run."
    durationMs: Int!
    "The error message, if any."
    errorMessage: String
}

"Holds statistics about a background routine."
type BackgroundRoutineStats {
    "The start of the earliest day for which we have any runs registered."
    since: DateTime
    "The number of times the routine ran in the period."
    runCount: Int!
    "The number of times the routine run ended with an error."
    errorCount: Int!
    "The minimum duration of a run, in milliseconds."
    minDurationMs: Int!
    "The average duration of a run, in milliseconds."
    avgDurationMs: Int!
    "The maximum duration of a run, in milliseconds."
    maxDurationMs: Int!
}

"Enum of the possible background routine types"
enum BackgroundRoutineType {
    "Periodic routine"
    PERIODIC
    "Periodic routine with metrics set up"
    PERIODIC_WITH_METRICS
    "DB-backed worker"
    DB_BACKED
    "Custom routine"
    CUSTOM
}

"A batch change is a set of related changes to apply to code across one or more repositories."
type BatchChange implements Node {
    "The unique ID for the batch change."
    id: ID!
    "The namespace where this batch change is defined."
    namespace: Namespace!
    "The name of the batch change."
    name: String!
    "The description (as Markdown)."
    description: String
    "The state of the batch change."
    state: BatchChangeState!
    "The user who created the batch change, or null if the user was deleted."
    creator: User
    "The user who last updated the batch change by applying a spec to this batch change.\nIf the batch change hasn't been updated, the lastApplier is the initialApplier, or null if the user was deleted."
    lastApplier: User
    "Whether the current user can edit or delete this batch change."
    viewerCanAdminister: Boolean!
    "The URL to this batch change."
    url: String!
    "The date and time when the batch change was created."
    createdAt: DateTime!
    "The date and time when the batch change was updated. That can be by applying a spec, or by an internal process.\nFor reading the time the batch change spec was changed last, see lastAppliedAt."
    updatedAt: DateTime!
    "The date and time when the batch change was last updated with a new spec. Null, if a batch spec has never been\napplied yet."
    lastAppliedAt: DateTime
    "The date and time when the batch change was closed. If set, applying a spec for this batch change will fail with an error."
    closedAt: DateTime
    "Stats on all the changesets that are tracked in this batch change."
    changesetsStats: ChangesetsStats!
    "The changesets in this batch change that already exist on the code host."
    changesets(first: Int = 50 "Opaque pagination cursor." after: String "Only include changesets with the given state." state: ChangesetState "Query only changesets that are either open or draft. This is used on the close page to list changesets that remain open.\nWhen set, passing state is not allowed." onlyClosable: Boolean "Only include changesets with the given review state.\n\nNote: The COMMENTED and DISMISSED review states are not yet implemented." reviewState: ChangesetReviewState "Only include changesets with the given check state." checkState: ChangesetCheckState "Only return changesets that have been published by this batch change. Imported changesets will be omitted." onlyPublishedByThisBatchChange: Boolean "Search for changesets matching this query. Queries may include quoted substrings to match phrases, and words may be preceded by - to negate them." search: String "Only return changesets that are archived in this batch change." onlyArchived: Boolean = false "Only include changesets belonging to the given repository." repo: ID): ChangesetConnection!
    "The changeset counts over time, in 1-day intervals backwards from the point in time given in\nthe \"to\" parameter."
    changesetCountsOverTime("Only include changeset counts up to this point in time (inclusive). Defaults to BatchChange.createdAt." from: DateTime "Only include changeset counts up to this point in time (inclusive). Defaults to the\ncurrent time." to: DateTime "Include archived changesets in the calculation." includeArchived: Boolean = false): [ChangesetCounts!]!
    "The diff stat for all the changesets in the batch change."
    diffStat: DiffStat!
    "The last batch spec applied to this batch change, or an \"empty\" spec if the batch\nchange has never had a spec applied."
    currentSpec: BatchSpec!
    "The bulk operations that have been run over this batch change."
    bulkOperations("Returns the first n entries from the list." first: Int = 50 "Opaque pagination cursor." after: String "Filter by createdAt value." createdAfter: DateTime): BulkOperationConnection!
    "The batch specs that have been running on this batch change.\n\nSite-admins can see all of them, non admins can only see batch specs that they\ncreated."
    batchSpecs("Returns the first n entries from the list." first: Int = 50 "Opaque pagination cursor." after: String "Include locally executed (i.e. with src-cli) batch specs in the list of specs returned." includeLocallyExecutedSpecs: Boolean "Exclude the empty batch specs that are initially created and applied to draft batch changes." excludeEmptySpecs: Boolean): BatchSpecConnection!
}

"A list of batch changes."
type BatchChangeConnection {
    "A list of batch changes."
    nodes: [BatchChange!]!
    "The total number of batch changes in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"A BatchChangeDescription describes a batch change."
type BatchChangeDescription {
    "The name as parsed from the input."
    name: String!
    "The description as parsed from the input."
    description: String!
}

"The state of the batch change."
enum BatchChangeState {
    OPEN
    CLOSED
    DRAFT
}

"A code host usable with batch changes. This service is accessible by the user it belongs to."
type BatchChangesCodeHost {
    "The kind of external service."
    externalServiceKind: ExternalServiceKind!
    "The URL of the external service."
    externalServiceURL: String!
    "The configured credential, if any."
    credential: BatchChangesCredential
    "Configuration for commit signing, if any has been set up. Always nil if the code\nhost type doesn't have commit signing support yet."
    commitSigningConfiguration: CommitSigningConfiguration
    "If true, some of the repositories on this code host require\nan SSH key to be configured."
    requiresSSH: Boolean!
    "If true, this code host requires credentials to have a username as well as a personal access token."
    requiresUsername: Boolean!
    "If true, this code host can setup commit signing."
    supportsCommitSigning: Boolean!
    "If true, the code host has webhooks configured."
    hasWebhooks: Boolean!
}

"A connection of all code hosts usable with batch changes and accessible by the user\nthis is requested on."
type BatchChangesCodeHostConnection {
    "A list of code hosts."
    nodes: [BatchChangesCodeHost!]!
    "The total number of configured external services in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"A user token configured for batch changes use on the specified code host."
type BatchChangesCredential implements Node {
    "A globally unique identifier."
    id: ID!
    "The kind of external service."
    externalServiceKind: ExternalServiceKind!
    "The URL of the external service."
    externalServiceURL: String!
    "The public key to use on the external service for SSH keypair authentication.\nNot set if the credential doesn't support SSH access."
    sshPublicKey: String
    "The date and time this token has been created at."
    createdAt: DateTime!
    "Whether the configured credential is a site credential, that is available globally."
    isSiteCredential: Boolean!
}

"A batch spec is an immutable description of the desired state of a batch change. To create a\nbatch spec, use the createBatchSpec mutation."
type BatchSpec implements Node {
    "The unique ID for a batch spec.\n\nThe ID is unguessable (i.e., long and randomly generated, not sequential).\nConsider a batch change to fix a security vulnerability: the batch change author may prefer\nto prepare the batch change, including the description in private so that the window\nbetween revealing the problem and merging the fixes is as short as possible."
    id: ID!
    "Future: Flag that calls applyBatchChange automatically when this execution completes.\nUseful for integrations with code monitoring etc.\n\nTODO: Not implemented yet."
    autoApplyEnabled: Boolean!
    "The current execution state of the batch spec. For manually created ones (src-cli workflow),\nthis will always be COMPLETED. This is an accumulated state over all the associated\nworkspaces for convenience."
    state: BatchSpecState!
    "The original YAML or JSON input that was used to create this batch spec."
    originalInput: String!
    "The parsed JSON value of the original input. If the original input was YAML, the YAML is\nconverted to the equivalent JSON."
    parsedInput: JSONValue!
    "The BatchChangeDescription that describes this batch change."
    description: BatchChangeDescription!
    "Generates a preview showing the operations that would be performed if the\nbatch spec was applied. This preview is not a guarantee, since the state\nof the changesets can change between the time the preview is generated and\nwhen the batch spec is applied."
    applyPreview("Returns the first n entries from the list." first: Int = 50 "Opaque pagination cursor." after: String "Search for changesets matching this query. Queries may include quoted substrings to match phrases, and words may be preceded by - to negate them." search: String "Search for changesets that are currently in this state." currentState: ChangesetState "Search for changesets that will have the given action performed." action: ChangesetSpecOperation "If set, it will be assumed that these changeset specs will have their\nUI publication states set to the given values when the batch spec is\napplied.\n\nAn error will be returned if the same changeset spec ID is included\nmore than once in the array, or if a changeset spec ID returned within\nthis page has a publication state set in its spec.\n\nNote: Unlike createBatchChange(), this query will not validate that all\nchangeset specs in the array correspond to valid changeset specs within\nthe batch spec, as they may not all be loaded on the current page." publicationStates: [ChangesetSpecPublicationStateInput!]): ChangesetApplyPreviewConnection!
    "The specs for changesets associated with this batch spec."
    changesetSpecs(first: Int = 50 after: String): ChangesetSpecConnection!
    "The user who created this batch spec. Their permissions will be honored when\nexecuting the batch spec. Null, if the user has been deleted."
    creator: User
    "The time when the batch spec was created at. At this time, it is also added to\nthe queue for execution, if created from raw."
    createdAt: DateTime!
    "The time when the execution started. Null, if the execution hasn't started\nyet, or if the batch spec was created in COMPLETED state."
    startedAt: DateTime
    "The time when the execution finished. Null, if the execution hasn't finished\nyet, or if the batch spec was created in COMPLETED state.\nThis value is the time of when the batch spec has been sealed."
    finishedAt: DateTime
    "The namespace (either a user or organization) of the batch spec."
    namespace: Namespace!
    "The date, if any, when this batch spec expires and is automatically purged. A batch spec\nnever expires if it has been applied."
    expiresAt: DateTime
    "The URL of a web page that allows applying this batch spec and\ndisplays a preview of which changesets will be created by applying it.\nNull, if the execution has not finished yet."
    applyURL: String
    "When true, the viewing user can apply this spec, modify it, and run workspace\nresolution jobs."
    viewerCanAdminister: Boolean!
    "The diff stat for all the changeset specs in the batch spec. Null if state is\nnot COMPLETED."
    diffStat: DiffStat
    "The batch change this spec will update when applied. If it's null, the\nbatch change doesn't yet exist."
    appliesToBatchChange: BatchChange
    "The newest version of this batch spec, as identified by its namespace\nand name. If this is the newest version, this field will be null."
    supersedingBatchSpec: BatchSpec
    "The code host connections required for applying this spec. Includes the credentials of the current user.\nOnly returns useful information if state is COMPLETED."
    viewerBatchChangesCodeHosts("Returns the first n code hosts from the list." first: Int = 50 "Opaque pagination cursor." after: String "Only returns the code hosts for which the viewer doesn't have credentials." onlyWithoutCredential: Boolean = false "Only returns code hosts that don't have webhooks configured." onlyWithoutWebhooks: Boolean = false): BatchChangesCodeHostConnection!
    "A wrapper for the workspace resolution on this batch spec. Contains access to\nall workspaces that have been resolved, as well as insight into the state of\nthe resolution.\nNull, if the batch spec was created in COMPLETED state."
    workspaceResolution: BatchSpecWorkspaceResolution
    "The set of changeset specs for importing changesets, as determined from the\nraw spec.\nNull, if not created through createBatchSpecFromRaw."
    importingChangesets(first: Int = 50 after: String search: String): ChangesetSpecConnection
    "Set when something about this batch spec is not right. For example, the input spec\nis invalid, or if ValidateChangesetSpecs throws an error when the last job completes."
    failureMessage: String
    "If true, repos with a .batchignore file will still be included in the\nexecution.\n\nNull, if not created through createBatchSpecFromRaw."
    allowIgnored: Boolean
    "If true, repos on unsupported codehosts will be included in the execution.\nThese cannot be published.\n\nNull, if not created through createBatchSpecFromRaw."
    allowUnsupported: Boolean
    "If true, workspaces will not run with cached results.\n\nNull, if not created through createBatchSpecFromRaw."
    noCache: Boolean
    "If true, viewer can retry the batch spec execution by calling\nretryBatchSpecExecution."
    viewerCanRetry: Boolean!
    "Whether the batch spec was created from the local src-cli workflow or remotely for\nserver-side execution."
    source: BatchSpecSource!
    "The files that are mounted in the steps of a batch spec."
    files("Returns the first n files from the list." first: Int = 50 "Opaque pagination cursor." after: String): BatchSpecWorkspaceFileConnection
}

"A list of batch specs."
type BatchSpecConnection {
    "The total number of batch specs in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
    "A list of batch specs."
    nodes: [BatchSpec!]!
}

"The possible sources of a batch spec."
enum BatchSpecSource {
    "The spec was created from the local src-cli workflow."
    LOCAL
    "This spec was created for remote server-side execution, e.g. from the web UI editor,\nor with src batch remote."
    REMOTE
}

"The possible states of a batch spec."
enum BatchSpecState {
    "The spec is not yet enqueued for processing."
    PENDING
    "This spec is being processed."
    PROCESSING
    "This spec failed to be processed."
    FAILED
    "This spec was processed successfully."
    COMPLETED
    "This spec is queued to be processed."
    QUEUED
    "The execution is being canceled."
    CANCELING
    "The execution has been canceled."
    CANCELED
}

"The common interface for a batch spec workspace. Depending on access to the repository,\neither a HiddenBatchSpecWorkspace or a VisibleBatchSpecWorkspace will be serving this\ninterface."
interface BatchSpecWorkspace {
    "The unique ID for the workspace."
    id: ID!
    "Used for reverse querying."
    batchSpec: BatchSpec!
    "If true, only the files within the workspace will be fetched."
    onlyFetchWorkspace: Boolean!
    "If true, this workspace has been skipped, because some rule forced this.\nFor now, the only one is a .batchignore file existing in the repository."
    ignored: Boolean!
    "If true, this workspace has been skipped, because the code host on which\nthe repository is hosted is not supported."
    unsupported: Boolean!
    "Whether we found a task cache result."
    cachedResultFound: Boolean!
    "How many steps had a cached result."
    stepCacheResultCount: Int!
    "The time when the workspace was enqueued for processing. Null, if not yet enqueued."
    queuedAt: DateTime
    "The time when the workspace started processing. Null, if not yet started."
    startedAt: DateTime
    "The time when the workspace finished processing. Null, if not yet finished."
    finishedAt: DateTime
    "The current state the workspace is in."
    state: BatchSpecWorkspaceState!
    "The rank of this execution in the queue of the user. The value of this field is null if the\nexecution has started."
    placeInQueue: Int
    "The rank of this execution in the global queue. The value of this field is null if the\nexecution has started."
    placeInGlobalQueue: Int
    "The diff stat over all created changeset specs. Null, if not yet finished or\nfailed."
    diffStat: DiffStat
}

"A list of workspaces."
type BatchSpecWorkspaceConnection {
    "The total number of workspaces in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
    "A list of workspaces."
    nodes: [BatchSpecWorkspace!]!
    "Statistics on the workspaces in this connection."
    stats: BatchSpecWorkspacesStats!
}

"An enviroment variable passed to a command in a step."
type BatchSpecWorkspaceEnvironmentVariable {
    "The variable name."
    name: String!
    "The variable value.\nIf null, the variable will be populated from a secret."
    value: String
}

"The metadata of a file being used in a batch spec step."
type BatchSpecWorkspaceFile implements File2 & Node {
    "The ID of the file."
    id: ID!
    "When the file was last touched."
    modifiedAt: DateTime!
    "When the file is initially created at."
    createdAt: DateTime!
    "When the file is updated at."
    updatedAt: DateTime!
    "The full path (relative to the root) of this file."
    path: String!
    "The base name (i.e., file name only) of this file."
    name: String!
    "False because this is a file, not a directory."
    isDirectory: Boolean!
    "The content of this file."
    content("Return file content starting at line \"startLine\". A value <= 0 will be the start of the file." startLine: Int "Return file content ending at line \"endLine\". A value < 0 or > totalLines will set endLine to the end of the file." endLine: Int): String!
    "The file size in bytes."
    byteSize: Int!
    "Total line count for the Blob. Returns 0 for binary files."
    totalLines: Int!
    "Whether or not it is binary."
    binary: Boolean!
    "The file rendered as rich HTML, or an empty string if it is not a supported\nrich file type.\nThis HTML string is already escaped and thus is always safe to render."
    richHTML("Return richHTML content starting at line \"startLine\". A value <= 0 will be the start of the file." startLine: Int "Return richHTML content ending at line \"endLine\". A value < 0 or > totalLines will set endLine to the end of the file." endLine: Int): String!
    "The URL to this file (using the input revision specifier, which may not be immutable)."
    url: String!
    "The canonical URL to this file (using an immutable revision specifier)."
    canonicalURL: String!
    "Not implemented."
    changelistURL: String
    "The URLs to this file on external services."
    externalURLs: [ExternalLink!]!
    "Highlight the file."
    highlight(disableTimeout: Boolean! isLightTheme: Boolean "If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.\n2000 bytes is enabled. This may produce a significant amount of HTML\nwhich some browsers (such as Chrome, but not Firefox) may have trouble\nrendering efficiently." highlightLongLines: Boolean = false "Specifies which format\/highlighting technique to use." format: HighlightResponseFormat = HTML_HIGHLIGHT "Return highlight content starting at line \"startLine\". A value <= 0 will be the start of the file.\nWarning: Pagination only works with the HTML_PLAINTEXT format type at the moment." startLine: Int "Return highlight content ending at line \"endLine\". A value < 0 or > totalLines will set endLine to the end of the file.\nWarning: Pagination only works with the HTML_PLAINTEXT format type at the moment." endLine: Int): HighlightedFile!
}

"A list of BatchSpecMounts."
type BatchSpecWorkspaceFileConnection {
    "The total number of files."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
    "A list of workspace files in a batch spec."
    nodes: [BatchSpecWorkspaceFile!]!
}

"An output variable in a step."
type BatchSpecWorkspaceOutputVariable {
    "The variable name."
    name: String!
    "The variable value."
    value: JSONValue!
}

"A bag for all info around resolving workspaces."
type BatchSpecWorkspaceResolution {
    "Error message, if the evaluation failed."
    failureMessage: String
    "Set when evaluating workspaces begins."
    startedAt: DateTime
    "Set when evaluating workspaces finished."
    finishedAt: DateTime
    "State of evaluating the workspaces."
    state: BatchSpecWorkspaceResolutionState!
    "The actual list of determined workspaces."
    workspaces(first: Int = 50 after: String "Not implemented." orderBy: WorkspacesSortOrder "Search for workspaces matching this query. Queries may include quoted substrings\nto match phrases, and words may be preceded by - to negate them.\nCurrently, this supports searching repository names only.\nRepos that are not visible to the viewer will be omitted entirely when\nthis argument is passed." search: String "Filter workspaces by given state." state: BatchSpecWorkspaceState): BatchSpecWorkspaceConnection!
    "Returns the workspaces where most recently a step completed that yielded a diff."
    recentlyCompleted(first: Int = 50 after: String): BatchSpecWorkspaceConnection!
    "Returns the most recently failed workspace executions."
    recentlyErrored(first: Int = 50 after: String): BatchSpecWorkspaceConnection!
}

"State of the workspace resolution."
enum BatchSpecWorkspaceResolutionState {
    "Not yet started resolving. Will be picked up by a worker eventually."
    QUEUED
    "Currently resolving workspaces."
    PROCESSING
    "An error occured while resolving workspaces. Will be retried eventually."
    ERRORED
    "A fatal error occured while resolving workspaces. No retries will be made."
    FAILED
    "Resolving workspaces finished successfully."
    COMPLETED
}

"Configuration and execution summary of a batch spec execution. This is mostly\nmeant for internal consumption, for the timeline view."
type BatchSpecWorkspaceStages {
    "Execution log entries related to setting up the workspace."
    setup: [ExecutionLogEntry!]!
    "Execution log entries related to running the steps of the batch spec."
    srcExec: [ExecutionLogEntry!]!
    "Execution log entries related to tearing down the workspace."
    teardown: [ExecutionLogEntry!]!
}

"The states a workspace can be in."
enum BatchSpecWorkspaceState {
    "The workspace will not be enqueued for execution, because either the\nworkspace is unsupported\/ignored or has 0 steps to execute."
    SKIPPED
    "The workspace is not yet enqueued for execution."
    PENDING
    "Not yet started executing. Will be picked up by a worker eventually."
    QUEUED
    "Currently executing on the workspace."
    PROCESSING
    "A fatal error occured while executing. No retries will be made."
    FAILED
    "Execution finished successfully."
    COMPLETED
    "Execution is being canceled. This is an async process."
    CANCELING
    "Execution has been canceled."
    CANCELED
}

"Description of one step in the execution of a workspace."
type BatchSpecWorkspaceStep {
    "The number of the step."
    number: Int!
    "The command to run."
    run: String!
    "The docker container image to use to run this command."
    container: String!
    "The if condition, under which the step is executed. Null, if not set."
    ifCondition: String
    "True, if a cached result has been found."
    cachedResultFound: Boolean!
    "True, when the `if` condition evaluated that this step doesn't need to run."
    skipped: Boolean!
    "The output logs, prefixed with either \"stdout \" or \"stderr \". Null, if the\nstep has not run yet."
    outputLines("Return the first N lines of logs." first: Int = 500 "Return the log lines after N lines." after: String): BatchSpecWorkspaceStepOutputLineConnection!
    "The time when the step started processing. Null, if not yet started."
    startedAt: DateTime
    "The time when the step finished processing. Null, if not yet finished."
    finishedAt: DateTime
    "The exit code of the command. Null, if not yet finished."
    exitCode: Int
    "The environment variables passed to this step."
    environment: [BatchSpecWorkspaceEnvironmentVariable!]!
    "The output variables the step produced. Null, if not yet finished."
    outputVariables: [BatchSpecWorkspaceOutputVariable!]
    "The diff stat of the step result. Null, if not yet finished."
    diffStat: DiffStat
    "The generated diff from this step. Null, if not yet finished."
    diff: PreviewRepositoryComparison
}

"A list of Output lines from a Batch spec workspace."
type BatchSpecWorkspaceStepOutputLineConnection {
    "The total number of output lines in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
    "A list of output lines."
    nodes: [String!]!
}

"Statistics on all workspaces in a connection."
type BatchSpecWorkspacesStats {
    "Number of errored workspaces."
    errored: Int!
    "Number of completed workspaces."
    completed: Int!
    "Number of processing workspaces."
    processing: Int!
    "Number of queued workspaces."
    queued: Int!
    "Number of ignored workspaces."
    ignored: Int!
}

"A set of Git behind\/ahead counts for one commit relative to another."
type BehindAheadCounts {
    "The number of commits behind the other commit."
    behind: Int!
    "The number of commits ahead of the other commit."
    ahead: Int!
}

"Pagination information for bi-directional pagination. See https:\/\/facebook.github.io\/relay\/graphql\/connections.htm#sec-undefined.PageInfo."
type BidirectionalPageInfo {
    "When paginating backwards, the cursor to continue."
    startCursor: String
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
}

"An arbitrarily large integer encoded as a decimal string."
scalar BigInt

"Information about a single Projects permission synchronization job."
type BitbucketProjectPermissionJob {
    "Internal ID of the job."
    InternalJobID: Int!
    "State of the job (queued, processing, completed, canceled, errored, failed)."
    State: String!
    "Failure message in case of unsuccessful job execution."
    FailureMessage: String
    "The time when the job was enqueued for processing."
    QueuedAt: DateTime!
    "The time when the job started processing. Null, if not yet started."
    StartedAt: DateTime
    "The time when the job finished processing. Null, if not yet finished."
    FinishedAt: DateTime
    "Controls the time after which the job is visible for processing."
    ProcessAfter: DateTime
    "The number of times when the job is moved back from failed to queued."
    NumResets: Int!
    "The number of times when the job entered the errored state."
    NumFailures: Int!
    "Bitbucket project key."
    ProjectKey: String!
    "ID of external service which project is being synchronized."
    ExternalServiceID: ID!
    "User permissions to be granted."
    Permissions: [UserPermission!]!
    "Shows that current project is accessible by any user of the project."
    Unrestricted: Boolean!
}

"Information about Bitbucket Projects permission synchronization jobs."
type BitbucketProjectPermissionJobs {
    "Number of jobs."
    totalCount: Int!
    "Bitbucket Projects permission sync jobs."
    nodes: [BitbucketProjectPermissionJob!]!
}

"A bulk operation represents a group of jobs run over a set of changesets in a batch change."
type BulkOperation implements Node {
    "The unique ID for the bulk operation."
    id: ID!
    "The type of task that is run."
    type: BulkOperationType!
    "The current state of the bulk operation."
    state: BulkOperationState!
    "The progress to completion of all executions involved in this bulk operation. Value\nranges from 0.0 to 1.0."
    progress: Float!
    "The list of all errors that occured while processing the bulk action."
    errors: [ChangesetJobError!]!
    "The time the bulk operation was created at."
    createdAt: DateTime!
    "The time the bulk operation finished. Also set, when some operations failed. Null,\nwhen some operations are still processing."
    finishedAt: DateTime
    "The user who triggered this bulk operation."
    initiator: User!
    "The number of changesets involved in this bulk operation."
    changesetCount: Int!
}

"A list of bulk operations."
type BulkOperationConnection {
    "The total number of bulk operations in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
    "A list of bulk operations."
    nodes: [BulkOperation!]!
}

"All valid states a bulk operation can be in."
enum BulkOperationState {
    "The bulk operation is still processing on some changesets."
    PROCESSING
    "No operations are still running and all of them finished without error."
    COMPLETED
    "No operations are still running and at least one of them finished with an error."
    FAILED
}

"The available types of jobs that can be run over a batch change."
enum BulkOperationType {
    "Bulk post comments over all involved changesets."
    COMMENT
    "Bulk detach changesets from a batch change."
    DETACH
    "Bulk reenqueue failed changesets."
    REENQUEUE
    "Bulk merge changesets."
    MERGE
    "Bulk close changesets."
    CLOSE
    "Bulk publish changesets."
    PUBLISH
}

"A status message of a permissions sync job cancellation."
enum CancelPermissionsSyncJobResultMessage {
    SUCCESS
    NOT_FOUND
    ERROR
}

"A changeset on a codehost."
interface Changeset {
    "The unique ID for the changeset."
    id: ID!
    "The batch changes that contain this changeset."
    batchChanges("Returns the first n batch changes from the list." first: Int = 50 "Opaque pagination cursor." after: String "Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`." state: BatchChangeState "Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it." states: [BatchChangeState!] "Only include batch changes that the viewer can administer." viewerCanAdminister: Boolean): BatchChangeConnection!
    "The state of the changeset."
    state: ChangesetState!
    "The date and time when the changeset was created."
    createdAt: DateTime!
    "The date and time when the changeset was updated."
    updatedAt: DateTime!
    "The date and time when the next changeset sync is scheduled, or null if none is scheduled."
    nextSyncAt: DateTime
}

"A preview for which actions applyBatchChange would result in when called at the point of time this preview was created at."
union ChangesetApplyPreview = VisibleChangesetApplyPreview | HiddenChangesetApplyPreview

"A list of preview entries."
type ChangesetApplyPreviewConnection {
    "The total number of entries in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
    "A list of preview entries."
    nodes: [ChangesetApplyPreview!]!
    "Stats on the elements in this connnection. Does not respect pagination parameters."
    stats: ChangesetApplyPreviewConnectionStats!
}

"Aggregated stats on nodes in this connection."
type ChangesetApplyPreviewConnectionStats {
    "The amount of new commits from the batch change in this operation."
    push: Int!
    "The amount of existing changeset that will be updated from the batch change in this operation."
    update: Int!
    "The amount of changesets that will be un-drafted from the batch change in this operation."
    undraft: Int!
    "The amount of changesets that will be pubished from the batch change in this operation."
    publish: Int!
    "The amount of changesets that will be published as a draft from the batch change in this operation."
    publishDraft: Int!
    "The amount of changesets that will be synced from the batch change in this operation."
    sync: Int!
    "The amount of changesets that will be imported from the batch change in this operation."
    import: Int!
    "The amount of changesets that will be closed from the batch change in this operation."
    close: Int!
    "The amount of changesets that will be re-opened from the batch change in this operation."
    reopen: Int!
    "Internal operation to get around slow code host updates."
    sleep: Int!
    "The amount of changesets that will be removed from the batch change in this operation."
    detach: Int!
    "The amount of changesets that will be archived from the batch change in this operation."
    archive: Int!
    "The amount of changesets that are added to the batch change in this operation."
    added: Int!
    "The amount of changesets that are already attached to the batch change and modified in this operation."
    modified: Int!
    "The amount of changesets that are disassociated from the batch change in this operation."
    removed: Int!
    "The amount of changesets that will be re-added from the batch change in this operation."
    reattach: Int!
}

"The state of checks (e.g., for continuous integration) on a changeset."
enum ChangesetCheckState {
    PENDING
    PASSED
    FAILED
}

"A list of changesets."
type ChangesetConnection {
    "A list of changesets."
    nodes: [Changeset!]!
    "The total number of changesets in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"The counts of changesets in certain states at a specific point in time."
type ChangesetCounts {
    "The point in time these counts were recorded."
    date: DateTime!
    "The total number of changesets."
    total: Int!
    "The number of merged changesets."
    merged: Int!
    "The number of closed changesets."
    closed: Int!
    "The number of draft changesets (independent of review state)."
    draft: Int!
    "The number of open changesets (independent of review state)."
    open: Int!
    "The number of changesets that are both open and approved."
    openApproved: Int!
    "The number of changesets that are both open and have requested changes."
    openChangesRequested: Int!
    "The number of changesets that are both open and are pending review."
    openPending: Int!
}

"All possible types of changesets that can be specified in a changeset spec."
union ChangesetDescription = ExistingChangesetReference | GitBranchChangesetDescription

"A changeset event in a code host (e.g., a comment on a pull request on GitHub)."
type ChangesetEvent implements Node {
    "The unique ID for the changeset event."
    id: ID!
    "The changeset this event belongs to."
    changeset: ExternalChangeset!
    "The date and time when the changeset was created."
    createdAt: DateTime!
}

"A list of changeset events."
type ChangesetEventConnection {
    "A list of changeset events."
    nodes: [ChangesetEvent!]!
    "The total number of changeset events in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"The state of a changeset on the code host on which it's hosted."
enum ChangesetExternalState {
    DRAFT
    OPEN
    CLOSED
    MERGED
    READONLY
    DELETED
}

"A reported error on a changeset in a bulk operation."
type ChangesetJobError {
    "The changeset this error is related to."
    changeset: Changeset!
    "The error message. Null, if the changeset is not accessible by the requesting\nuser."
    error: String
}

"A label attached to a changeset on a code host."
type ChangesetLabel {
    "The label's text."
    text: String!
    "The label's color, as a hex color code without the . For example: \"93ba13\"."
    color: String!
    "An optional description of the label."
    description: String
}

"The publication state of a changeset on Sourcegraph"
enum ChangesetPublicationState {
    "The changeset has not yet been created on the code host."
    UNPUBLISHED
    "The changeset has been created on the code host."
    PUBLISHED
}

"The reconciler state of a changeset on Sourcegraph"
enum ChangesetReconcilerState {
    "The changeset is scheduled, and will be enqueued when its turn comes in Sourcegraph's rollout window."
    SCHEDULED
    "The changeset is enqueued for the reconciler to process it."
    QUEUED
    "The changeset reconciler is currently computing the delta between the\nIf a delta exists, the reconciler tries to update the state of the\nchangeset on the code host and on Sourcegraph to the desired state."
    PROCESSING
    "The changeset reconciler ran into a problem while processing the\nchangeset and will retry it for a number of retries."
    ERRORED
    "The changeset reconciler ran into a problem while processing the\nchangeset that can't be fixed by retrying."
    FAILED
    "The changeset is not enqueued for processing."
    COMPLETED
}

"The review state of a changeset."
enum ChangesetReviewState {
    APPROVED
    CHANGES_REQUESTED
    PENDING
    COMMENTED
    DISMISSED
}

"A changeset spec is an immutable description of the desired state of a changeset in a batch change. To\ncreate a changeset spec, use the createChangesetSpec mutation."
interface ChangesetSpec {
    "The unique ID for a changeset spec.\n\nThe ID is unguessable (i.e., long and randomly generated, not sequential). This is important\neven though repository permissions also apply to viewers of changeset specs, because being\nallowed to view a repository should not entitle a person to view all not-yet-published\nchangesets for that repository. Consider a batch change to fix a security vulnerability: the\nbatch change author may prefer to prepare all of the changesets in private so that the window\nbetween revealing the problem and merging the fixes is as short as possible."
    id: ID!
    "The type of changeset spec."
    type: ChangesetSpecType!
    "The date, if any, when this changeset spec expires and is automatically purged. A changeset\nspec never expires (and this field is null) if its batch spec has been applied."
    expiresAt: DateTime
}

"A list of changeset specs."
type ChangesetSpecConnection {
    "The total number of changeset specs in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
    "A list of changeset specs."
    nodes: [ChangesetSpec!]!
}

"Description of the current changeset state vs the changeset spec desired state."
type ChangesetSpecDelta {
    "When run, the title of the changeset will be updated."
    titleChanged: Boolean!
    "When run, the body of the changeset will be updated."
    bodyChanged: Boolean!
    "When run, the changeset will be taken out of draft mode."
    undraft: Boolean!
    "When run, the target branch of the changeset will be updated."
    baseRefChanged: Boolean!
    "When run, a new commit will be created on the branch of the changeset."
    diffChanged: Boolean!
    "When run, a new commit will be created on the branch of the changeset."
    commitMessageChanged: Boolean!
    "When run, a new commit in the name of the specified author will be created on the branch of the changeset."
    authorNameChanged: Boolean!
    "When run, a new commit in the name of the specified author will be created on the branch of the changeset."
    authorEmailChanged: Boolean!
}

"This enum declares all operations supported by the reconciler."
enum ChangesetSpecOperation {
    "Push a new commit to the code host."
    PUSH
    "Update the existing changeset on the codehost. This is purely the changeset resource on the code host,\nnot the git commit. For updates to the commit, see 'PUSH'."
    UPDATE
    "Move the existing changeset out of being a draft."
    UNDRAFT
    "Publish a changeset to the codehost."
    PUBLISH
    "Publish a changeset to the codehost as a draft changeset. (Only on supported code hosts)."
    PUBLISH_DRAFT
    "Sync the changeset with the current state on the codehost."
    SYNC
    "Import an existing changeset from the code host with the ExternalID from the spec."
    IMPORT
    "Close the changeset on the codehost."
    CLOSE
    "Reopen the changeset on the codehost."
    REOPEN
    "Internal operation to get around slow code host updates."
    SLEEP
    "The changeset is removed from some of the associated batch changes."
    DETACH
    "The changeset is kept in the batch change, but it's marked as archived."
    ARCHIVE
    "The changeset is re-added to the batch change."
    REATTACH
}

"A ChangesetSpecPublicationStateInput is a tuple containing a changeset spec ID\nand its desired UI publication state."
input ChangesetSpecPublicationStateInput {
    "The changeset spec ID."
    changesetSpec: ID!
    "The desired publication state."
    publicationState: PublishedValue!
}

"The type of the changeset spec."
enum ChangesetSpecType {
    "References an existing changeset on a code host to be imported."
    EXISTING
    "References a branch and a patch to be applied to create the changeset from."
    BRANCH
}

"The visual state a changeset is currently in."
enum ChangesetState {
    "The changeset has not been marked as to be published."
    UNPUBLISHED
    "The changeset reconciler ran into a problem while processing the\nchangeset that can't be fixed by retrying."
    FAILED
    "The changeset reconciler ran into a problem while processing the\nchangeset and will retry it for a number of retries."
    RETRYING
    "The changeset is scheduled, and will be enqueued when its turn comes in Sourcegraph's rollout window."
    SCHEDULED
    "The changeset reconciler is currently computing the delta between the\nIf a delta exists, the reconciler tries to update the state of the\nchangeset on the code host and on Sourcegraph to the desired state."
    PROCESSING
    "The changeset is published, not being reconciled and open on the code host."
    OPEN
    "The changeset is published, not being reconciled and in draft state on the code host."
    DRAFT
    "The changeset is published, not being reconciled and closed on the code host."
    CLOSED
    "The changeset is published, not being reconciled and merged on the code host."
    MERGED
    "The changeset is published, and is now read-only, most likely due to the\nrepository being archived."
    READONLY
    "The changeset is published, not being reconciled and has been deleted on the code host."
    DELETED
}

"Used in the batch change page for the overview component."
type ChangesetsStats {
    "The count of unpublished changesets."
    unpublished: Int!
    "The count of draft changesets."
    draft: Int!
    "The count of open changesets."
    open: Int!
    "The count of merged changesets."
    merged: Int!
    "The count of closed changesets."
    closed: Int!
    "The count of deleted changesets."
    deleted: Int!
    "The count of changesets in retrying state."
    retrying: Int!
    "The count of changesets in failed state."
    failed: Int!
    "The count of changesets in the scheduled state."
    scheduled: Int!
    "The count of changesets that are currently processing or enqueued to be."
    processing: Int!
    "The count of archived changesets."
    archived: Int!
    "The count of all changesets."
    total: Int!
    "If true, then all changesets are either merged or closed. This indicates that the batch change is completed."
    isCompleted: Boolean!
    "The count of changesets that are complete (i.e in a merged or closed state) and not archived or deleted."
    percentComplete: Int!
}

"The result for Mutation.checkMirrorRepositoryConnection."
type CheckMirrorRepositoryConnectionResult {
    "The error message encountered during the update operation, if any. If null, then\nthe connection check succeeded."
    error: String
}

"A set of matched ranges contained in a chunk of contiguous lines."
type ChunkMatch {
    "The contiguous set of full lines which contain the matches in ranges."
    content: String!
    "The location of the beginning of content."
    contentStart: Position!
    "The set of ranges within the content that matched the search query."
    ranges: [Range!]!
}

"Configuration details for the browser extension, editor extensions, etc."
type ClientConfigurationDetails {
    "The list of phabricator\/gitlab\/bitbucket\/etc instance URLs that specifies which pages the content script will be injected into."
    contentScriptUrls: [String!]!
    "Returns details about the parent Sourcegraph instance."
    parentSourcegraph: ParentSourcegraphDetails!
}

"The clone status of a repository."
enum CloneStatus {
    NOT_CLONED
    CLONING
    CLONED
}

"FOR INTERNAL USE ONLY: A status message produced when repositories are being\ncloned"
type CloningProgress {
    "The message of this status message"
    message: String!
}

"A specific code host, like github.com."
type CodeHost implements Node {
    "The id of the code host."
    id: ID!
    "The type of code host, e.g. GITHUB."
    kind: ExternalServiceKind!
    "The url for the code host, e.g. github.com."
    url: String!
    "A amount of API requests Sourcegraph can send to the code host."
    apiRateLimitQuota: Int
    "How often API rate limits get reset. Defined in seconds."
    apiRateLimitIntervalSeconds: Int
    "A amount of git requests Sourcegraph can send to the code host."
    gitRateLimitQuota: Int
    "How often git rate limits get reset. Defined in seconds."
    gitRateLimitIntervalSeconds: Int
    "All external services that refer to this code host."
    externalServices(first: Int = 50 after: String): ExternalServiceConnection!
}

"A list of code hosts."
type CodeHostConnection {
    "Only when this flag is true, the connection can be trusted to be complete.\nThis will stop existing in Sourcegraph 5.3 when the migration is ensured\nto be complete."
    isMigrationDone: Boolean!
    "A list of code hosts."
    nodes: [CodeHost!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of records in this result set."
    totalCount: Int!
}

"Describes the state of a provider (code host) during a permission sync job."
type CodeHostState {
    "ID of a permissions provider (code host)."
    providerID: String!
    "Permissions provider (code host) type."
    providerType: String!
    "Status of permission sync of a given provider."
    status: CodeHostStatus!
    "Status message."
    message: String!
}

"Describes the status of a permissions sync for a given provider (code host)."
enum CodeHostStatus {
    SUCCESS
    ERROR
}

"A Code Intel Commit."
type CodeIntelCommit {
    "The globally addressable ID for this commit."
    id: ID!
    "This commit's Git object ID (OID), a 40-character SHA-1 hash."
    oid: GitObjectID!
    "The abbreviated form of this commit's OID."
    abbreviatedOID: String!
    "The URL to this commit (using the input revision specifier, which may not be immutable)."
    url: String!
    "The repository that contains this commit."
    repository: CodeIntelRepository!
}

"A repository on an external service (such as GitHub, GitLab, Phabricator, etc.)."
type CodeIntelExternalRepository {
    "The type of external service where this repository resides.\nExample: \"github\", \"gitlab\", etc."
    serviceType: String!
    "The particular instance of the external service where this repository resides. Its value is\nopaque but typically consists of the canonical base URL to the service.\nExample: For GitHub.com, this is \"https:\/\/github.com\/\"."
    serviceID: String!
}

"A gitblob resolver specific to code intel."
type CodeIntelGitBlob {
    "The full path (relative to the root) of this tree."
    path: String!
    "The base name (i.e., last path component only) of this tree."
    name: String!
    "The Git commit containing this tree."
    commit: CodeIntelCommit!
    "The URL to this tree (using the input revision specifier, which may not be immutable)."
    url: String!
    "The repository containing this tree."
    repository: CodeIntelRepository!
    "The content of this blob."
    content("Return file content starting at line \"startLine\". A value <= 0 will be the start of the file." startLine: Int "Return file content ending at line \"endLine\". A value < 0 or > totalLines will set endLine to the end of the file." endLine: Int): String!
}

"A git object that matches a git object type and glob pattern. This type is used by\nthe UI to preview what names match a code intelligence policy in a given repository."
type CodeIntelGitObject {
    "The relevant branch or tag name."
    name: String!
    "The full 40-char revhash."
    rev: String!
    "The time that the underlying commit was created."
    committedAt: DateTime!
}

"A Code Intel Git Tree."
type CodeIntelGitTree {
    "The full path (relative to the root) of this tree."
    path: String!
    "The base name (i.e., last path component only) of this tree."
    name: String!
    "The Git commit containing this tree."
    commit: CodeIntelCommit!
    "The URL to this tree (using the input revision specifier, which may not be immutable)."
    url: String!
    "The repository containing this tree."
    repository: CodeIntelRepository!
    "The content of this blob."
    content("Return file content starting at line \"startLine\". A value <= 0 will be the start of the file." startLine: Int "Return file content ending at line \"endLine\". A value < 0 or > totalLines will set endLine to the end of the file." endLine: Int): String!
}

"Describes a precise code-intel indexer."
type CodeIntelIndexer {
    "The language ecosystem that this indexer supports."
    key: String!
    "Name of the precise code-intel indexer."
    name: String!
    "URL to the source of the indexer e.g. https:\/\/github.com\/sourcegraph\/lsif-go"
    url: String!
    "A Docker image name used to distribute the indexer to the executor for via auto-indexing."
    imageName: String
}

"A codeintel repository is a Git source control repository that is mirrored from some origin code host and it is specific to code intel."
type CodeIntelRepository {
    "The globally addressable ID for this commit."
    id: ID!
    "The repository's name, as a path with one or more components. It conventionally consists of\nthe repository's hostname and path (joined by \"\/\"), minus any suffixes (such as \".git\").\nExamples:\n- github.com\/foo\/bar\n- my-code-host.example.com\/myrepo\n- myrepo"
    name: String!
    "The URL to this repository."
    url: String!
    "Information about this repository from the external service that it originates from (such as GitHub, GitLab,\nPhabricator, etc.). Only populated when used as part of repository list previews for configuration policies."
    externalRepository: CodeIntelExternalRepository
}

"A summary of the most recent upload and index status."
type CodeIntelRepositorySummary {
    "A list of recent precise indexes for a specific repository. This list contains processing,\nrecently queued, and the most recently processed precise indexes for each distinct indexer\nand root."
    recentActivity: [PreciseIndex!]!
    "The last time uploads of this repository were checked against data retention policies."
    lastUploadRetentionScan: DateTime
    "The last time this repository was considered for auto-indexing job scheduling."
    lastIndexScan: DateTime
    "The additionally available indexers that could be indexed but haven't been indexed."
    availableIndexers: [InferredAvailableIndexers!]!
    "If inference of the repository contents hit a limit its error description will available here."
    limitError: String
}

"A repository paired with a list of precise indexers (used by CodeIntelSummary)."
type CodeIntelRepositoryWithConfiguration {
    "The repository."
    repository: CodeIntelRepository!
    "The precise indexers available for the repository."
    indexers: [IndexerWithCount!]!
}

"A list of repositories paired with a list of precise indexers (used by CodeIntelSummary)."
type CodeIntelRepositoryWithConfigurationConnection {
    "The repository and indexer count."
    nodes: [CodeIntelRepositoryWithConfiguration!]!
    "The total number of results (over all pages) in this list."
    totalCount: Int
    "Metadata about the current page of results."
    pageInfo: PageInfo!
}

"A repository paired with a count of precise indexing errors (used by CodeIntelSummary)."
type CodeIntelRepositoryWithError {
    "The repository."
    repository: CodeIntelRepository!
    "The number of precise indexing errors in the repository."
    count: Int!
}

"A list of repositories paired with a count of precise indexing errors (used by CodeIntelSummary)."
type CodeIntelRepositoryWithErrorConnection {
    "The repository and error count."
    nodes: [CodeIntelRepositoryWithError!]!
    "The total number of results (over all pages) in this list."
    totalCount: Int
    "Metadata about the current page of results."
    pageInfo: PageInfo!
}

"A summary of code intelligence on the instance."
type CodeIntelSummary {
    "The number of repositories with precise index records."
    numRepositoriesWithCodeIntelligence: Int!
    "A list of repositories with precise index errors."
    repositoriesWithErrors("When specified, indicates that this request should be paginated and\nthe first N results (relative to the cursor) should be returned. i.e.\nhow many results to return per page." first: Int "When specified, indicates that this request should be paginated and\nto fetch results starting at this cursor.\n\nA future request can be made for more results by passing in the\n'CodeIntelRepositoryWithErrorConnection.pageInfo.endCursor'\nthat is returned." after: String): CodeIntelRepositoryWithErrorConnection!
    "A list of repositories with configurable auto-indexing jobs."
    repositoriesWithConfiguration("When specified, indicates that this request should be paginated and\nthe first N results (relative to the cursor) should be returned. i.e.\nhow many results to return per page." first: Int "When specified, indicates that this request should be paginated and\nto fetch results starting at this cursor.\n\nA future request can be made for more results by passing in the\n'CodeIntelRepositoryWithErrorConnection.pageInfo.endCursor'\nthat is returned." after: String): CodeIntelRepositoryWithConfigurationConnection
}

"Information and status related to the commit graph of this repository calculated\nfor use by code intelligence features."
type CodeIntelligenceCommitGraph {
    "Whether or not the commit graph needs to be updated."
    stale: Boolean!
    "When, if ever, the commit graph was last refreshed."
    updatedAt: DateTime
}

"A configuration policy that applies to a set of Git objects matching an associated\npattern. Each policy has optional data retention and auto-indexing schedule configuration\nattached. A policy can be applied globally or on a per-repository basis."
type CodeIntelligenceConfigurationPolicy implements Node {
    "The ID."
    id: ID!
    "A description of the configuration policy."
    name: String!
    "The repository to which this configuration policy applies."
    repository: CodeIntelRepository
    "The set of name patterns matching repositories to which this configuration policy applies."
    repositoryPatterns: [String!]
    "The type of Git object described by the configuration policy."
    type: GitObjectType!
    "A pattern matching the name of the matching Git object."
    pattern: String!
    "Protected policies may not be deleted (or created directly by users)."
    protected: Boolean!
    "Whether or not this configuration policy affects data retention rules."
    retentionEnabled: Boolean!
    "The max age of data retained by this configuration policy."
    retentionDurationHours: Int
    "If the matching Git object is a branch, setting this value to true will also\nretain all data used to resolve queries for any commit on the matching branches.\nSetting this value to false will only consider the tip of the branch."
    retainIntermediateCommits: Boolean!
    "Whether or not this configuration policy affects auto-indexing schedules."
    indexingEnabled: Boolean!
    "The max age of commits indexed by this configuration policy."
    indexCommitMaxAgeHours: Int
    "If the matching Git object is a branch, setting this value to true will also\nindex all commits on the matching branches. Setting this value to false will\nonly consider the tip of the branch."
    indexIntermediateCommits: Boolean!
    "Whether or not this configuration policy affects embeddings."
    embeddingsEnabled: Boolean!
}

"A list of code intelligence configuration policies."
type CodeIntelligenceConfigurationPolicyConnection {
    "A list of code intelligence configuration policies."
    nodes: [CodeIntelligenceConfigurationPolicy!]!
    "The total number of policies in this result set."
    totalCount: Int
    "Pagination information."
    pageInfo: PageInfo!
}

"Aggregate code intelligence for a particular range within a document."
type CodeIntelligenceRange {
    "The range this code intelligence applies to."
    range: Range!
    "A list of definitions of the symbol occurring within the range."
    definitions: LocationConnection!
    "A list of references of the symbol occurring within the range."
    references: LocationConnection!
    "A list of implementations of the symbol occurring within the range."
    implementations: LocationConnection!
    "The hover result of the symbol occurring within the range."
    hover: Hover
}

"Aggregate local code intelligence for all ranges that fall between a window of lines in a document."
type CodeIntelligenceRangeConnection {
    "Aggregate local code intelligence grouped by range."
    nodes: [CodeIntelligenceRange!]!
}

"A retention policy match candidate."
type CodeIntelligenceRetentionPolicyMatch {
    "The actual retention policy."
    configurationPolicy: CodeIntelligenceConfigurationPolicy
    "Whether the retention policy matches the upload or not. False values may be returned\nif non-matching policies are requested for inclusion."
    matches: Boolean!
    "A list of commits that are visible to this upload for which this retention policy applies.\nIt is empty if the policy applies directly to the commit associated with the upload."
    protectingCommits: [String!]
}

"A list of code intelligence retention policy match candidates."
type CodeIntelligenceRetentionPolicyMatchesConnection {
    "A list of code intelligence retention policies matches."
    nodes: [CodeIntelligenceRetentionPolicyMatch!]!
    "The total number of policies in this result set."
    totalCount: Int
    "Pagination information."
    pageInfo: PageInfo!
}

"The entity is an owner because they were manually assigned as an owner."
type CodeownersFileEntry {
    "Descriptive title to display in the UI for the determination."
    title: String!
    "More detailed description to display in the UI for the determination."
    description: String!
    "Either GitBlob or VirtualFile. This points to the CODEOWNERS file that yielded the\ndetermination."
    codeownersFile: File2!
    "The line in the CODEOWNERS file that matched for this determination."
    ruleLineMatch: Int!
}

"CodeownersFileInput represents the input for ingesting codeowners files"
input CodeownersFileInput {
    "fileContents is the text of the codeowners file"
    fileContents: String!
    "The repo ID to ingest the file for. Cannot be set with repositoryName."
    repoID: ID
    "The repo name to ingest the file for. Cannot be set with repositoryID."
    repoName: String
}

"CodeownersIngestedFile represents a manually ingested Codeowners file."
type CodeownersIngestedFile implements Node {
    "A graphql ID for this file."
    id: ID!
    "The string contents of the codeowners file."
    contents: String!
    "The repository this codeowners file has been manually ingested for."
    repository: Repository!
    "The creation date of this codeowners file."
    createdAt: DateTime!
    "The last updated date of this codeowners file."
    updatedAt: DateTime!
}

"A list of CodeownersIngestedFiles."
type CodeownersIngestedFileConnection {
    "The total count of items in the connection."
    totalCount: Int!
    "The pagination info for the connection."
    pageInfo: PageInfo!
    "The current page of codeowners files in this connection."
    nodes: [CodeownersIngestedFile!]!
}

"EXPERIMENTAL: A single piece of context. It's defined as a union so we can\nreturn other types of context in the future (think code intel definition\nor wiki page)."
union CodyContextResult = FileChunkContext

"Cody Gateway access granted to a subscription.\nFOR INTERNAL USE ONLY."
type CodyGatewayAccess {
    "Whether or not a subscription has Cody Gateway access."
    enabled: Boolean!
    "Rate limit for chat completions access, or null if not enabled."
    chatCompletionsRateLimit: CodyGatewayRateLimit
    "Rate limit for code completions access, or null if not enabled."
    codeCompletionsRateLimit: CodyGatewayRateLimit
    "Rate limit for embedding text chunks, or null if not enabled."
    embeddingsRateLimit: CodyGatewayRateLimit
}

"A dotcom user allowed to access the Cody Gateway\nFOR INTERNAL USE ONLY."
type CodyGatewayDotcomUser {
    "The id of the user"
    id: ID!
    "The user name of the user"
    username: String!
    "Cody Gateway access granted to this user. Properties may be inferred from dotcom site config, or be defined in overrides on the user."
    codyGatewayAccess: CodyGatewayAccess!
}

"Cody Gateway access rate limits for a subscription.\nFOR INTERNAL USE ONLY."
type CodyGatewayRateLimit {
    "The source of the rate limit configuration."
    source: CodyGatewayRateLimitSource!
    "The models that are allowed for this rate limit bucket.\nUsually, customers will have two separate rate limits, one\nfor chat completions and one for code completions. A usual\nconfig could include:\n\n    chatCompletionsRateLimit: {\n        allowedModels: [anthropic\/claude-v1, anthropic\/claude-v1.3]\n    },\n    codeCompletionsRateLimit: {\n        allowedModels: [anthropic\/claude-instant-v1]\n    }\n\nIn general, the model names are of the format \"$PROVIDER\/$MODEL_NAME\"."
    allowedModels: [String!]!
    "Requests per time interval."
    limit: BigInt!
    "Interval for rate limiting."
    intervalSeconds: Int!
    "Recent usage data of Cody Gateway for the subscription."
    usage: [CodyGatewayUsageDatapoint!]!
}

"The source of the rate limit returned.\nFOR INTERNAL USE ONLY."
enum CodyGatewayRateLimitSource {
    "Indicates that a custom override for the rate limit has been stored."
    OVERRIDE
    "Indicates that the rate limit is inferred by the subscriptions active plan."
    PLAN
}

"CodyGatewayRateLimitStatus current status of a rate limit."
type CodyGatewayRateLimitStatus {
    "The feature that the rate limit applies to."
    feature: String!
    "The limit allowed."
    limit: BigInt!
    "The number of usages in current period."
    usage: BigInt!
    "The percentage of the rate limit used."
    percentUsed: Int!
    "The time interval for the rate limit."
    interval: String!
    "When the rate limit next resets if an interval has already started."
    nextLimitReset: DateTime
}

"A usage data point of Cody Gateway usage of a subscription."
type CodyGatewayUsageDatapoint {
    "The day the usage occurred."
    date: DateTime!
    "The number of requests made."
    count: BigInt!
    "The model that was used."
    model: String!
}

"Cody LLM configuration contains information about how the main LLM used by Cody\nis configured."
type CodyLLMConfiguration {
    "Name of the model being used for chat."
    chatModel: String!
    "Maximum number of tokens client should use when talking to the chatModel."
    chatModelMaxTokens: Int
    "Name of the model being used for fast chat."
    fastChatModel: String!
    "Maximum number of tokens client should use when talking to the fastChatModel."
    fastChatModelMaxTokens: Int
    "Name of the model being used for code completions."
    completionModel: String!
    "Maximum number of tokens client should use when talking to the completionModel."
    completionModelMaxTokens: Int
}

"A search result that is a Git commit."
type CommitSearchResult implements GenericSearchResultInterface {
    "A markdown string that is rendered prominently."
    label: Markdown!
    "The URL of the result."
    url: String!
    "A markdown string of that is rendered less prominently."
    detail: Markdown!
    "The result previews of the result."
    matches: [SearchResultMatch!]!
    "The commit that matched the search query."
    commit: GitCommit!
    "The ref names of the commit."
    refs: [GitRef!]!
    "The refs by which this commit was reached."
    sourceRefs: [GitRef!]!
    "The matching portion of the commit message, if any."
    messagePreview: HighlightedString
    "The matching portion of the diff, if any."
    diffPreview: HighlightedString
}

"Commit signing configuration for a code host, e.g. GitHubApp or SSHKey. Today, the\nonly supported form of commit signing is via a GitHub App."
union CommitSigningConfiguration = GitHubApp

"Commit signing verification for a code host, e.g. if it was signed via GitHub App or\nan SSH key."
union CommitVerification = GitHubCommitVerification

"Input wrapper for completions"
input CompletionsInput {
    "List of conversation messages"
    messages: [Message!]!
    "Temperature for sampling - higher means more random completions"
    temperature: Float!
    "Maximum number of tokens to sample"
    maxTokensToSample: Int!
    "Number of highest probability completions to return"
    topK: Int!
    "Probability threshold for inclusion in results"
    topP: Int!
}

"An entry in match environment is a variable with a value spanning a range. Variable names correspond to\na variable names in a pattern metasyntax. For regular expression patterns, named capture groups will use the variable\nspecified. For unnamed capture groups, variable names correspond to capture '1', '2', etc."
type ComputeEnvironmentEntry {
    "The variable name."
    variable: String!
    "The value associated with this variable."
    value: String!
    "The absolute range spanned by this value in the input."
    range: Range!
}

"Represents a value matched within file content, and an environment of submatches within this value corresponding to an input pattern (e.g., regular expression capture groups)."
type ComputeMatch {
    "The string value"
    value: String!
    "The range of this value within the file."
    range: Range!
    "The environment of submatches within value."
    environment: [ComputeEnvironmentEntry]!
}

"The result of matching data that satisfy a search pattern, including an environment of submatches."
type ComputeMatchContext {
    "The repository."
    repository: Repository!
    "The commit."
    commit: String!
    "The file path."
    path: String!
    "Computed match results"
    matches: [ComputeMatch]!
}

"A compute operation result."
union ComputeResult = ComputeMatchContext | ComputeText

"A general computed result for arbitrary textual data. A result optionally specifies a related repository, commit, file path, or the kind of textual data."
type ComputeText {
    "The repository."
    repository: Repository
    "The commit."
    commit: String
    "The file path."
    path: String
    "An arbitrary label communicating the kind of data the value represents."
    kind: String
    "The computed value."
    value: String!
}

"DEPRECATED: Use the contents field on the parent type instead. This type will be removed in a future release."
type Configuration {
    "DEPRECATED: This field will be removed in a future release.\nThe raw JSON contents, encoded as a string."
    contents: JSONCString! @deprecated(reason: "use the contents field on the parent type instead")
    "DEPRECATED: This field is always empty. It will be removed in a future release."
    messages: [String!]! @deprecated(reason: "use client-side JSON Schema validation instead")
}

"DEPRECATED: Renamed to SettingsCascade."
type ConfigurationCascade {
    "DEPRECATED"
    subjects: [SettingsSubject!]! @deprecated(reason: "use SettingsCascade.subjects instead")
    "DEPRECATED"
    merged: Configuration! @deprecated(reason: "use SettingsCascade.final instead")
}

"DEPRECATED: This type was renamed to SettingsEdit.\nNOTE: GraphQL does not support @deprecated directives on INPUT_FIELD_DEFINITION (input fields)."
input ConfigurationEdit {
    "DEPRECATED"
    keyPath: [KeyPathSegment!]!
    "DEPRECATED"
    value: JSONValue
    "DEPRECATED"
    valueIsJSONCEncodedString: Boolean = false
}

"An object with totalCount and PageInfo."
interface Connection {
    "The total count of items in the connection."
    totalCount: Int!
    "The pagination info for the connection."
    pageInfo: ConnectionPageInfo!
}

"Pagination information."
type ConnectionPageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backward, the cursor to continue."
    startCursor: String
    "When paginating backward, are there more items?"
    hasPreviousPage: Boolean!
}

"The result for Mutation.createAccessToken."
type CreateAccessTokenResult {
    "The ID of the newly created access token."
    id: ID!
    "The secret token value that is used to authenticate API clients. The caller is responsible for storing this\nvalue."
    token: String!
}

"CreateFileBlockInput contains the information necessary to create a file block."
input CreateFileBlockInput {
    "Name of the repository, e.g. \"github.com\/sourcegraph\/sourcegraph\"."
    repositoryName: String!
    "Path within the repository, e.g. \"client\/web\/file.tsx\"."
    filePath: String!
    "An optional revision, e.g. \"pr\/feature-1\", \"a9505a2947d3df53558e8c88ff8bcef390fc4e3e\".\nIf omitted, we use the latest revision (HEAD)."
    revision: String
    "An optional line range. If omitted, we display the entire file."
    lineRange: CreateFileBlockLineRangeInput
}

"Input to create a line range for a file block."
input CreateFileBlockLineRangeInput {
    "The first line to fetch (0-indexed, inclusive)."
    startLine: Int!
    "The last line to fetch (0-indexed, exclusive)."
    endLine: Int!
}

"Input object for creating a new dashboard."
input CreateInsightsDashboardInput {
    "Dashboard title."
    title: String!
    "Permissions to grant to the dashboard."
    grants: InsightsPermissionGrantsInput!
}

"GraphQL does not accept union types as inputs, so we have to use\nall possible optional inputs with an enum to select the actual block input we want to use."
input CreateNotebookBlockInput {
    "ID of the block."
    id: String!
    "Block type."
    type: NotebookBlockType!
    "Markdown input."
    markdownInput: String
    "Query input."
    queryInput: String
    "File input."
    fileInput: CreateFileBlockInput
    "Symbol input."
    symbolInput: CreateSymbolBlockInput
}

"CreateSymbolBlockInput contains the information necessary to create a symbol block."
input CreateSymbolBlockInput {
    "Name of the repository, e.g. \"github.com\/sourcegraph\/sourcegraph\"."
    repositoryName: String!
    "Path within the repository, e.g. \"client\/web\/file.tsx\"."
    filePath: String!
    "An optional revision, e.g. \"pr\/feature-1\", \"a9505a2947d3df53558e8c88ff8bcef390fc4e3e\".\nIf omitted, we use the latest revision (HEAD)."
    revision: String
    "Number of lines to show before and after the matched symbol line."
    lineContext: Int!
    "The symbol name."
    symbolName: String!
    "Name of the symbol container."
    symbolContainerName: String!
    "The symbol kind."
    symbolKind: SymbolKind!
}

"The result for Mutation.createUser."
type CreateUserResult {
    "The new user."
    user: User!
    "The reset password URL that the new user must visit to sign into their account. If the builtin\nusername-password authentication provider is not enabled, this field's value is null.\n\nIf email sending (SMTP) is configured on this instance and an email was provided, an email\ncontaining this URL will also be sent to the primary email address associated with the user."
    resetPasswordURL: String
}

"An RFC 3339-encoded UTC date string, such as 1973-11-29T21:33:09Z. This value can be parsed into a\nJavaScript Date using Date.parse. To produce this value from a JavaScript Date instance, use\nDate#toISOString."
scalar DateTime

"The default settings for the Sourcegraph instance. This is hardcoded in\nSourcegraph, but may change from release to release."
type DefaultSettings implements SettingsSubject {
    "The opaque GraphQL ID."
    id: ID!
    "The latest default settings (this never changes)."
    latestSettings: Settings
    "The URL to the default settings. This URL does not exist because you\ncannot edit or directly view default settings."
    settingsURL: String
    "Whether the viewer can modify the subject's settings. Always false for\ndefault settings."
    viewerCanAdminister: Boolean!
    "The default settings, and the final merged settings.\nAll viewers can access this field."
    settingsCascade: SettingsCascade!
    "DEPRECATED"
    configurationCascade: ConfigurationCascade! @deprecated(reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release.")
}

"A repository to pass to the deleteCodeownersFiles mutation. Either repoID or repoName\nmust be provided."
input DeleteCodeownersFilesInput {
    "The repo ID to ingest the file for. Cannot be set with repositoryName."
    repoID: ID
    "The repo name to ingest the file for. Cannot be set with repositoryID."
    repoName: String
}

"Represents a diagnostic, such as a compiler error or warning."
type Diagnostic {
    "The location at which the message applies."
    location: Location!
    "The diagnostic's severity."
    severity: DiagnosticSeverity
    "The diagnostic's code as provided by the tool."
    code: String
    "A human-readable string describing the source of this\ndiagnostic, e.g. \"typescript\" or \"super lint\"."
    source: String
    "The diagnostic's message."
    message: String
}

"A list of diagnostics."
type DiagnosticConnection {
    "A list of diagnostics."
    nodes: [Diagnostic!]!
    "The total count of diagnostics (which may be larger than nodes.length if the connection is paginated)."
    totalCount: Int
    "Pagination information."
    pageInfo: PageInfo!
}

"Represents the severity level of a diagnostic."
enum DiagnosticSeverity {
    ERROR
    WARNING
    INFORMATION
    HINT
}

"A diff between two diffable Git objects."
type Diff {
    "The diff's repository."
    repository: Repository!
    "The revision range of the diff."
    range: GitRevisionRange!
}

"The type of content in a hunk line."
enum DiffHunkLineType {
    "Added line."
    ADDED
    "Unchanged line."
    UNCHANGED
    "Deleted line."
    DELETED
}

"Statistics about a diff."
type DiffStat {
    "Number of lines added."
    added: Int!
    "Number of lines deleted."
    deleted: Int!
}

"Mutations that are only used on Sourcegraph.com.\nFOR INTERNAL USE ONLY."
type DotcomMutation {
    "Creates new product subscription for an account.\nOnly Sourcegraph.com site admins may perform this mutation.\nFOR INTERNAL USE ONLY."
    createProductSubscription("The ID of the user (i.e., customer) to whom this product subscription is assigned." accountID: ID!): ProductSubscription!
    "Generates and signs a new product license and associates it with an existing product subscription. The\nproduct license key is signed with Sourcegraph.com's private key and is verifiable with the corresponding\npublic key.\nOnly Sourcegraph.com site admins may perform this mutation.\nFOR INTERNAL USE ONLY."
    generateProductLicenseForSubscription("The product subscription to associate with the license." productSubscriptionID: ID! "The license to generate." license: ProductLicenseInput!): ProductLicense!
    "Revokes an existing product license, rendering it invalid."
    revokeLicense("The UUID of the license to revoke" id: ID! "Reason for revoking of the license" reason: String!): EmptyResponse!
    "Applies a partial update to a product subscription.\n\nOnly Sourcegraph.com site admins may perform this mutation.\nFOR INTERNAL USE ONLY."
    updateProductSubscription("The product subscription ID to update." id: ID! "Partial update to apply." update: UpdateProductSubscriptionInput!): EmptyResponse!
    "Archives an existing product subscription.\nOnly Sourcegraph.com site admins may perform this mutation.\nFOR INTERNAL USE ONLY."
    archiveProductSubscription("The product subscription to archive." id: ID!): EmptyResponse!
}

"Mutations that are only used on Sourcegraph.com.\nFOR INTERNAL USE ONLY."
type DotcomQuery {
    "The product subscription with the given UUID. An error is returned if no such product\nsubscription exists.\nOnly Sourcegraph.com site admins and the account owners of the product subscription may\nperform this query.\nFOR INTERNAL USE ONLY."
    productSubscription(uuid: String!): ProductSubscription!
    "The access available to the product subscription with the given access token.\nThe returned ProductSubscription may be archived or not associated with an active license.\n\nOnly Sourcegraph.com site admins, the account owners of the product subscription, and\nspecific service accounts may perform this query.\nFOR INTERNAL USE ONLY."
    productSubscriptionByAccessToken(accessToken: String!): ProductSubscription!
    "A list of product subscriptions.\nFOR INTERNAL USE ONLY."
    productSubscriptions("Returns the first n product subscriptions from the list." first: Int "Returns only product subscriptions for the given account.\nOnly Sourcegraph.com site admins may perform this query with account == null." account: ID "Returns product subscriptions from users with usernames or email addresses that match the query." query: String): ProductSubscriptionConnection!
    "A list of product licenses.\nOnly Sourcegraph.com site admins may perform this query.\nFOR INTERNAL USE ONLY."
    productLicenses("Returns the first n product subscriptions from the list." first: Int "Returns only product subscriptions whose license key contains this substring." licenseKeySubstring: String "Returns only product licenses associated with the given subscription" productSubscriptionID: ID): ProductLicenseConnection!
    "A dotcom user for purposes of connecting to the Cody Gateway.\nOnly Sourcegraph.com site admins or service accounts may perform this query.\nToken is a Cody Gateway token, not a Sourcegraph instance access token.\nFOR INTERNAL USE ONLY."
    codyGatewayDotcomUserByToken(token: String!): CodyGatewayDotcomUser
}

"A single embeddings search result."
type EmbeddingsSearchResult {
    "The name of the repository containing the search result."
    repoName: String!
    "The commitID of the repository containing the search result."
    revision: String!
    "The search result file name."
    fileName: String!
    "The start line of the content (inclusive)."
    startLine: Int!
    "The end line of the content (exclusive)."
    endLine: Int!
    "The content of the file from start line to end line."
    content: String!
}

"Embeddings search results. Contains a list of code results and a list of text results."
type EmbeddingsSearchResults {
    "A list of code file results."
    codeResults: [EmbeddingsSearchResult!]!
    "A list of text file results."
    textResults: [EmbeddingsSearchResult!]!
}

"Represents a null return value."
type EmptyResponse {
    "A dummy null value."
    alwaysNil: String
}

"This type is not returned by any resolver, but serves to document what an error\nresponse will look like."
type Error {
    "A string giving more context about the error that occurred."
    message: String!
    "The GraphQL path to where the error happened. For an error in the query\nquery {\n    user {\n        externalID # This is a nullable field that failed computing.\n    }\n}\nthe path would be [\"user\", \"externalID\"]."
    path: [String!]!
    "Optional additional context on the error."
    extensions: ErrorExtensions
}

"Optional additional context on an error returned from a resolver.\nIt may also contain more properties, which aren't strictly typed here."
type ErrorExtensions {
    "An error code, which can be asserted on.\nPossible error codes are communicated in the doc string of the field."
    code: String
}

"An evaluated feature flag is any feature flag (static or random) that has been evaluated to\na concrete value for a given viewer."
type EvaluatedFeatureFlag {
    "The name of the feature flag"
    name: String!
    "The concrete evaluated value of the feature flag"
    value: Boolean!
}

"A description of a user event."
input Event {
    "The name of the event."
    event: String!
    "The randomly generated unique user ID stored in a browser cookie."
    userCookieID: String!
    "The first sourcegraph URL visited by the user, stored in a browser cookie."
    firstSourceURL: String
    "The last sourcegraph URL visited by the user, stored in a browser cookie."
    lastSourceURL: String
    "The URL when the event was logged."
    url: String!
    "The source of the event."
    source: EventSource!
    "An optional cohort ID to identify the user as part of a specific A\/B test.\nThe cohort ID is expected to be a date in the form YYYY-MM-DD"
    cohortID: String
    "An optional referrer parameter for the user's current session.\nOnly captured and stored on Sourcegraph Cloud."
    referrer: String
    "The original referrer for a user"
    originalReferrer: String
    "The session referrer for a user"
    sessionReferrer: String
    "The sessions first url for a user"
    sessionFirstURL: String
    "Device session ID to identify the user's session for analytics."
    deviceSessionID: String
    "The additional argument information."
    argument: String
    "Public argument information. PRIVACY: Do NOT include any potentially private information in this field.\nThese properties get sent to our analytics tools for Cloud, so must not include private information,\nsuch as search queries or repository names."
    publicArgument: String
    "Device ID used for Amplitude analytics. Used on Sourcegraph Cloud only."
    deviceID: String
    "Event ID used to deduplicate events that occur simultaneously in Amplitude analytics.\nSee https:\/\/developers.amplitude.com\/docs\/http-api-v2#optional-keys. Used on Sourcegraph Cloud only."
    eventID: Int
    "Insert ID used to deduplicate events that re-occur in the event of retries or\nbackfills in Amplitude analytics. See https:\/\/developers.amplitude.com\/docs\/http-api-v2#optional-keys.\nUsed on Sourcegraph Cloud only."
    insertID: String
    "The client that this event is being sent from."
    client: String
    "The product category for the event, used for billing purposes."
    billingProductCategory: String
    "The billing ID for the event, used for tagging user events for billing aggregation purposes."
    billingEventID: String
    "The site ID that the client was connected to when the event was logged."
    connectedSiteID: String
    "The connected site's license key, hashed using sha256. Used for uniquely identifying the site."
    hashedLicenseKey: String
}

"Billing IDs for events, used for tagging user events for billing aggregation purposes."
enum EventBillingID {
    "A billable Cody chat event, including manual chats, recipes, and more."
    CodyChat
    "A billable Cody completion (aka suggestion or autocomplete) event."
    CodyCompletion
    "A billable Cody embedding\/code graph creation or search event."
    CodyEmbedding
}

"The product categories for events, used for billing purposes."
enum EventBillingProductCategory {
    "Used for all events related to non-billable, non-product usage (e.g. marketing, CTAs, signed out\nevents, etc.)"
    NOT_BILLABLE
    "Used for all billable but shared user interface events, such as administration, authentication, user\nprofile and settings, shared landing pages, etc."
    SHARED
    "Used for all events primarily related to the Code Search product, including file and repo pageviews,\nsearch actions, code navigation, batch changes, code insights, etc."
    CODE_SEARCH
    "Used for all events primarily related to the Cody product, including chats, recipes, completions, web\nchat views, etc."
    CODY
}

"The product client where events come from.\n\nFuture additions include:\n- BITBUCKET_NATIVE_INTEGRATION\n- GITLAB_NATIVE_INTEGRATION\n- CHROME_SOURCEGRAPH_EXTENSION\n- FIREFOX_SOURCEGRAPH_EXTENSION\n- EDGE_SOURCEGRAPH_EXTENSION\n- VSCODE_SOURCEGRAPH_EXTENSION (for https:\/\/marketplace.visualstudio.com\/items?itemName=sourcegraph.sourcegraph)\n- EMACS_CODY_EXTENSION"
enum EventClient {
    SERVER_WEB
    APP_WEB
    DOTCOM_WEB
    MARKETING_WEB
    DOTCOM_BACKEND
    APP_BACKEND
    SERVER_BACKEND
    VSCODE_CODY_EXTENSION
    JETBRAINS_CODY_EXTENSION
    NEOVIM_CODY_EXTENSION
}

"A single user event that has been logged."
type EventLog {
    "The name of the event."
    name: String!
    "The user who executed the event, if one exists."
    user: User
    "The randomly generated unique user ID stored in a browser cookie."
    anonymousUserID: String!
    "The URL when the event was logged."
    url: String!
    "The source of the event."
    source: EventSource!
    "The additional argument information."
    argument: String
    "The Sourcegraph version when the event was logged."
    version: String!
    "The timestamp when the event was logged."
    timestamp: DateTime!
}

"A list of event logs."
type EventLogsConnection {
    "A list of event logs."
    nodes: [EventLog!]!
    "The total count of event logs in the connection. This total count may be larger than the number of nodes\nin this object when the result is paginated."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"The product sources where events can come from."
enum EventSource {
    WEB
    CODEHOSTINTEGRATION
    BACKEND
    STATICWEB
    IDEEXTENSION
    "DEPRECATED"
    CODY
}

"Supported status of monitor events."
enum EventStatus {
    PENDING
    SUCCESS
    ERROR
}

"A description of a command run inside the executor to during processing of the parent record."
type ExecutionLogEntry {
    "An internal tag used to correlate this log entry with other records."
    key: String!
    "The arguments of the command run inside the executor."
    command: [String!]!
    "The date when this command started."
    startTime: DateTime!
    "The exit code of the command. Null, if the command has not finished yet."
    exitCode: Int
    "The combined stdout and stderr logs of the command."
    out: String!
    "The duration in milliseconds of the command. Null, if the command has not finished yet."
    durationMilliseconds: Int
}

"An active executor compute instance."
type Executor implements Node {
    "The unique identifier of this executor."
    id: ID!
    "The hostname of the executor instance."
    hostname: String!
    "The queue name that the executor polls for work."
    queueName: String
    "The queue name that the executor polls for work."
    queueNames: [String!]
    "Active is true, if a heartbeat from the executor has been received at most three heartbeat intervals ago."
    active: Boolean!
    "The operating system running the executor."
    os: String!
    "The machine architecture running the executor."
    architecture: String!
    "The version of Git used by the executor."
    dockerVersion: String!
    "The version of the executor."
    executorVersion: String!
    "The version of Docker used by the executor."
    gitVersion: String!
    "The version of Ignite used by the executor."
    igniteVersion: String!
    "The version of src-cli used by the executor."
    srcCliVersion: String!
    "The first time the executor sent a heartbeat to the Sourcegraph instance."
    firstSeenAt: DateTime!
    "The last time the executor sent a heartbeat to the Sourcegraph instance."
    lastSeenAt: DateTime!
    "The compatibility of the executor with respect to the Sourcegraph instance.\nIf outdated, please make sure that the executor and the Sourcegraph backend are of compatible versions. This means they should match in major and minor version, but they may be 1 minor version apart.\nIf too new, please update the Sourcegraph instance to match the version of the executor or downgrade the executor.\n\nCompatibility can be null if the executor or Sourcegraph instance runs in dev mode or there's a version mismatch."
    compatibility: ExecutorCompatibility
}

"The compatibility of the executor with the sourcegraph instance."
enum ExecutorCompatibility {
    "Executor version is more than one version behind the Sourcegraph instance."
    OUTDATED
    "Executor is up-to-date with the Sourcegraph instance."
    UP_TO_DATE
    "Executor version is more than one version ahead of the Sourcegraph instance."
    VERSION_AHEAD
}

"A list of active executors compute instances."
type ExecutorConnection {
    "A list of executors."
    nodes: [Executor!]!
    "The total number of executors in this result set."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"A secret to be used in executor jobs."
type ExecutorSecret implements Node {
    "The unique identifier of the secret."
    id: ID!
    "The key under which the secret is available. Secrets are usually exposed\nas environment variables named using this key.\nRecommended format: uppercase letters, numbers and underscores."
    key: String!
    "The scope of this secret. The secret will only be usable for jobs in this\nparticular scope."
    scope: ExecutorSecretScope!
    "If true, this secret is defined in a namespace and a secret with the same key\nis also defined in the global namespace, which this secret overwrites."
    overwritesGlobalSecret: Boolean!
    "The namespace this secret belongs to. Null, if a global secret.\nGlobal secrets are available to every execution."
    namespace: Namespace
    "The creator of the secret. Null, if the creator has been deleted."
    creator: User
    "The date and time this secret has been created."
    createdAt: DateTime!
    "The date and time this secret has been last updated."
    updatedAt: DateTime!
    "The list of access events to this secret. Every time the secret value is\ndecoded and used, one of these entries is created."
    accessLogs("Only return N records." first: Int = 50 "Opaque cursor for pagination." after: String): ExecutorSecretAccessLogConnection!
}

"An access log entry for an executor secret.\nThese are created every time the secret value is decoded."
type ExecutorSecretAccessLog implements Node {
    "The unique identifier of the log entry."
    id: ID!
    "The secret that this log entry belongs to."
    executorSecret: ExecutorSecret!
    "The user in which name the secret has been used.\nThis is null when the access was not by a user account, or\nwhen the user account was deleted."
    user: User
    "True when the secret was accessed by an internal procedure."
    machineUser: String!
    "The date and time when the secret has been used."
    createdAt: DateTime!
}

"A list of executor secret access logs."
type ExecutorSecretAccessLogConnection {
    "A list of access logs."
    nodes: [ExecutorSecretAccessLog!]!
    "The total number of records in this result set."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"A list of executor secrets."
type ExecutorSecretConnection {
    "A list of executor secrets."
    nodes: [ExecutorSecret!]!
    "The total number of records in this result set."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"Enum of the possible scopes for executor secrets."
enum ExecutorSecretScope {
    "The secret is meant to be used with Batch Changes execution."
    BATCHES
    "The secret is meant to be used with Auto-indexing."
    CODEINTEL
}

"Information regarding the results of an exhaustive search aggregation"
type ExhaustiveSearchAggregationResult {
    "A list of the first [LIMIT] aggregation groups in decreasing order"
    groups: [AggregationGroup!]!
    "Boolean indicating if the search query supports being persisted as an insight on a dashboard"
    supportsPersistence: Boolean
    "A count to capture the number of results that are not included in the list of groups returned.\nThis includes result counts for groups that were excluded due to the requested limit"
    otherResultCount: Int
    "A count to represent the number of aggregation groups that were not returned due to the requested LIMIT"
    otherGroupCount: Int
    "The SearchAggregationMode the results relate to"
    mode: SearchAggregationMode!
}

"A reference to a changeset that already exists on a code host (and was not created by the\nbatch change)."
type ExistingChangesetReference {
    "The repository that contains the existing changeset on the code host."
    baseRepository: Repository!
    "The ID that uniquely identifies the existing changeset on the code host.\n\nFor GitHub and Bitbucket Server, this is the pull request number (as a string) in the\nbase repository. For example, \"1234\" for PR 1234."
    externalID: String!
}

"An external account associated with a user."
type ExternalAccount implements Node {
    "The unique ID for the external account."
    id: ID!
    "The user on Sourcegraph."
    user: User!
    "The type of the external service where the external account resides."
    serviceType: String!
    "An identifier for the external service where the external account resides."
    serviceID: String!
    "An identifier for the client of the external service where the external account resides. This distinguishes\namong multiple authentication providers that access the same service with different parameters."
    clientID: String!
    "An identifier for the external account (typically equal to or derived from the ID on the external service)."
    accountID: String!
    "The creation date of this external account on Sourcegraph."
    createdAt: DateTime!
    "The last-updated date of this external account on Sourcegraph."
    updatedAt: DateTime!
    "A URL that, when visited, re-initiates the authentication process."
    refreshURL: String
    "Provider-specific data about the external account.\nOnly site admins may query this field."
    accountData: JSONValue
    "Public provider-specific data about the external account.\nOnly users that are linked to the external account and site admins\nmay query this field."
    publicAccountData: PublicExternalAccountData
}

"A list of external accounts."
type ExternalAccountConnection {
    "A list of external accounts."
    nodes: [ExternalAccount!]!
    "The total count of external accounts in the connection. This total count may be larger than the number of nodes\nin this object when the result is paginated."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"A changeset on a code host (e.g., a pull request on GitHub)."
type ExternalChangeset implements Node & Changeset {
    "The unique ID for the changeset."
    id: ID!
    "The external ID that uniquely identifies this ExternalChangeset on the\ncode host. For example, on GitHub this is the pull request number. This is only set once the changeset is published on the code host."
    externalID: String
    "The repository changed by this changeset."
    repository: Repository!
    "The batch changes that contain this changeset."
    batchChanges("Returns the first n batch changes from the list." first: Int = 50 "Opaque pagination cursor." after: String "Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`." state: BatchChangeState "Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it." states: [BatchChangeState!] "Only include batch changes that the viewer can administer." viewerCanAdminister: Boolean): BatchChangeConnection!
    "The batch change that \"owns\" this changeset: If this is null, it is imported\/tracked by a batch change."
    ownedByBatchChange: ID
    "The events belonging to this changeset."
    events(first: Int = 50 after: String): ChangesetEventConnection!
    "The date and time when the changeset was created."
    createdAt: DateTime!
    "The date and time when the changeset was updated."
    updatedAt: DateTime!
    "The date and time when the next changeset sync is scheduled, or null if none is scheduled or when the initial sync hasn't happened."
    nextSyncAt: DateTime
    "The time the changeset is expected to be enqueued at. This is an estimate, and may change depending on other code host and Batch Changes activity.\n\nNull if the changeset is not currently scheduled."
    scheduleEstimateAt: DateTime
    "The title of the changeset, or null if the data hasn't been synced from the code host yet."
    title: String
    "The body of the changeset, or null if the data hasn't been synced from the code host yet."
    body: String
    "The author of the changeset, or null if the data is unavailable or hasn't been synced\nfrom the code host yet.\n\nNote that author is not fully supported by some code host APIs:\n* GitHub - only author.name\n* GitLab - only author.name\n* Bitbucket Server - author is not always available\n* Bitbucket Cloud - author is never available\n* Azure DevOps - author is always available"
    author: Person
    "The state of the changeset."
    state: ChangesetState!
    "The labels attached to the changeset on the code host."
    labels: [ChangesetLabel!]!
    "The external URL of the changeset on the code host. Not set when changeset state is UNPUBLISHED, externalState is DELETED, or the changeset's data hasn't been synced yet."
    externalURL: ExternalLink
    "If the changeset was opened from a fork, this is the namespace of the fork\n(which will generally correspond to a user or organisation name on the code\nhost)."
    forkNamespace: String
    "If the changeset was opened from a fork, this is the name of the fork repository."
    forkName: String
    "Commit verification object for this changeset's commit, if it was signed."
    commitVerification: CommitVerification
    "The review state of this changeset. This is only set once the changeset is published on the code host.\n\nNote: The COMMENTED and DISMISSED review states are not yet implemented."
    reviewState: ChangesetReviewState
    "The diff of this changeset, or null if the changeset is closed (without merging) or is already merged."
    diff: RepositoryComparisonInterface
    "The diffstat of this changeset, or null if the changeset is closed\n(without merging) or is already merged. This data is also available\nindirectly through the diff field above, but if only the diffStat is\nrequired, this field is cheaper to access."
    diffStat: DiffStat
    "The state of the checks (e.g., for continuous integration) on this changeset, or null if no\nchecks have been configured."
    checkState: ChangesetCheckState
    "An error that has occurred when publishing or updating the changeset. This is only set when the changeset state is ERRORED and the viewer can administer this changeset."
    error: String
    "An error that has occured during the last sync of the changeset. Null, if was successful."
    syncerError: String
    "The current changeset spec for this changeset. Use this to get access to the\nworkspace execution that generated this changeset.\n\nNull if the changeset was only imported."
    currentSpec: VisibleChangesetSpec
}

"A URL to a resource on an external service, such as the URL to a repository on its external (origin) code host."
type ExternalLink {
    "The URL to the resource."
    url: String!
    "The kind of external service, such as \"GITHUB\", or null if unknown\/unrecognized. This is used solely for\ndisplaying an icon that represents the service."
    serviceKind: ExternalServiceKind
    "The type of external service, such as \"github\", or null if unknown\/unrecognized. This is used solely for\ndisplaying an icon that represents the service."
    serviceType: String @deprecated(reason: "use name serviceKind instead")
}

"A repository on an external service (such as GitHub, GitLab, Phabricator, etc.)."
type ExternalRepository {
    "The repository's ID on the external service.\nExample: For GitHub, this is the GitHub GraphQL API's node ID for the repository."
    id: String!
    "The type of external service where this repository resides.\nExample: \"github\", \"gitlab\", etc."
    serviceType: String!
    "The particular instance of the external service where this repository resides. Its value is\nopaque but typically consists of the canonical base URL to the service.\nExample: For GitHub.com, this is \"https:\/\/github.com\/\"."
    serviceID: String!
}

"A configured external service."
type ExternalService implements Node {
    "The external service's unique ID."
    id: ID!
    "The kind of external service."
    kind: ExternalServiceKind!
    "The display name of the external service."
    displayName: String!
    "The JSON configuration of the external service."
    config: JSONCString!
    "When the external service was created."
    createdAt: DateTime!
    "When the external service was last updated."
    updatedAt: DateTime!
    "The number of repos synced by the external service."
    repoCount: Int!
    "An optional URL that will be populated when webhooks have been configured for the external service."
    webhookURL: String
    "This is an optional field that's populated when we ran into errors on the\nbackend side when trying to create\/update an ExternalService, but the\ncreate\/update still succeeded.\nIt is a field on ExternalService instead of a separate thing in order to\nnot break the API and stay backwards compatible."
    warning: String
    "External services are synced with code hosts in the background. This optional field\nwill contain any errors that occurred during the most recent completed sync."
    lastSyncError: String
    "LastSyncAt is the time the last sync job was run for this code host. Null if it\nhas never been synced so far."
    lastSyncAt: DateTime
    "The timestamp of the next sync job. Null if not scheduled for a re-sync."
    nextSyncAt: DateTime
    "Returns recently received webhooks on this external service.\n\nOnly site admins may access this field.\n\nDEPRECATED: Webhook logs linked directly to an external service will be removed. See https:\/\/docs.sourcegraph.com\/admin\/config\/webhooks\/incoming#deprecation-notice"
    webhookLogs("Returns the first n webhook logs." first: Int "Opaque pagination cursor." after: String "Only include webhook logs that resulted in errors." onlyErrors: Boolean "Only include webhook logs on or after this time." since: DateTime "Only include webhook logs on or before this time." until: DateTime): WebhookLogConnection! @deprecated(reason: "Webhook logs linked directly to an external service will be removed. See https:\/\/docs.sourcegraph.com\/admin\/config\/webhooks\/incoming#deprecation-notice")
    "The list of recent sync jobs for this external service."
    syncJobs(first: Int): ExternalServiceSyncJobConnection!
    "Checks the availability of the external service."
    checkConnection: ExternalServiceAvailability!
    "True if this external service can perform availability check by running checkConnection.\n\nIf this is false, then checkConnection responds with ExternalServiceAvailabilityUnknown."
    hasConnectionCheck: Boolean!
    "True if this external service configuration supports `exclude` parameter."
    supportsRepoExclusion: Boolean!
}

"Availability status of an external service for diagnostic purposes.\n\nThis is so that the UI can surface whether the external service\ncan serve requests, and if not, why is the reason for that."
union ExternalServiceAvailability = ExternalServiceAvailable | ExternalServiceUnavailable | ExternalServiceAvailabilityUnknown

"Availability for some external services may not be determined, or only partially\nsupported. In that case unknown variant of ExternalServiceAvailability is returned."
type ExternalServiceAvailabilityUnknown {
    "User-friendly textual description of the implementation status of availability.\nThis is expected to be tied to specific kinds of external services."
    implementationNote: String!
}

"Indicator that the external service was recently found to be available."
type ExternalServiceAvailable {
    "The timestamp of the last successful availability check that was performed."
    lastCheckedAt: DateTime!
}

"A list of external services."
type ExternalServiceConnection {
    "A list of external services."
    nodes: [ExternalService!]!
    "The total number of external services in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"A specific kind of external service."
enum ExternalServiceKind {
    AWSCODECOMMIT
    AZUREDEVOPS
    BITBUCKETCLOUD
    BITBUCKETSERVER
    GERRIT
    GITHUB
    GITLAB
    GITOLITE
    GOMODULES
    JVMPACKAGES
    NPMPACKAGES
    OTHER
    LOCALGIT
    PAGURE
    PERFORCE
    PHABRICATOR
    PYTHONPACKAGES
    RUSTPACKAGES
    RUBYPACKAGES
}

"A namespace sourced from a defined external service (such as GitHub, GitLab, Phabricator, etc.) that can be discovered\nbefore any sync or mirror operations."
type ExternalServiceNamespace {
    "The unique identifier of the external service namespace."
    id: ID!
    "The name of the external service namespace."
    name: String!
    "The Namespace's ID on the external service.\nExample: For GitHub, this is the GitHub GraphQL API's node ID for the organization."
    externalID: String!
}

"A list of namespaces available to an external service configuration."
type ExternalServiceNamespaceConnection {
    "A list of namespaces available on the source.\nNamespaces are used to organize which members and users can access repositories\nand are defined by external service kind (e.g. Github organizations, Bitbucket projects, etc.)"
    nodes: [ExternalServiceNamespace!]!
    "The total number of source repos in the connection."
    totalCount: Int!
}

"A repository sourced from a defined external service (such as GitHub, GitLab, Phabricator, etc.) that can be discovered\nbefore any sync or mirror operations."
type ExternalServiceRepository {
    "The unique identifier of the external service repository."
    id: ID!
    "The name of the external service repository."
    name: String!
    "The repository's ID on the external service.\nExample: For GitHub, this is the GitHub GraphQL API's node ID for the repository."
    externalID: String!
}

"A list of repositories available to an external service configuration."
type ExternalServiceRepositoryConnection {
    "A list of repositories available on the source."
    nodes: [ExternalServiceRepository!]!
}

"FOR INTERNAL USE ONLY: A status message produced when repositories could not\nbe synced from an external service"
type ExternalServiceSyncError {
    "The message of this status message"
    message: String!
    "The external service that failed to sync"
    externalService: ExternalService!
}

"An external service sync job represents one sync with the code host. It's a background\njob that will eventually be run by the repo syncer."
type ExternalServiceSyncJob implements Node {
    "The unique identifier of the sync job."
    id: ID!
    "The current state of the sync job."
    state: ExternalServiceSyncJobState!
    "When the sync job was added to the queue."
    queuedAt: DateTime!
    "Set when sync begins."
    startedAt: DateTime
    "Set when sync finished."
    finishedAt: DateTime
    "Error message, if the sync failed."
    failureMessage: String
    "The number of repos synced during this sync job."
    reposSynced: Int!
    "The number of times an error occurred syncing a repo during this sync job."
    repoSyncErrors: Int!
    "The number of new repos discovered during this sync job."
    reposAdded: Int!
    "The number of repos deleted as a result of this sync job."
    reposDeleted: Int!
    "The number of existing repos whose metadata has changed during this sync job."
    reposModified: Int!
    "The number of existing repos whose metadata did not change during this sync job."
    reposUnmodified: Int!
}

"A list of external service sync jobs."
type ExternalServiceSyncJobConnection {
    "A list of sync jobs."
    nodes: [ExternalServiceSyncJob!]!
    "The total number of jobs in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"The possible states of an external service sync job."
enum ExternalServiceSyncJobState {
    "Not yet started. Will be picked up by a worker eventually."
    QUEUED
    "Currently syncing."
    PROCESSING
    "An error occurred while syncing. Will be retried eventually."
    ERRORED
    "A fatal error occurred while syncing. No retries will be made."
    FAILED
    "Sync finished successfully."
    COMPLETED
    "Sync job is being canceled."
    CANCELING
    "Sync job has been canceled."
    CANCELED
}

"Indicator that the external service was recently not found available."
type ExternalServiceUnavailable {
    "User-friendly textual description of supposed reason why the service is not available."
    suspectedReason: String!
}

"External services count information includes a count of services for remote code host connections and a count of services\nfor local code host connections (local is only supported for Sourcegraph App)."
type ExternalServicesCounts {
    "The count of external services configured for remote code host connections."
    remoteExternalServicesCount: Int!
    "The count of external services configured for local code host connections."
    localExternalServicesCount: Int!
}

"A feature flag is either a static boolean feature flag or a rollout feature flag"
union FeatureFlag = FeatureFlagBoolean | FeatureFlagRollout

"A feature flag that has a statically configured value"
type FeatureFlagBoolean {
    "The name of the feature flag"
    name: String!
    "The static value of the feature flag"
    value: Boolean!
    "Overrides that apply to the feature flag"
    overrides: [FeatureFlagOverride!]!
    "When the feature flag was created."
    createdAt: DateTime!
    "When the feature flag was last updated."
    updatedAt: DateTime!
}

"A feature flag override is an override of a feature flag's value for a specific org or user"
type FeatureFlagOverride {
    "A unique ID for this feature flag override"
    id: ID!
    "The namespace for this override. Will always be a user or org."
    namespace: Namespace!
    "The name of the feature flag being overridden"
    targetFlag: FeatureFlag!
    "The overridden value of the feature flag"
    value: Boolean!
}

"A feature flag that is randomly evaluated to a boolean based on the rollout parameter"
type FeatureFlagRollout {
    "The name of the feature flag"
    name: String!
    "The ratio of users that will be assigned this this feature flag, expressed in\nbasis points (0.01%)."
    rolloutBasisPoints: Int!
    "Overrides that apply to the feature flag"
    overrides: [FeatureFlagOverride!]!
    "When the feature flag was created."
    createdAt: DateTime!
    "When the feature flag was last updated."
    updatedAt: DateTime!
}

"Additional options when performing a permissions sync."
input FetchPermissionsOptions {
    "Indicate that any caches added for optimization encountered during this permissions\nsync should be invalidated."
    invalidateCaches: Boolean
}

"File is temporarily preserved for backcompat with browser extension search API client code."
type File {
    "The full path (relative to the repository root) of this file."
    path: String!
    "The base name (i.e., file name only) of this file's path."
    name: String!
    "Whether this is a directory."
    isDirectory: Boolean!
    "The URL to this file on Sourcegraph."
    url: String!
    "The repository that contains this file."
    repository: Repository!
}

"A file.\nIn a future version of Sourcegraph, a repository's files may be distinct from a repository's blobs\n(for example, to support searching\/browsing generated files that aren't committed and don't exist\nas Git blobs). Clients should generally use the GitBlob concrete type and GitCommit.blobs (not\nGitCommit.files), unless they explicitly want to opt-in to different behavior in the future.\nINTERNAL: This is temporarily named File2 during a migration. Do not refer to the name File2 in\nany API clients as the name will change soon."
interface File2 {
    "The full path (relative to the root) of this file."
    path: String!
    "The base name (i.e., file name only) of this file."
    name: String!
    "False because this is a file, not a directory."
    isDirectory: Boolean!
    "The content of this file."
    content("Return file content starting at line \"startLine\". A value <= 0 will be the start of the file." startLine: Int "Return file content ending at line \"endLine\". A value < 0 or > totalLines will set endLine to the end of the file." endLine: Int): String!
    "The file size in bytes."
    byteSize: Int!
    "Total line count for the file. Returns 0 for binary files."
    totalLines: Int!
    "Whether or not it is binary."
    binary: Boolean!
    "The file rendered as rich HTML, or an empty string if it is not a supported\nrich file type.\nThis HTML string is already escaped and thus is always safe to render."
    richHTML("Return richHTML content starting at line \"startLine\". A value <= 0 will be the start of the file." startLine: Int "Return richHTML content ending at line \"endLine\". A value < 0 or > totalLines will set endLine to the end of the file." endLine: Int): String!
    "The URL to this file (using the input revision specifier, which may not be immutable)."
    url: String!
    "The canonical URL to this file (using an immutable revision specifier)."
    canonicalURL: String!
    "The URL to this file using the changelist ID if this file is inside a perforce depot."
    changelistURL: String
    "The URLs to this file on external services."
    externalURLs: [ExternalLink!]!
    "Highlight the file."
    highlight(disableTimeout: Boolean! isLightTheme: Boolean "If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.\n2000 bytes is enabled. This may produce a significant amount of HTML\nwhich some browsers (such as Chrome, but not Firefox) may have trouble\nrendering efficiently." highlightLongLines: Boolean = false "Specifies which format\/highlighting technique to use." format: HighlightResponseFormat = HTML_HIGHLIGHT "Return highlight content starting at line \"startLine\". A value <= 0 will be the start of the file.\nWarning: Pagination only works with the HTML_PLAINTEXT format type at the moment." startLine: Int "Return blob highlight ending at line \"endLine\". A value < 0 or > totalLines will set endLine to the end of the file.\nWarning: Pagination only works with the HTML_PLAINTEXT format type at the moment." endLine: Int): HighlightedFile!
}

"FileBlock specifies a file (or part of a file) to display within the block."
type FileBlock {
    "ID of the block."
    id: String!
    "File block input."
    fileInput: FileBlockInput!
}

"FileBlockInput contains the information necessary to fetch the file."
type FileBlockInput {
    "Name of the repository, e.g. \"github.com\/sourcegraph\/sourcegraph\"."
    repositoryName: String!
    "Path within the repository, e.g. \"client\/web\/file.tsx\"."
    filePath: String!
    "An optional revision, e.g. \"pr\/feature-1\", \"a9505a2947d3df53558e8c88ff8bcef390fc4e3e\".\nIf omitted, we use the latest revision (HEAD)."
    revision: String
    "An optional line range. If omitted, we display the entire file."
    lineRange: FileBlockLineRange
}

"A line range inside a file."
type FileBlockLineRange {
    "The first line to fetch (0-indexed, inclusive)."
    startLine: Int!
    "The last line to fetch (0-indexed, exclusive)."
    endLine: Int!
}

"A piece of context that represents a chunk of a file in a git repository"
type FileChunkContext {
    "The git blob this file is associated with"
    blob: GitBlob!
    "The start line of the relevant chunk (inclusive)."
    startLine: Int!
    "The end line of the relevant chunk (exclusive)."
    endLine: Int!
    "The relevant content of the file from start line to end line."
    chunkContent: String!
}

"A diff for a single file."
type FileDiff {
    "The old (original) path of the file, or null if the file was added."
    oldPath: String
    "The old file, or null if the file was created (oldFile.path == oldPath)."
    oldFile: File2
    "The new (changed) path of the file, or null if the file was deleted."
    newPath: String
    "The new file, or null if the file was deleted (newFile.path == newPath)."
    newFile: File2
    "The old file (if the file was deleted) and otherwise the new file. This file field is typically used by\nclients that want to show a \"View\" link to the file."
    mostRelevantFile: File2!
    "Hunks that were changed from old to new."
    hunks: [FileDiffHunk!]!
    "The diff stat for the whole file."
    stat: DiffStat!
    "FOR INTERNAL USE ONLY.\nAn identifier for the file diff that is unique among all other file diffs in the list that\ncontains it."
    internalID: String!
}

"A list of file diffs."
type FileDiffConnection {
    "A list of file diffs."
    nodes: [FileDiff!]!
    "The total count of file diffs in the connection, if available. This total count may be larger than the number\nof nodes in this object when the result is paginated."
    totalCount: Int
    "Pagination information."
    pageInfo: PageInfo!
    "The diff stat for the file diffs in this object, which may be a subset of the entire diff if the result is\npaginated."
    diffStat: DiffStat!
    "The raw diff for the file diffs in this object, which may be a subset of the entire diff if the result is\npaginated."
    rawDiff: String!
}

"A changed region (\"hunk\") in a file diff."
type FileDiffHunk {
    "The range of the old file that the hunk applies to."
    oldRange: FileDiffHunkRange!
    "Whether the old file had a trailing newline."
    oldNoNewlineAt: Boolean!
    "The range of the new file that the hunk applies to."
    newRange: FileDiffHunkRange!
    "The diff hunk section heading, if any."
    section: String
    "The hunk body, with lines prefixed with '-', '+', or ' '."
    body: String!
    "Highlight the hunk."
    highlight(disableTimeout: Boolean! isLightTheme: Boolean "If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.\n2000 bytes is enabled. This may produce a significant amount of HTML\nwhich some browsers (such as Chrome, but not Firefox) may have trouble\nrendering efficiently." highlightLongLines: Boolean = false "Specifies which format\/highlighting technique to use." format: HighlightResponseFormat = HTML_HIGHLIGHT): HighlightedDiffHunkBody!
}

"A hunk range in one side (old\/new) of a diff."
type FileDiffHunkRange {
    "The first line that the hunk applies to."
    startLine: Int!
    "The number of lines that the hunk applies to."
    lines: Int!
}

"A file match."
type FileMatch {
    "The file containing the match.\nKNOWN ISSUE: This file's \"commit\" field contains incomplete data.\nKNOWN ISSUE: This field's type should be File! not GitBlob!."
    file: GitBlob!
    "The repository containing the file match."
    repository: Repository!
    "The revspec of the revision that contains this match. If no revspec was given (such as when no\nrepository filter or revspec is specified in the search query), it is null."
    revSpec: GitRevSpec
    "The symbols found in this file that match the query."
    symbols: [Symbol!]!
    "The line matches."
    lineMatches: [LineMatch!]!
    "EXPERIMENTAL: This field is experimental and may be unstable.\nThe chunk matches."
    chunkMatches: [ChunkMatch!]!
    "Whether or not the limit was hit."
    limitHit: Boolean!
}

"The target repository that a changeset will be pushed to, if it's not the origin\nrepository."
type ForkTarget {
    "True if the remote target is a fork in the user namespace associated with\nthe credential used to push the changeset."
    pushUser: Boolean!
    "The specific named fork that the changeset will be pushed to."
    namespace: String
}

"Represents a terminally incomplete data point at a specific time. Only returns alerts that do not satisfy a specific implementation."
type GenericIncompleteDatapointAlert implements IncompleteDatapointAlert {
    "The data point that is incomplete."
    time: DateTime!
    "A message describing why the datapoint was marked incomplete."
    reason: String!
}

"A search result. Every type of search result, except FileMatch, must implement this interface."
interface GenericSearchResultInterface {
    "A markdown string that is rendered prominently."
    label: Markdown!
    "The URL of the result."
    url: String!
    "A markdown string that is rendered less prominently."
    detail: Markdown!
    "A list of matches in this search result."
    matches: [SearchResultMatch!]!
}

"A Git blob in a repository."
type GitBlob implements TreeEntry & File2 & Ownable {
    "The full path (relative to the repository root) of this blob."
    path: String!
    "The base name (i.e., file name only) of this blob's path."
    name: String!
    "False because this is a blob (file), not a directory."
    isDirectory: Boolean!
    "The content of this blob."
    content("Return blob content starting at line \"startLine\". A value <= 0 will be the start of the file." startLine: Int "Return blob content ending at line \"endLine\". A value < 0 or > totalLines will set endLine to the end of the file." endLine: Int): String!
    "The file size in bytes."
    byteSize: Int!
    "Total line count for the Blob. Returns 0 for binary files."
    totalLines: Int!
    "Whether or not it is binary."
    binary: Boolean!
    "The blob contents rendered as rich HTML, or an empty string if it is not a supported\nrich file type.\nThis HTML string is already escaped and thus is always safe to render."
    richHTML("Return richHTML content starting at line \"startLine\". A value <= 0 will be the start of the file." startLine: Int "Return richHTML content ending at line \"endLine\". A value < 0 or > totalLines will set endLine to the end of the file." endLine: Int): String!
    "The Git commit containing this blob."
    commit: GitCommit!
    "The repository containing this Git blob."
    repository: Repository!
    "The URL to this blob (using the input revision specifier, which may not be immutable)."
    url: String!
    "The canonical URL to this blob (using an immutable revision specifier)."
    canonicalURL: String!
    "The URL to this file using the changelist ID if this file is inside a perforce depot."
    changelistURL: String
    "The URLs to this blob on its repository's external services."
    externalURLs: [ExternalLink!]!
    "Blame the blob."
    blame(startLine: Int! endLine: Int!): [Hunk!]!
    "Highlight the blob contents."
    highlight(disableTimeout: Boolean! isLightTheme: Boolean "If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.\n2000 bytes is enabled. This may produce a significant amount of HTML\nwhich some browsers (such as Chrome, but not Firefox) may have trouble\nrendering efficiently." highlightLongLines: Boolean = false "Specifies which format\/highlighting technique to use." format: HighlightResponseFormat = HTML_HIGHLIGHT "Return highlight content starting at line \"startLine\". A value <= 0 will be the start of the file.\nWarning: Pagination only works with the HTML_PLAINTEXT format type at the moment." startLine: Int "Return highlight content ending at line \"endLine\". A value < 0 or > totalLines will set endLine to the end of the file.\nWarning: Pagination only works with the HTML_PLAINTEXT format type at the moment." endLine: Int): HighlightedFile!
    "Submodule metadata if this tree points to a submodule"
    submodule: Submodule
    "Symbols defined in this blob."
    symbols("Returns the first n symbols from the list." first: Int "Return symbols matching the query." query: String): SymbolConnection!
    "EXPERIMENTAL: Symbol defined in this blob at the specific line number and character offset."
    symbol("The line number (0-based)." line: Int! "The character offset (0-based). The offset is measured in characters, not bytes." character: Int!): Symbol
    "Always false, since a blob is a file, not directory."
    isSingleChild("Returns the first n files in the tree." first: Int "Recurse into sub-trees." recursive: Boolean = false "Recurse into sub-trees of single-child directories" recursiveSingleChild: Boolean = false): Boolean!
    "LFS is set if the GitBlob is a pointer to a file stored in LFS."
    lfs: LFS
    "A wrapper around LSIF query methods. If no LSIF upload can be used to answer code\nintelligence queries for this path-at-revision, this resolves to null."
    lsif("An optional filter for the name of the tool that produced the upload data." toolName: String): GitBlobLSIFData
    "Provides code intelligence within the file.\n\nExperimental: This API is likely to change in the future."
    localCodeIntel: JSONValue
    "A wrapper around syntactic hover and definition query methods.\n\nExperimental: This API is likely to change in the future."
    symbolInfo(line: Int! character: Int!): SymbolInfo
    "Ownership summary for this file."
    ownership("Returns the first n ownership records from the list." first: Int "Opaque pagination cursor." after: String "Return only ownership for the given reasons." reasons: [OwnershipReasonType!]): OwnershipConnection!
}

"A wrapper object around LSIF query methods for a particular git-blob-at-revision. When this node is\nnull, no LSIF data is available for the git blob in question."
type GitBlobLSIFData implements TreeEntryLSIFData {
    "Return a flat list of all ranges in the document that have code intelligence."
    stencil: [Range!]!
    "Get aggregated local code intelligence for all ranges that fall in the window\nindicated by the given zero-based start (inclusive) and end (exclusive) lines.\nThe associated data for each range is \"local\", in that the locations and hover\nmust also be defined in the same index as the source range. To get cross-repository\nand cross-bundle results, you must query the definitions, references, and hovers\nof that range explicitly."
    ranges(startLine: Int! endLine: Int!): CodeIntelligenceRangeConnection
    "A list of definitions of the symbol under the given document position."
    definitions("The line on which the symbol occurs (zero-based, inclusive)." line: Int! "The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive)." character: Int! "When specified, it filters references by filename." filter: String): LocationConnection!
    "A list of references of the symbol under the given document position."
    references("The line on which the symbol occurs (zero-based, inclusive)." line: Int! "The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive)." character: Int! "When specified, indicates that this request should be paginated and\nto fetch results starting at this cursor.\nA future request can be made for more results by passing in the\n'LocationConnection.pageInfo.endCursor' that is returned." after: String "When specified, indicates that this request should be paginated and\nthe first N results (relative to the cursor) should be returned. i.e.\nhow many results to return per page." first: Int "When specified, it filters references by filename." filter: String): LocationConnection!
    "A list of implementations of the symbol under the given document position."
    implementations("The line on which the symbol occurs (zero-based, inclusive)." line: Int! "The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive)." character: Int! "When specified, indicates that this request should be paginated and\nto fetch results starting at this cursor.\nA future request can be made for more results by passing in the\n'LocationConnection.pageInfo.endCursor' that is returned." after: String "When specified, indicates that this request should be paginated and\nthe first N results (relative to the cursor) should be returned. i.e.\nhow many results to return per page." first: Int "When specified, it filters implementation by filename." filter: String): LocationConnection!
    "A list of prototypes of the symbol under the given document position."
    prototypes("The line on which the symbol occurs (zero-based, inclusive)." line: Int! "The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive)." character: Int! "When specified, indicates that this request should be paginated and\nto fetch results starting at this cursor.\nA future request can be made for more results by passing in the\n'LocationConnection.pageInfo.endCursor' that is returned." after: String "When specified, indicates that this request should be paginated and\nthe first N results (relative to the cursor) should be returned. i.e.\nhow many results to return per page." first: Int "When specified, it filters prototypes by filename." filter: String): LocationConnection!
    "The hover result of the symbol under the given document position."
    hover("The line on which the symbol occurs (zero-based, inclusive)." line: Int! "The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive)." character: Int!): Hover
    "Code diagnostics provided through LSIF."
    diagnostics(first: Int): DiagnosticConnection!
    "The indexes that could provide precise code intelligence for the current blob."
    visibleIndexes: [PreciseIndex!]
    "SCIP snapshot data (similar to the additional information from the `scip snapshot` command) for each SCIP Occurrence."
    snapshot(indexID: ID!): [SnapshotData!]
}

"A description of a changeset that represents the proposal to merge one branch into another.\nThis is used to describe a pull request (on GitHub and Bitbucket Server)."
type GitBranchChangesetDescription {
    "The repository that this changeset spec is proposing to change."
    baseRepository: Repository!
    "The full name of the Git ref in the base repository that this changeset is based on (and is\nproposing to be merged into). This ref must exist on the base repository. For example,\n\"refs\/heads\/master\" or \"refs\/heads\/main\"."
    baseRef: String!
    "The base revision this changeset is based on. It is the latest commit in\nbaseRef at the time when the changeset spec was created.\nFor example: \"4095572721c6234cd72013fd49dff4fb48f0f8a4\""
    baseRev: String!
    "The full name of the Git ref that holds the changes proposed by this changeset. This ref will\nbe created or updated with the commits. For example, \"refs\/heads\/fix-foo\" (for\nthe Git branch \"fix-foo\")."
    headRef: String!
    "The title of the changeset on the code host.\n\nOn Bitbucket Server or GitHub this is the title of the pull request."
    title: String!
    "The body of the changeset on the code host.\n\nOn Bitbucket Server or GitHub this is the body\/description of the pull request."
    body: String!
    "The Git commits with the proposed changes. These commits are pushed to the head ref.\n\nOnly 1 commit is supported."
    commits: [GitCommitDescription!]!
    "The total diff of the changeset diff."
    diff: PreviewRepositoryComparison!
    "The diffstat of this changeset spec. This data is also available\nindirectly through the diff field above, but if only the diffStat is\nrequired, this field is cheaper to access."
    diffStat: DiffStat!
    "Whether or not the changeset described here should be created right after\napplying the ChangesetSpec this description belongs to.\n\nIf this is false, the changeset will only be created on Sourcegraph and\ncan be previewed.\n\nAnother ChangesetSpec with the same description, but \"published: true\",\ncan later be applied to publish the changeset."
    published: PublishedValue
}

"A Git commit."
type GitCommit implements Node {
    "The globally addressable ID for this commit."
    id: ID!
    "The repository that contains this commit."
    repository: Repository!
    "This commit's Git object ID (OID), a 40-character SHA-1 hash."
    oid: GitObjectID!
    "The abbreviated form of this commit's OID."
    abbreviatedOID: String!
    "EXPERIMENTAL: The perforce changelist ID if this git commit was originally converted from a perforce depot."
    perforceChangelist: PerforceChangelist
    "This commit's author."
    author: Signature!
    "This commit's committer, if any."
    committer: Signature
    "The full commit message."
    message: String!
    "The first line of the commit message."
    subject: String!
    "The contents of the commit message after the first line."
    body: String
    "Parent commits of this commit."
    parents: [GitCommit!]!
    "The URL to this commit (using the input revision specifier, which may not be immutable)."
    url: String!
    "The canonical URL to this commit (using an immutable revision specifier)."
    canonicalURL: String!
    "The URLs to this commit on its repository's external services."
    externalURLs: [ExternalLink!]!
    "The Git tree or blob in this commit at the given path."
    path("The path of the tree or blob." path: String = ""): GitTreeOrBlob
    "The Git tree in this commit at the given path."
    tree("The path of the tree." path: String = "" "Whether to recurse into sub-trees. If true, it overrides the value of the \"recursive\" parameter on all of\nGitTree's fields.\nDEPRECATED: Use the \"recursive\" parameter on GitTree's fields instead." recursive: Boolean = false): GitTree
    "A list of file names in this repository."
    fileNames: [String!]!
    "The Git blob in this commit at the given path."
    blob(path: String!): GitBlob
    "The file at the given path for this commit.\nSee \"File\" documentation for the difference between this field and the \"blob\" field."
    file(path: String!): File2
    "Lists the programming languages present in the tree at this commit."
    languages: [String!]!
    "List statistics for each language present in the repository."
    languageStatistics: [LanguageStatistics!]!
    "The log of commits consisting of this commit and its ancestors."
    ancestors("Returns the first n commits from the list." first: Int "Return commits that match the query." query: String "Return commits that affect the path." path: String "Follow history beyond renames (only works for a single file)." follow: Boolean = false "Return commits more recent than the specified date." after: String "Skip the first N commits of the repo before returning the number of commits as set in the field \"first\"." afterCursor: String "Return commits older than the specified date." before: String): GitCommitConnection!
    "Returns the number of commits that this commit is behind and ahead of revspec."
    behindAhead(revspec: String!): BehindAheadCounts!
    "Symbols defined as of this commit. (All symbols, not just symbols that were newly defined in this commit.)"
    symbols("Returns the first n symbols from the list." first: Int "Return symbols matching the query." query: String "A list of regular expressions, all of which must match all\nfile paths returned in the list." includePatterns: [String!]): SymbolConnection!
    "Returns the comparison with another revision."
    diff("The base commit to compare to. Defaults to the commit's first parent." base: String): RepositoryComparison!
    "Owners of the repository at this commit."
    ownership("Returns the first n ownership records from the list." first: Int "Opaque pagination cursor." after: String): OwnershipConnection!
}

"A list of Git commits."
type GitCommitConnection {
    "A list of Git commits."
    nodes: [GitCommit!]!
    "The total number of Git commits in the connection. If the GitCommitConnection is paginated\n(e.g., because a \"first\" parameter was provided to the field that produced it), this field is\nnull to avoid it taking unexpectedly long to compute the total count. Remove the pagination\nparameters to obtain a non-null value for this field."
    totalCount: Int
    "Pagination information."
    pageInfo: PageInfo!
}

"A description of a Git commit."
type GitCommitDescription {
    "The full commit message."
    message: String!
    "The first line of the commit message."
    subject: String!
    "The contents of the commit message after the first line."
    body: String
    "The Git commit author."
    author: Person!
    "The commit diff (in unified diff format).\n\nThe filenames must not be prefixed (e.g., with 'a\/' and 'b\/'). Tip: use 'git diff --no-prefix'\nto omit the prefix."
    diff: String!
}

"Represents a GitHub account on which the App was installed."
type GitHubAccount {
    "The login username of the account."
    login: String!
    "The avatar URL of the account."
    avatarURL: String!
    "A link to the account on GitHub."
    url: String!
    "The account type."
    type: String!
}

"A GitHub App configuration."
type GitHubApp implements Node {
    "Unique ID of the GitHub App"
    id: ID!
    "The GitHub App ID"
    appID: Int!
    "The name of the GitHub App"
    name: String!
    "The domain of the GitHub App (e.g. \"repos\" or \"batches\")"
    domain: String!
    "The slug of the GitHub App"
    slug: String!
    "The base URL of the GitHub App"
    baseURL: String!
    "The URL of the GitHub App page"
    appURL: String!
    "The client ID of the GitHub App"
    clientID: String!
    "The client secret of the GitHub App"
    clientSecret: String!
    "The logo URL of the GitHub App"
    logo: String!
    "The created at timestamp of the GitHub App in our database"
    createdAt: DateTime!
    "The updated at timestamp of the GitHub App in our database"
    updatedAt: DateTime!
    "Fetches a list of installation IDs for this GitHub App."
    installations: [Installation!]!
    "Fetches the webhook associated with this GitHub App."
    webhook: Webhook
}

"A list of GitHub Apps."
type GitHubAppConnection {
    "A list of GitHub Apps."
    nodes: [GitHubApp!]!
    "The total count of GitHub Apps in the connection."
    totalCount: Int!
}

"GitHubAppDomain enumerates the domains in which GitHub Apps can be used."
enum GitHubAppDomain {
    "GitHub Apps that are configured for repository syncing."
    REPOS
    "GitHub Apps that are configured for batch changes commit signing."
    BATCHES
}

"The verification object describing the result of verifying the commit's signature.\nhttps:\/\/docs.github.com\/en\/rest\/git\/commits?apiVersion=2022-11-28#create-a-commit"
type GitHubCommitVerification {
    "Indicates whether GitHub considers the signature in the commit verified"
    verified: Boolean!
    "The reason for the verified value"
    reason: String!
    "The signature extracted from the commit"
    signature: String!
    "The value that was signed"
    payload: String!
}

"A Git object."
type GitObject {
    "This object's OID."
    oid: GitObjectID!
    "The abbreviated form of this object's OID."
    abbreviatedOID: String!
    "The commit object, if it is a commit and it exists; otherwise null."
    commit: GitCommit
    "The Git object's type."
    type: GitObjectType!
}

"A decorated connection of Git objects resulting from 'previewGitObjectFilter'."
type GitObjectFilterPreview {
    "A list of Git objects composing the current page."
    nodes: [CodeIntelGitObject!]!
    "The total number of Git objects in this result set."
    totalCount: Int!
    "When countObjectsYoungerThanHours is supplied, this holds the total number of Git\nobjects in the result set that have an associated commit date younger than the\nsupplied threshold."
    totalCountYoungerThanThreshold: Int
}

"A Git object ID (SHA-1 hash, 40 hexadecimal characters)."
scalar GitObjectID

"All possible types of Git objects."
enum GitObjectType {
    "A Git commit object."
    GIT_COMMIT
    "A Git tag object."
    GIT_TAG
    "A Git tree object."
    GIT_TREE
    "A Git blob object."
    GIT_BLOB
    "A Git object of unknown type."
    GIT_UNKNOWN
}

"A Git ref."
type GitRef implements Node {
    "The globally addressable ID for the Git ref."
    id: ID!
    "The full ref name (e.g., \"refs\/heads\/mybranch\" or \"refs\/tags\/mytag\")."
    name: String!
    "An unambiguous short name for the ref."
    abbrevName: String!
    "The display name of the ref. For branches (\"refs\/heads\/foo\"), this is the branch\nname (\"foo\").\nAs a special case, for GitHub pull request refs of the form refs\/pull\/NUMBER\/head,\nthis is \"NUMBER\"."
    displayName: String!
    "The prefix of the ref, either \"\", \"refs\/\", \"refs\/heads\/\", \"refs\/pull\/\", or\n\"refs\/tags\/\". This prefix is always a prefix of the ref's name."
    prefix: String!
    "The type of this Git ref."
    type: GitRefType!
    "The object that the ref points to."
    target: GitObject!
    "The associated repository."
    repository: Repository!
    "The URL to this Git ref."
    url: String!
}

"A list of Git refs."
type GitRefConnection {
    "A list of Git refs."
    nodes: [GitRef!]!
    "The total count of Git refs in the connection. This total count may be larger\nthan the number of nodes in this object when the result is paginated."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"Ordering options for Git refs."
enum GitRefOrder {
    "By the authored or committed at date, whichever is more recent."
    AUTHORED_OR_COMMITTED_AT
}

"All possible types of Git refs."
enum GitRefType {
    "A Git branch (in refs\/heads\/)."
    GIT_BRANCH
    "A Git tag (in refs\/tags\/)."
    GIT_TAG
    "A Git ref that is neither a branch nor tag."
    GIT_REF_OTHER
}

"A Git revspec."
union GitRevSpec = GitRef | GitRevSpecExpr | GitObject

"A Git revspec expression that (possibly) resolves to a Git revision."
type GitRevSpecExpr {
    "The original Git revspec expression."
    expr: String!
    "The Git object that the revspec resolves to, or null otherwise."
    object: GitObject
}

"A Git revision range of the form \"base..head\" or \"base...head\". Other revision\nrange formats are not supported."
type GitRevisionRange {
    "The Git revision range expression of the form \"base..head\" or \"base...head\"."
    expr: String!
    "The base (left-hand side) of the range."
    base: GitRevSpec!
    "The base's revspec as an expression."
    baseRevSpec: GitRevSpecExpr!
    "The head (right-hand side) of the range."
    head: GitRevSpec!
    "The head's revspec as an expression."
    headRevSpec: GitRevSpecExpr!
    "The merge-base of the base and head revisions, if this is a \"base...head\"\nrevision range. If this is a \"base..head\" revision range, then this field is null."
    mergeBase: GitObject
}

"A Git tree in a repository."
type GitTree implements TreeEntry {
    "The full path (relative to the root) of this tree."
    path: String!
    "Whether this tree is the root (top-level) tree."
    isRoot: Boolean!
    "The base name (i.e., last path component only) of this tree."
    name: String!
    "True because this is a directory. (The value differs for other TreeEntry interface implementations, such as\nFile.)"
    isDirectory: Boolean!
    "The Git commit containing this tree."
    commit: GitCommit!
    "The repository containing this tree."
    repository: Repository!
    "The URL to this tree (using the input revision specifier, which may not be immutable)."
    url: String!
    "The canonical URL to this tree (using an immutable revision specifier)."
    canonicalURL: String!
    "The URLs to this tree on external services."
    externalURLs: [ExternalLink!]!
    "The URL to this entry's raw contents as a Zip archive."
    rawZipArchiveURL: String!
    "Submodule metadata if this tree points to a submodule"
    submodule: Submodule
    "A list of directories in this tree."
    directories("Returns the first n files in the tree." first: Int "Recurse into sub-trees." recursive: Boolean = false): [GitTree!]!
    "A list of files in this tree."
    files("Returns the first n files in the tree." first: Int "Recurse into sub-trees." recursive: Boolean = false): [File!]!
    "A list of entries in this tree."
    entries("Returns the first n files in the tree." first: Int "Recurse into sub-trees. If true, implies recursiveSingleChild." recursive: Boolean = false "Recurse into sub-trees of single-child directories. If true, we return a flat list of\nevery directory that is a single child, and any directories or files that are\nnested in a single child." recursiveSingleChild: Boolean = false "Includes all parent directories and their entries. For example, if the path is\n`\/client\/web\/something`, it will return the following entries in this order:\n\n  - `\/*`\n  - `\/client\/*`\n  - `\/client\/web\/*`\n  - `\/client\/web\/something\/*`\n\nThis is useful for rendering a collapsed tree view for the entry." ancestors: Boolean = false): [TreeEntry!]!
    "Symbols defined in this tree."
    symbols("Returns the first n symbols from the list." first: Int "Return symbols matching the query." query: String): SymbolConnection!
    "Whether this tree entry is a single child"
    isSingleChild("Returns the first n files in the tree." first: Int "Recurse into sub-trees." recursive: Boolean = false "Recurse into sub-trees of single-child directories" recursiveSingleChild: Boolean = false): Boolean!
    "LSIF data for this tree entry."
    lsif("An optional filter for the name of the tool that produced the upload data." toolName: String): GitTreeLSIFData
    "Owners of the directory at revision."
    ownership("Returns the first n ownership records from the list." first: Int "Opaque pagination cursor." after: String): OwnershipConnection!
    "Ownership statistics for all the files (deeply) contained in this tree."
    ownershipStats: OwnershipStats!
}

"A wrapper object around LSIF query methods for a particular git-tree-at-revision. When this node is\nnull, no LSIF data is available for the git tree in question."
type GitTreeLSIFData implements TreeEntryLSIFData {
    "Code diagnostics provided through LSIF."
    diagnostics(first: Int): DiagnosticConnection!
}

"Either a git tree or blob."
union GitTreeOrBlob = GitTree | GitBlob

"FOR INTERNAL USE ONLY: A status message produced when disableAutoGitUpdates is\nset to true in the site configuration"
type GitUpdatesDisabled {
    "The message of this status message"
    message: String!
}

"Stats on all the changesets across the instance."
type GlobalChangesetsStats {
    "The count of unpublished changesets."
    unpublished: Int!
    "The count of draft changesets."
    draft: Int!
    "The count of open changesets."
    open: Int!
    "The count of merged changesets."
    merged: Int!
    "The count of closed changesets."
    closed: Int!
    "The count of all changesets."
    total: Int!
}

"THe progress of current and historic precise ranking jobs."
type GlobalRankingSummary {
    "Precise ranking job summaries ordered reverse-chronologically."
    rankingSummary: [RankingSummary!]!
    "The key of the current ranking summary."
    derivativeGraphKey: String
    "The time that the next ranking job is configured to begin."
    nextJobStartsAt: DateTime
    "The current number of SCIP indexes that are visible to the ranking calculation."
    numExportedIndexes: Int!
    "The target number of SCIP indexes that are visible to the ranking calculation."
    numTargetIndexes: Int!
    "The number of repositories which have ranks but haven't been indexed since the\nranking scores became available."
    numRepositoriesWithoutCurrentRanks: Int!
}

"Fields that can be grouped on for compute powered insights."
enum GroupByField {
    REPO
    LANG
    PATH
    AUTHOR
    DATE
}

"A key-value pair"
type HTTPHeader {
    "The header name"
    name: String!
    "Can be multiple values"
    values: [String!]!
}

"Input for a happiness feedback submission."
input HappinessFeedbackSubmissionInput {
    "The feedback text from the user."
    feedback: String
    "The path that the happiness feedback will be submitted from."
    currentPath: String
}

"A preview entry to a repository to which the user has no access."
union HiddenApplyPreviewTargets = HiddenApplyPreviewTargetsAttach | HiddenApplyPreviewTargetsUpdate | HiddenApplyPreviewTargetsDetach

"A preview entry where no changeset existed before matching the changeset spec."
type HiddenApplyPreviewTargetsAttach {
    "The changeset spec from this entry."
    changesetSpec: HiddenChangesetSpec!
}

"A preview entry where no changeset spec exists for the changeset currently in\nthe target batch change."
type HiddenApplyPreviewTargetsDetach {
    "The changeset from this entry."
    changeset: HiddenExternalChangeset!
}

"A preview entry where a changeset matches the changeset spec."
type HiddenApplyPreviewTargetsUpdate {
    "The changeset spec from this entry."
    changesetSpec: HiddenChangesetSpec!
    "The changeset from this entry."
    changeset: HiddenExternalChangeset!
}

"A workspace to which the requesting user does not have access."
type HiddenBatchSpecWorkspace implements BatchSpecWorkspace & Node {
    "The unique ID for the workspace."
    id: ID!
    "Used for reverse querying."
    batchSpec: BatchSpec!
    "If true, only the files within the workspace will be fetched."
    onlyFetchWorkspace: Boolean!
    "If true, this workspace has been skipped, because some rule forced this.\nFor now, the only one is a .batchignore file existing in the repository."
    ignored: Boolean!
    "If true, this workspace has been skipped, because the code host on which\nthe repository is hosted is not supported."
    unsupported: Boolean!
    "Whether we found a task cache result."
    cachedResultFound: Boolean!
    "How many steps had a cached result."
    stepCacheResultCount: Int!
    "The time when the workspace was enqueued for processing. Null, if not yet enqueued."
    queuedAt: DateTime
    "The time when the workspace started processing. Null, if not yet started."
    startedAt: DateTime
    "The time when the workspace finished processing. Null, if not yet finished."
    finishedAt: DateTime
    "The current state the workspace is in."
    state: BatchSpecWorkspaceState!
    "The rank of this execution in the queue of the user. The value of this field is null if the\nexecution has started."
    placeInQueue: Int
    "The rank of this execution in the global queue. The value of this field is null if the\nexecution has started."
    placeInGlobalQueue: Int
    "The diff stat over all created changeset specs. Null, if not yet finished or\nfailed."
    diffStat: DiffStat
}

"One preview entry in the list of all previews against a batch spec. Each mapping\nbetween changeset specs and current changesets yields one of these. It describes\nwhich operations are taken against which changeset spec and changeset to ensure the\ndesired state is met."
type HiddenChangesetApplyPreview {
    "The operations to take to achieve the desired state."
    operations: [ChangesetSpecOperation!]!
    "The delta between the current changeset state and what the new changeset spec\nenvisions the changeset to look like."
    delta: ChangesetSpecDelta!
    "The target entities in this preview entry."
    targets: HiddenApplyPreviewTargets!
}

"A changeset spec is an immutable description of the desired state of a changeset in a batch change. To\ncreate a changeset spec, use the createChangesetSpec mutation."
type HiddenChangesetSpec implements ChangesetSpec & Node {
    "The unique ID for a changeset spec.\n\nThe ID is unguessable (i.e., long and randomly generated, not sequential). This is important\neven though repository permissions also apply to viewers of changeset specs, because being\nallowed to view a repository should not entitle a person to view all not-yet-published\nchangesets for that repository. Consider a batch change to fix a security vulnerability: the\nbatch change author may prefer to prepare all of the changesets in private so that the window\nbetween revealing the problem and merging the fixes is as short as possible."
    id: ID!
    "The type of changeset spec."
    type: ChangesetSpecType!
    "The date, if any, when this changeset spec expires and is automatically purged. A changeset\nspec never expires (and this field is null) if its batch spec has been applied."
    expiresAt: DateTime
}

"A changeset on a code host that the user does not have access to."
type HiddenExternalChangeset implements Node & Changeset {
    "The unique ID for the changeset."
    id: ID!
    "The batch changes that contain this changeset."
    batchChanges("Returns the first n batch changes from the list." first: Int = 50 "Opaque pagination cursor." after: String "Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`." state: BatchChangeState "Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it." states: [BatchChangeState!] "Only include batch changes that the viewer can administer." viewerCanAdminister: Boolean): BatchChangeConnection!
    "The state of the changeset."
    state: ChangesetState!
    "The date and time when the changeset was created."
    createdAt: DateTime!
    "The date and time when the changeset was updated."
    updatedAt: DateTime!
    "The date and time when the next changeset sync is scheduled, or null if none is scheduled."
    nextSyncAt: DateTime
}

"A highlighted region in a string (e.g., matched by a query)."
type Highlight {
    "The 1-indexed line number."
    line: Int!
    "The 1-indexed character on the line."
    character: Int!
    "The length of the highlight, in characters (on the same line)."
    length: Int!
}

"A specific highlighted line range to fetch."
input HighlightLineRange {
    "The first line to fetch (0-indexed, inclusive). Values outside the bounds of the file will\nautomatically be clamped within the valid range."
    startLine: Int!
    "The last line to fetch (0-indexed, inclusive). Values outside the bounds of the file will\nautomatically be clamped within the valid range."
    endLine: Int!
}

"The format and highlighting to use when requesting highlighting information for a file."
enum HighlightResponseFormat {
    "HTML formatted file content without syntax highlighting."
    HTML_PLAINTEXT
    "HTML formatted file content with syntax highlighting."
    HTML_HIGHLIGHT
    "SCIP highlighting information as JSON."
    JSON_SCIP
}

"A highlighted hunk, consisting of all its lines."
type HighlightedDiffHunkBody {
    "Whether highlighting was aborted."
    aborted: Boolean!
    "The highlighted lines."
    lines: [HighlightedDiffHunkLine!]!
}

"A single highlighted line, including the kind of line."
type HighlightedDiffHunkLine {
    "The HTML containing the syntax-highlighted line of code."
    html: String!
    "The operation that happened on this line, in patches it is prefixed with '+', '-', ' '.\nCan be either add, delete, or no change."
    kind: DiffHunkLineType!
}

"A highlighted file."
type HighlightedFile {
    "Whether or not it was aborted."
    aborted: Boolean!
    "The HTML table that can be used to display the highlighted file."
    html: String!
    "Base64 encoded JSON payload of LSIF Typed with syntax highlighting data."
    lsif: String!
    "A list of the desired line ranges. Each list is a list of lines, where each element is an HTML\ntable row '<tr>...<\/tr>' string. This is useful if you only need to display specific subsets of\nthe file."
    lineRanges(ranges: [HighlightLineRange!]!): [[String!]!]!
}

"A string that has highlights (e.g, query matches)."
type HighlightedString {
    "The full contents of the string."
    value: String!
    "Highlighted matches of the query in the preview string."
    highlights: [Highlight!]!
}

"Hover range and markdown content."
type Hover {
    "A markdown string containing the contents of the hover."
    markdown: Markdown!
    "The range to highlight."
    range: Range!
}

"A hunk."
type Hunk {
    "The startLine."
    startLine: Int!
    "The endLine."
    endLine: Int!
    "The startByte."
    startByte: Int!
    "The endByte."
    endByte: Int!
    "The rev."
    rev: String!
    "The author."
    author: Signature!
    "The message."
    message: String!
    "The commit that contains the hunk."
    commit: GitCommit!
    "The original filename at the commit. Use this filename if you're reading the\ntext contents of the file at the `commit` field of this hunk. The file may\nhave been renamed after the commit so name of file where this hunk got computed\nmay not exist."
    filename: String!
}

"Represents a terminally incomplete data point at a specific time, and optionally for a specific repository."
interface IncompleteDatapointAlert {
    "The data point that is incomplete."
    time: DateTime!
}

"Explicit configuration for indexing a repository."
type IndexConfiguration {
    "The raw JSON-encoded index configuration."
    configuration: String
    "The parsed index configuration (decoded from the raw JSON version)."
    parsedConfiguration: [AutoIndexJobDescription!]
    "The raw JSON-encoded index configuration as inferred by the auto-indexer."
    inferredConfiguration: InferredConfiguration
}

"The configuration and execution summary of the indexer."
type IndexStep {
    "Commands to run in the same image as the indexer but before the indexer is invoked."
    commands: [String!]!
    "The arguments to supply to the indexer container."
    indexerArgs: [String!]!
    "The path to the index file relative to the root directory (dump.lsif by default)."
    outfile: String
    "A list of environment variables (VAR=VAL) that should be made available to the indexer."
    requestedEnvVars: [String!]
    "The execution summary (if completed or errored) of the index command."
    logEntry: ExecutionLogEntry
}

"Configuration and execution summary of an index job."
type IndexSteps {
    "Execution log entries related to setting up the indexing workspace."
    setup: [ExecutionLogEntry!]!
    "Configuration and execution summary (if completed or errored) of steps to be performed prior to indexing."
    preIndex: [PreIndexStep!]!
    "Configuration and execution summary (if completed or errored) of the indexer."
    index: IndexStep!
    "Execution log entry related to uploading the dump produced by the indexing step.\nThis field be missing if the upload step had not been executed."
    upload: ExecutionLogEntry
    "Execution log entries related to tearing down the indexing workspace."
    teardown: [ExecutionLogEntry!]!
}

"A precise indexer paired with a count of indexable projects in the repository (used by CodeIntelSummary)."
type IndexerWithCount {
    "The repository."
    indexer: CodeIntelIndexer
    "The count of projects that could utilize the indexer in this repository."
    count: Int!
}

"FOR INTERNAL USE ONLY: A status message produced when repositories are being\nindexed for search."
type IndexingProgress {
    "The number of repositories that have not been indexed yet."
    notIndexed: Int!
    "The number of repositories that have been indexed."
    indexed: Int!
}

"The result of running the auto-index inference script over a particular repo."
type InferAutoIndexJobsResult {
    "The list of inferred jobs."
    jobs: [AutoIndexJobDescription!]!
    "The output from the inference script."
    inferenceOutput: String!
}

"The additionally available indexers that have been inferred from jobs and job hints that could be indexed but haven't been indexed."
type InferredAvailableIndexers {
    "The indexer."
    indexer: CodeIntelIndexer!
    "The list of roots that could be indexed."
    roots: [String!]!
    "The list of roots that could be indexed."
    rootsWithKeys: [RootWithKey!]!
}

"A wrapper around inferred configuration and a possible limit error."
type InferredConfiguration {
    "The raw JSON-encoded inferred index configuration."
    configuration: String!
    "The parsed index configuration (decoded from the raw JSON version)."
    parsedConfiguration: [AutoIndexJobDescription!]
    "If inference of the repository contents hit a limit its error description will available here."
    limitError: String
}

"An insight about code."
type Insight {
    "The short title of the insight."
    title: String!
    "The description of the insight."
    description: String!
    "Data points over a time range (inclusive)"
    series: [InsightsSeries!]!
    "Unique identifier for this insight."
    id: String!
}

"Information about an item in the insights backfill queue"
type InsightBackfillQueueItem {
    "The ID of the Backfill item"
    id: ID!
    "The title of the insight view"
    insightViewTitle: String!
    "The user that originally created the insight view"
    creator: User
    "The name of the series on the associated insight view"
    seriesLabel: String!
    "The search query for the series"
    seriesSearchQuery: String!
    "Information on the current backfill status"
    backfillQueueStatus: BackfillStatus!
}

"Returns information regarding the insights backfill queue to admin users."
type InsightBackfillQueueItemConnection implements Connection {
    "A list of insight backfill queue items."
    nodes: [InsightBackfillQueueItem!]!
    "The total number of insight backfill queue items in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: ConnectionPageInfo!
}

"A code insight data point."
type InsightDataPoint {
    "The time of this data point."
    dateTime: DateTime!
    "The value of the insight at this point in time."
    value: Float!
    "A search query that will show the diff between this point and the previous point"
    diffQuery: String
}

"Defines how the data series is generated."
union InsightDataSeriesDefinition = SearchInsightDataSeriesDefinition

"Defines a time scope using an interval of time"
type InsightIntervalTimeScope {
    "The unit of time."
    unit: TimeIntervalStepUnit!
    "The value of time."
    value: Int!
}

"Defines presentation options for the insight."
union InsightPresentation = LineChartInsightViewPresentation | PieChartInsightViewPresentation

"Possible queue states"
enum InsightQueueItemState {
    NEW
    QUEUED
    COMPLETED
    PROCESSING
    FAILED
    UNKNOWN
}

"Defines how the scope of repositories was generated"
union InsightRepositoryDefinition = RepositorySearchScope | InsightRepositoryScope

"A custom repository scope for an insight. A scope with all empty fields implies a global scope."
type InsightRepositoryScope {
    "The list of repositories in the scope."
    repositories: [String!]!
}

"Metadata about a specific data series for an insight."
type InsightSeriesMetadata {
    "Unique ID for the series."
    seriesId: String!
    "Sourcegraph query string used to generate the series."
    query: String!
    "Current status of the series."
    enabled: Boolean!
}

"Wrapper payload object for insight series metadata."
type InsightSeriesMetadataPayload {
    "The series metadata."
    series: InsightSeriesMetadata!
}

"Information about queue status for insight series queries."
type InsightSeriesQueryStatus {
    "Unique ID for the series."
    seriesId: String!
    "Sourcegraph query string used to generate the series. This is the base query string that was input by the user,\nand does not include each repository specific query that would be generated to backfill an entire series."
    query: String!
    "The current activity status for this series."
    enabled: Boolean!
    "The number of queries belonging to the series with errored status. Errored is a transient state representing a retryable error that has not\nyet exceeded the max retry count. This count only represents the queries that have yet to be pruned by the background maintenance workers."
    errored: Int!
    "The number of queries belonging to the series that are successfully completed.\nThis count only represents the queries that have yet to be pruned by the background maintenance workers."
    completed: Int!
    "The number of queries belonging to the series that are currently processing.\nThis count only represents the queries that have yet to be pruned by the background maintenance workers."
    processing: Int!
    "The number of queries belonging to the series that are terminally failed. These have either been marked as non-retryable or exceeded\nthe max retry limit. This count only represents the queries that have yet to be pruned by the background maintenance workers."
    failed: Int!
    "The number of queries belonging to the series that are queued for processing.\nThis count only represents the queries that have yet to be pruned by the background maintenance workers."
    queued: Int!
}

"Status indicators for a specific series of insight data."
type InsightSeriesStatus {
    "The total number of points stored for this series, at the finest level\n(e.g. per repository, or per-repository-per-language) Has no strict relation\nto the data points shown in the web UI or returned by `points()`, because those\nare aggregated and this number _can_ report some duplicates points which get\nstored but removed at query time for the web UI.\n\nWhy its useful: an insight may look like \"it is doing nothing\" but in reality\nthis number will be increasing by e.g. several thousands of points rapidly."
    totalPoints: Int!
    "The total number of jobs currently pending to add new data points for this series.\n\nEach job may create multiple data points (e.g. a job may create one data point per\nrepo, or language, etc.) This number will go up and down over time until all work\nis completed (discovering work takes almost as long as doing the work.)\n\nWhy its useful: signals \"amount of work still to be done.\""
    pendingJobs: Int!
    "The total number of jobs completed for this series. Note that since pendingJobs will\ngo up\/down over time, you CANNOT divide these two numbers to get a percentage as it\nwould be nonsense (\"it says 90% complete but has been like that for a really long\ntime!\").\n\nDoes not include 'failedJobs'.\n\nWhy its useful: gives an indication of \"how much work has been done?\""
    completedJobs: Int!
    "The total number of jobs that were tried multiple times and outright failed. They will\nnot be retried again, and indicates the series has incomplete data.\n\nUse ((failedJobs \/ completedJobs) * 100.0) to get an approximate percentage of how\nmuch data the series data may be missing (e.g. ((30 \/ 150)*100.0) == 20% of the series\ndata is incomplete (rough approximation, not precise).\n\nWhy its useful: signals if there are problems, and how severe they are."
    failedJobs: Int!
    "The time that the insight series completed a full iteration and queued up records for processing. This can\neffectively be used as a status that the insight is still processing if returned null."
    backfillQueuedAt: DateTime
    "Indicates if the series is currently loading additional data"
    isLoadingData: Boolean
    "Data points that are flagged terminally incomplete for this series."
    incompleteDatapoints: [IncompleteDatapointAlert!]!
}

"Defines a scope of time for which the insight data is generated."
union InsightTimeScope = InsightIntervalTimeScope

"An Insight View is a lens to view insight data series. In most cases this corresponds to a visualization of an insight, containing multiple series."
type InsightView implements Node {
    "The View ID."
    id: ID!
    "The default filters saved on the insight. This will differ from the applied filters if they are overwritten but not saved."
    defaultFilters: InsightViewFilters!
    "The filters currently applied to the insight and the data."
    appliedFilters: InsightViewFilters!
    "The time series data for this insight."
    dataSeries: [InsightsSeries!]!
    "Presentation options for the insight."
    presentation: InsightPresentation!
    "Information on how each data series was generated"
    dataSeriesDefinitions: [InsightDataSeriesDefinition!]!
    "The total number of dashboards on which this insight is referenced. The count is global and disregards permissions."
    dashboardReferenceCount: Int!
    "Represents if this insight is in a frozen state or not. A frozen state is relevant when a license is downgraded and the number of insights exceed the free plan limits."
    isFrozen: Boolean!
    "The default series display options saved on the insight. This will differ from the applied options if they are overwritten but not saved."
    defaultSeriesDisplayOptions: SeriesDisplayOptions!
    "The series display options currently applied to the insight."
    appliedSeriesDisplayOptions: SeriesDisplayOptions!
    "Dashboards this insight has been added to that the current user has permission to view"
    dashboards(first: Int after: String id: ID): InsightsDashboardConnection
    "The total number of series on this insight."
    seriesCount: Int
    "The Repositories the dataSeries on this insight will operate over."
    repositoryDefinition: InsightRepositoryDefinition!
    "The scope of time for which the insight data is generated."
    timeScope: InsightTimeScope!
}

"A dashboard of insight views."
type InsightViewConnection {
    "A list of insights."
    nodes: [InsightView]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of insights in the connection."
    totalCount: Int
}

"Input for the default values for filters and aggregates for an insight."
input InsightViewControlsInput {
    "Input for the default filters for an insight."
    filters: InsightViewFiltersInput!
    "Input for series' sort order."
    seriesDisplayOptions: SeriesDisplayOptionsInput!
}

"Debugging information related to an InsightView"
type InsightViewDebug {
    "A JSON dump of debug information for series on the insight view"
    raw: [String!]!
}

"The fields and values for which the insight is filtered."
type InsightViewFilters {
    "A regex string for which to include repositories in a filter."
    includeRepoRegex: String
    "A regex string for which to exclude repositories from a filter."
    excludeRepoRegex: String
    "The names of query based search contexts that are used as a filter."
    searchContexts: [String!]
}

"Input for the default values by which the insight is filtered."
input InsightViewFiltersInput {
    "A regex string for which to include repositories in a filter."
    includeRepoRegex: String
    "A regex string for which to exclude repositories in a filter."
    excludeRepoRegex: String
    "A list of query based search contexts to include in the filters for the view."
    searchContexts: [String!]
}

"Response wrapper object for insight view mutations."
type InsightViewPayload {
    "The resulting view."
    view: InsightView!
}

"A dashboard of insights."
type InsightsDashboard implements Node {
    "The Dashboard ID."
    id: ID!
    "The Dashboard Title."
    title: String!
    "The list of associated insights to the dashboard."
    views(first: Int after: ID): InsightViewConnection
    "The permission grants assossiated with the dashboard."
    grants: InsightsPermissionGrants!
}

"A paginated list of dashboards."
type InsightsDashboardConnection {
    "A list of dashboards."
    nodes: [InsightsDashboard!]!
    "Pagination information."
    pageInfo: PageInfo!
}

"Response wrapper object for insight dashboard mutations."
type InsightsDashboardPayload {
    "The result dashboard after mutation."
    dashboard: InsightsDashboard!
}

"Permissions object. Note: only organizations the user has access to will be included."
type InsightsPermissionGrants {
    "Specific users that have permission."
    users: [ID!]!
    "Organizations that have permission."
    organizations: [ID!]!
    "True if the permission is set to global."
    global: Boolean!
}

"Input object for permissions to grant."
input InsightsPermissionGrantsInput {
    "Specific users to grant permissions to."
    users: [ID!]
    "Organizations to grant permissions to."
    organizations: [ID!]
    "Set global to true to grant global permission."
    global: Boolean
}

"A series of data about a code insight."
type InsightsSeries {
    "Unique ID for the series."
    seriesId: String!
    "The label used to describe this series of data points."
    label: String!
    "Data points over a time range (inclusive)\n\nThe 'from', 'to', 'includeRepoRegex' and 'excludeRepoRegex' arguments have been deprecated.\nThey will have no affect on the points returned and will be removed in a future version."
    points(from: DateTime to: DateTime includeRepoRegex: String excludeRepoRegex: String): [InsightDataPoint!]!
    "The status of this series of data, e.g. progress collecting it."
    status: InsightSeriesStatus!
}

"Represents a single GitHub App installation."
type Installation {
    "The installation ID of the App."
    id: Int!
    "The installation URL."
    url: String!
    "The account on which the App was installed"
    account: GitHubAccount!
    "The external services derived from this installation."
    externalServices(first: Int): ExternalServiceConnection!
}

"The result of Mutation.inviteUserToOrganization."
type InviteUserToOrganizationResult {
    "Whether an invitation email was sent. If emails are not enabled on this site or if the user has no verified\nemail address, an email will not be sent."
    sentInvitationEmail: Boolean!
    "The URL that the invited user can visit to accept or reject the invitation."
    invitationURL: String!
}

"A string that contains valid JSON, with additional support for \/\/-style comments and trailing commas."
scalar JSONCString

"A valid JSON value."
scalar JSONValue

"A segment of a key path that locates a nested JSON value in a root JSON value. Exactly one field in each\nKeyPathSegment must be non-null.\nFor example, in {\"a\": [0, {\"b\": 3}]}, the value 3 is located at the key path [\"a\", 1, \"b\"]."
input KeyPathSegment {
    "The name of the property in the object at this location to descend into."
    property: String
    "The index of the array at this location to descend into."
    index: Int
}

"A key-value pair"
type KeyValuePair {
    "The non-nullable key."
    key: String!
    "The nullable value. A null value indicates this key-value pair should be treated as a tag."
    value: String
}

"Information about a blob stored in Git Large File Storage (LFS)."
type LFS {
    "The size of the file in LFS in bytes.\nNote: the file size in the GitBlob will be the size of the pointer not the file a\nuser checks out."
    byteSize: BigInt!
}

"Contains the metadata and upload data for a single state change of an upload."
type LSIFUploadAuditLog {
    "The timestamp the log was emitted at."
    logTimestamp: DateTime!
    "The timestamp when the associated upload was deleted at."
    uploadDeletedAt: DateTime
    "The reason for this change in data."
    reason: String
    "A list of changed columns in the format {\"column\": \"<colname>\", \"new\": \"<newval>\", \"old\": \"<oldval>\"}"
    changedColumns: [AuditLogColumnChange!]!
    "The ID of the upload."
    uploadId: ID!
    "The original 40-character commit commit supplied at upload time."
    inputCommit: String!
    "The original root supplied at upload time."
    inputRoot: String!
    "The original indexer name supplied at upload time."
    inputIndexer: String!
    "The time the upload was uploaded."
    uploadedAt: DateTime!
    "The operation denoted by this log."
    operation: AuditLogOperation!
}

"A programming language."
type Language {
    "Name of the programming language."
    name: String!
}

"Statistics about a language's usage."
type LanguageStatistics {
    "The name of the language."
    name: String!
    "The total bytes in the language."
    totalBytes: Float!
    "The total number of lines in the language."
    totalLines: Int!
}

"License feature info type."
type LicenseFeature {
    "License feature name."
    name: String!
    "Whether feature is enabled or not by the license."
    enabled: Boolean!
}

"License basic info type."
type LicenseInfo {
    "License plan."
    plan: String!
    "License expiration date."
    expiresAt: DateTime!
    "The number of users allowed by the license."
    userCount: Int!
    "Whether license restricts number of users or not."
    userCountRestricted: Boolean!
    "All license features."
    features: [LicenseFeature!]!
}

"Options for a line chart data series"
input LineChartDataSeriesOptionsInput {
    "The label for the data series."
    label: String
    "The line color for the data series."
    lineColor: String
}

"View presentation for a single insight line chart data series"
type LineChartDataSeriesPresentation {
    "Unique ID for the series."
    seriesId: String!
    "The label for the series."
    label: String!
    "The color for the series."
    color: String!
}

"View presentation for a line chart insight"
type LineChartInsightViewPresentation {
    "The title for the line chart."
    title: String!
    "The presentation options for the line chart."
    seriesPresentation: [LineChartDataSeriesPresentation!]!
}

"Options for a line chart"
input LineChartOptionsInput {
    "The chart title."
    title: String
}

"Input for a line chart search insight data series."
input LineChartSearchInsightDataSeriesInput {
    "Unique ID for the series. Omit this field if it's a new series."
    seriesId: String
    "The query string."
    query: String!
    "Options for this line chart data series."
    options: LineChartDataSeriesOptionsInput!
    "The scope of repositories. The repository scope can be provided at the LineChartSearchInsightInput level.\nIf scope is provided here will take priority of any other scope provide at a higher level in the input."
    repositoryScope: RepositoryScopeInput
    "The scope of time. This time scope can also be provided at the LineChartSearchInsightInput level.\nIf the scope is provided here it will take priority over any other scope provided at a higher level in the input."
    timeScope: TimeScopeInput
    "Whether or not to generate the timeseries results from the query capture groups. Defaults to false if not provided."
    generatedFromCaptureGroups: Boolean
    "The field to group results by. (For compute powered insights only.) This field is experimental and should be considered unstable in the API."
    groupBy: GroupByField
}

"Input for a line chart search insight."
input LineChartSearchInsightInput {
    "The list of data series to create (or add) to this insight."
    dataSeries: [LineChartSearchInsightDataSeriesInput!]!
    "The scope of repositories for the insight. If provided here it will apply to all series unless overwritten."
    repositoryScope: RepositoryScopeInput
    "The scope of time for the insight view. If provided here it will apply to all series unless overwritten."
    timeScope: TimeScopeInput
    "The options for this line chart."
    options: LineChartOptionsInput!
    "The dashboard IDs to associate this insight with once created."
    dashboards: [ID!]
    "The default values for filters and aggregates for this line chart."
    viewControls: InsightViewControlsInput
}

"A line match."
type LineMatch {
    "The preview."
    preview: String!
    "The line number. 0-based. The first line will have lineNumber 0. Note: A\nUI will normally display line numbers 1-based."
    lineNumber: Int!
    "Tuples of [offset, length] measured in characters (not bytes)."
    offsetAndLengths: [[Int!]!]!
    "Whether or not the limit was hit."
    limitHit: Boolean! @deprecated(reason: "will always be false")
}

"LineRange is a span within a line."
type LineRange {
    "The line."
    line: Int!
    "The character."
    character: Int!
    "The length."
    length: Int!
}

"A location inside a resource (in a repository at a specific commit)."
type Location {
    "The file that this location refers to."
    resource: CodeIntelGitBlob!
    "The range inside the file that this location refers to."
    range: Range
    "The URL to this location (using the input revision specifier, which may not be immutable)."
    url: String!
    "The canonical URL to this location (using an immutable revision specifier)."
    canonicalURL: String!
}

"A list of locations within a file."
type LocationConnection {
    "A list of locations within a file."
    nodes: [Location!]!
    "Pagination information."
    pageInfo: PageInfo!
}

"An object representing a markdown string."
type Markdown {
    "The raw markdown string."
    text: String!
    "HTML for the rendered markdown string, or null if there is no HTML representation provided.\nIf specified, clients should render this directly."
    html: String!
}

"Markdown block renders the Markdown formatted input string into HTML."
type MarkdownBlock {
    "ID of the block."
    id: String!
    "Markdown formatted input string."
    markdownInput: String!
}

"Describes options for rendering Markdown."
input MarkdownOptions {
    "A dummy null value (empty input types are not allowed yet)."
    alwaysNil: String
}

"Message to or from the LLM"
input Message {
    "Speaker of the message (human\/assistant)"
    speaker: SpeakerType!
    "Text content of the message"
    text: String!
}

"Information and status about the mirroring of a repository. In this case, the remote source repository\nis external to Sourcegraph and the mirror is maintained by the Sourcegraph site (not the other way\naround)."
type MirrorRepositoryInfo {
    "The URL of the remote source repository."
    remoteURL: String!
    "Whether the clone of the repository has begun but not yet completed."
    cloneInProgress: Boolean!
    "A single line of text that contains progress information for the running clone command.\nThe format of the progress text is not specified.\nIt is intended to be displayed directly to a user.\ne.g.\n\"Receiving objects:  95% (2041\/2148), 292.01 KiB | 515.00 KiB\/s\"\n\"Resolving deltas:   9% (117\/1263)\""
    cloneProgress: String
    "Whether the repository has ever been successfully cloned."
    cloned: Boolean!
    "Whether the repository is currently corrupt."
    isCorrupted: Boolean!
    "A Log of the corruption events that have been detected on this repository. Only 10 events are kept and the events\nare ordered from most recent to least."
    corruptionLogs: [RepoCorruptionLog!]!
    "When the repository was last successfully updated from the remote source repository."
    updatedAt: DateTime
    "When the repository is next scheduled to be updated from the remote source repository."
    nextSyncAt: DateTime
    "The state of this repository in the update schedule."
    updateSchedule: UpdateSchedule
    "The state of this repository in the update queue."
    updateQueue: UpdateQueue
    "The last error message, if any, returned when fetching or cloning the repo"
    lastError: String
    "The output of the most recent repo sync job"
    lastSyncOutput: String
    "The byte size of the repo."
    byteSize: BigInt!
    "The gitserver shard on which the repository is or will be cloned.\nOnly site admins can access this field."
    shard: String
}

"A code monitor with one trigger and possibly many actions."
type Monitor implements Node {
    "The code monitor's unique ID."
    id: ID!
    "The user who created the code monitor."
    createdBy: User!
    "The time at which the code monitor was created."
    createdAt: DateTime!
    "A meaningful description of the code monitor."
    description: String!
    "Owners can edit the code monitor."
    owner: Namespace!
    "Whether the code monitor is currently enabled."
    enabled: Boolean!
    "Triggers trigger actions. There can only be one trigger per monitor."
    trigger: MonitorTrigger!
    "One or more actions that are triggered by the trigger."
    actions("Returns the first n actions from the list." first: Int = 50 "Opaque pagination cursor." after: String): MonitorActionConnection!
}

"Supported actions for code monitors."
union MonitorAction = MonitorEmail | MonitorWebhook | MonitorSlackWebhook

"A list of actions."
type MonitorActionConnection {
    "A list of actions."
    nodes: [MonitorAction!]!
    "The total number of actions in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"A list of events."
type MonitorActionEmailRecipientsConnection {
    "A list of recipients."
    nodes: [Namespace!]!
    "The total number of recipients in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"An event documents the result of a trigger or an execution of an action."
type MonitorActionEvent implements Node {
    "The unique id of an event."
    id: ID!
    "The status of an event."
    status: EventStatus!
    "A message with details regarding the status of the event."
    message: String
    "The time and date of the event."
    timestamp: DateTime!
}

"A list of events."
type MonitorActionEventConnection {
    "A list of events."
    nodes: [MonitorActionEvent!]!
    "The total number of events in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"The input required to create an action."
input MonitorActionInput {
    "An email action."
    email: MonitorEmailInput
    "A webhook action."
    webhook: MonitorWebhookInput
    "A Slack webhook action."
    slackWebhook: MonitorSlackWebhookInput
}

"A list of code monitors"
type MonitorConnection {
    "A list of monitors."
    nodes: [Monitor!]!
    "The total number of monitors in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"The input required to edit an action."
input MonitorEditActionInput {
    "An email action."
    email: MonitorEditEmailInput
    "A webhook action."
    webhook: MonitorEditWebhookInput
    "A Slack webhook action."
    slackWebhook: MonitorEditSlackWebhookInput
}

"The input required to edit an email action."
input MonitorEditEmailInput {
    "The id of an email action. If unset, this will\nbe treated as a new email action and be created\nrather than updated."
    id: ID
    "The desired state after the update."
    update: MonitorEmailInput!
}

"The input required to edit a code monitor."
input MonitorEditInput {
    "The id of the monitor."
    id: ID!
    "The desired state after the udpate."
    update: MonitorInput!
}

"The input required to edit a Slack webhook action."
input MonitorEditSlackWebhookInput {
    "The id of a Slack webhook action. If unset, this will\nbe treated as a new Slack webhook action and be created\nrather than updated."
    id: ID
    "The desired state after the update."
    update: MonitorSlackWebhookInput!
}

"The input required to edit a trigger."
input MonitorEditTriggerInput {
    "The id of the Trigger."
    id: ID!
    "The desired state after the udpate."
    update: MonitorTriggerInput!
}

"The input required to edit a webhook action."
input MonitorEditWebhookInput {
    "The id of a webhook action. If unset, this will\nbe treated as a new webhook action and be created\nrather than updated."
    id: ID
    "The desired state after the update."
    update: MonitorWebhookInput!
}

"Email is one of the supported actions of code monitors."
type MonitorEmail implements Node {
    "The unique id of an email action."
    id: ID!
    "Whether the email action is enabled or not."
    enabled: Boolean!
    "Whether to include the result contents in the email message"
    includeResults: Boolean!
    "The priority of the email action."
    priority: MonitorEmailPriority!
    "Use header to automatically approve the message in a read-only or moderated mailing list."
    header: String!
    "A list of recipients of the email."
    recipients("Returns the first n recipients from the list." first: Int = 50 "Opaque pagination cursor." after: String): MonitorActionEmailRecipientsConnection!
    "A list of events."
    events("Returns the first n events from the list." first: Int = 50 "Opaque pagination cursor." after: String): MonitorActionEventConnection!
}

"The input required to create an email action."
input MonitorEmailInput {
    "Whether the email action is enabled or not."
    enabled: Boolean!
    "Whether to include the result contents in the email message"
    includeResults: Boolean!
    "The priority of the email."
    priority: MonitorEmailPriority!
    "A list of users or orgs which will receive the email."
    recipients: [ID!]!
    "Use header to automatically approve the message in a read-only or moderated mailing list."
    header: String!
}

"The priority of an email action."
enum MonitorEmailPriority {
    NORMAL
    CRITICAL
}

"The input required to create a code monitor."
input MonitorInput {
    "The namespace represents the owner of the code monitor.\nOwners can either be users or organizations."
    namespace: ID!
    "A meaningful description of the code monitor."
    description: String!
    "Whether the code monitor is enabled or not."
    enabled: Boolean!
}

"A query that can serve as a trigger for code monitors."
type MonitorQuery implements Node {
    "The unique id of a trigger query."
    id: ID!
    "A query."
    query: String!
    "A list of events."
    events("Returns the first n events from the list." first: Int = 50 "Opaque pagination cursor." after: String): MonitorTriggerEventConnection!
}

"SlackWebhook is one of the supported actions of code monitors."
type MonitorSlackWebhook implements Node {
    "The unique id of an Slack webhook action."
    id: ID!
    "Whether the Slack webhook action is enabled or not."
    enabled: Boolean!
    "Whether to include the result contents in Slack notification message."
    includeResults: Boolean!
    "The endpoint the Slack webhook event will be sent to"
    url: String!
    "A list of events."
    events("Returns the first n events from the list." first: Int = 50 "Opaque pagination cursor." after: String): MonitorActionEventConnection!
}

"The input required to create a Slack webhook action."
input MonitorSlackWebhookInput {
    "Whether the Slack webhook action is enabled or not."
    enabled: Boolean!
    "Whether to include the result contents in Slack notification message."
    includeResults: Boolean!
    "The URL that will receive a payload when the action is triggered."
    url: String!
}

"Supported triggers for code monitors."
union MonitorTrigger = MonitorQuery

"A trigger event is an event together with a list of associated actions."
type MonitorTriggerEvent implements Node {
    "The unique id of an event."
    id: ID!
    "The status of an event."
    status: EventStatus!
    "A message with details regarding the status of the event."
    message: String
    "The time and date of the event."
    timestamp: DateTime!
    "The query (with after filter) that provides an approximation of the\nset of results associated with this trigger run. Will always be empty\nwhile status is PENDING."
    query: String
    "The number of results recorded for this trigger run. Will always be\nzero until status is SUCCESS."
    resultCount: Int!
    "A list of actions."
    actions("Returns the first n events from the list." first: Int = 50 "Opaque pagination cursor." after: String): MonitorActionConnection!
}

"A list of trigger events."
type MonitorTriggerEventConnection {
    "A list of events."
    nodes: [MonitorTriggerEvent!]!
    "The total number of events in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"The input required to create a trigger."
input MonitorTriggerInput {
    "The query string."
    query: String!
}

"Webhook is one of the supported actions of code monitors."
type MonitorWebhook implements Node {
    "The unique id of a webhook action."
    id: ID!
    "Whether the webhook action is enabled or not."
    enabled: Boolean!
    "Whether to include the result contents in webhook payload."
    includeResults: Boolean!
    "The endpoint the webhook event will be sent to"
    url: String!
    "A list of events."
    events("Returns the first n events from the list." first: Int = 50 "Opaque pagination cursor." after: String): MonitorActionEventConnection!
}

"The input required to create a webhook action."
input MonitorWebhookInput {
    "Whether the webhook action is enabled or not."
    enabled: Boolean!
    "Whether to include the result contents in webhook payload."
    includeResults: Boolean!
    "The URL that will receive a payload when the action is triggered."
    url: String!
}

"A high-level monitoring alert, for details see https:\/\/docs.sourcegraph.com\/admin\/observability\/metrics#high-level-alerting-metrics"
type MonitoringAlert {
    "End time of this event, which describes the past 12h of recorded data."
    timestamp: DateTime!
    "Name of alert that the service fired."
    name: String!
    "Name of the service that fired the alert."
    serviceName: String!
    "Owner of the fired alert."
    owner: String!
    "Average percentage of time (between [0, 1]) that the event was firing over the 12h of recorded data. e.g.\n1.0 if it was firing 100% of the time on average during that 12h window, 0.5 if it was firing 50% of the\ntime on average, etc."
    average: Float!
}

"Monitoring overview."
type MonitoringStatistics {
    "Alerts fired in this time span."
    alerts: [MonitoringAlert!]! @deprecated(reason: "No longer supported, and will no longer return data - query will be removed after Sourcegraph 4.5")
}

"A mutation."
type Mutation {
    "INTERNAL ONLY: Sets the value of versions.auto_upgrade in the frontend db.\nDetermines behavior of multiversion upgrades.\n\nOnly site admins may perform this mutation."
    setAutoUpgrade(enable: Boolean!): EmptyResponse!
    "Updates the user profile information for the user with the given ID.\n\nOnly the user and site admins may perform this mutation."
    updateUser(user: ID! username: String displayName: String avatarURL: String): User!
    "Creates an organization. The caller is added as a member of the newly created organization.\n\nOnly authenticated users may perform this mutation."
    createOrganization(name: String! displayName: String statsID: ID): Org!
    "Updates an organization.\n\nOnly site admins and any member of the organization may perform this mutation."
    updateOrganization(id: ID! displayName: String): Org!
    "Soft deletes an organization.\n\nOnly site admins may perform this mutation."
    deleteOrganization(organization: ID!): EmptyResponse
    "Creates a webhook for the specified code host. Only site admins may perform this mutation."
    createWebhook(name: String! codeHostKind: String! codeHostURN: String! secret: String): Webhook!
    "Deletes a webhook by given ID. Only site admins may perform this mutation."
    deleteWebhook(id: ID!): EmptyResponse!
    "Updates a webhook with given ID. Null values aren't updated."
    updateWebhook(id: ID! name: String codeHostKind: String codeHostURN: String secret: String): Webhook!
    "Adds a external service. Only site admins may perform this mutation."
    addExternalService(input: AddExternalServiceInput!): ExternalService!
    "Updates a external service. Only site admins may perform this mutation."
    updateExternalService(input: UpdateExternalServiceInput!): ExternalService!
    "Delete an external service. Only site admins may perform this mutation."
    deleteExternalService(externalService: ID! async: Boolean = false): EmptyResponse!
    "Excludes a repo from external services configs. Only site admins may perform this mutation."
    excludeRepoFromExternalServices(externalServices: [ID!]! repo: ID!): EmptyResponse!
    "Tests the connection to a mirror repository's original source repository. This is an\nexpensive and slow operation, so it should only be used for interactive diagnostics.\n\nOnly site admins may perform this mutation."
    checkMirrorRepositoryConnection("The ID of the existing repository whose mirror to check." repository: ID "The name of a repository whose mirror to check. If the name is provided, the repository need not be added\nto the site (but the site configuration must define a code host that knows how to handle the name)." name: String): CheckMirrorRepositoryConnectionResult!
    "Schedule the mirror repository to be updated from its original source repository. Updating\noccurs automatically, so this should not normally be needed.\n\nOnly site admins may perform this mutation."
    updateMirrorRepository("The mirror repository to update." repository: ID!): EmptyResponse!
    "Force Zoekt to reindex the repository right now. Reindexing occurs\nautomatically, so this should not normally be needed."
    reindexRepository("The repository to index" repository: ID!): EmptyResponse!
    "Creates a new user account.\n\nOnly site admins may perform this mutation."
    createUser("The new user's username." username: String! "The new user's optional email address. If given, it must be verified by the user." email: String "Whether or not to mark the provided email address as verified. If unset or set to\ntrue, then the email address is immediately marked as verified - otherwise, the\nemail may be marked as unverified if SMTP and password resets are enabled." verifiedEmail: Boolean): CreateUserResult!
    "Randomize a user's password so that they need to reset it before they can sign in again.\n\nOnly site admins may perform this mutation."
    randomizeUserPassword(user: ID!): RandomizeUserPasswordResult!
    "Adds an email address to the user's account. The email address will be marked as unverified until the user\nhas followed the email verification process.\n\nOnly the user and site admins may perform this mutation."
    addUserEmail(user: ID! email: String!): EmptyResponse!
    "Removes an email address from the user's account.\n\nOnly the user and site admins may perform this mutation."
    removeUserEmail(user: ID! email: String!): EmptyResponse!
    "Set an email address as the user's primary.\n\nOnly the user and site admins may perform this mutation."
    setUserEmailPrimary(user: ID! email: String!): EmptyResponse!
    "Manually set the verification status of a user's email, without going through the normal verification process\n(of clicking on a link in the email with a verification code).\n\nOnly site admins may perform this mutation."
    setUserEmailVerified(user: ID! email: String! verified: Boolean!): EmptyResponse!
    "Resend a verification email, no op if the email is already verified.\n\nOnly the user and site admins may perform this mutation."
    resendVerificationEmail(user: ID! email: String!): EmptyResponse!
    "Deletes a user account. Only site admins may perform this mutation.\n\nIf hard == true, a hard delete is performed. By default, deletes are\n'soft deletes' and could theoretically be undone with manual DB commands.\nIf a hard delete is performed, the data is truly removed from the\ndatabase and deletion can NEVER be undone.\n\nData that is deleted as part of this operation:\n\n- All user data (access tokens, email addresses, external account info, survey responses, etc)\n- Organization membership information (which organizations the user is a part of, any invitations created by or targeting the user).\n- User, Organization, or Global settings authored by the user."
    deleteUser(user: ID! hard: Boolean): EmptyResponse
    "Bulk \"deleteUser\" action."
    deleteUsers(users: [ID!]! hard: Boolean): EmptyResponse
    "Bulk \"recoverUser\" action."
    recoverUsers(userIDs: [ID!]!): EmptyResponse
    "Updates the current user's password. The oldPassword arg must match the user's current password."
    updatePassword(oldPassword: String! newPassword: String!): EmptyResponse
    "Creates a password for the current user. It is only permitted if the user does not have a password."
    createPassword(newPassword: String!): EmptyResponse
    "Sets the user to accept the site's Terms of Service and Privacy Policy.\nIf the ID is omitted, the current user is assumed.\n\nOnly the user or site admins may perform this mutation."
    setTosAccepted(userID: ID): EmptyResponse!
    "Current user opt in\/out from being searchable in the users picker."
    setSearchable(searchable: Boolean!): EmptyResponse!
    "Sets the user to have completed the post-signup flow.\nIf the ID is omitted, the current user is assumed.\n\nOnly the user or site admins may perform this mutation."
    setCompletedPostSignup(userID: ID): EmptyResponse!
    "Creates an access token that grants the privileges of the specified user (referred to as the access token's\n\"subject\" user after token creation). The result is the access token value, which the caller is responsible\nfor storing (it is not accessible by Sourcegraph after creation).\n\nThe supported scopes are:\n\n- \"user:all\": Full control of all resources accessible to the user account.\n- \"site-admin:sudo\": Ability to perform any action as any other user. (Only site admins may create tokens\n  with this scope.)\n\nOnly the user or site admins may perform this mutation."
    createAccessToken(user: ID! scopes: [String!]! note: String!): CreateAccessTokenResult!
    "Deletes and immediately revokes the specified access token, specified by either its ID or by the token\nitself.\n\nOnly site admins or the user who owns the token may perform this mutation."
    deleteAccessToken(byID: ID byToken: String): EmptyResponse!
    "Deletes the association between an external account and its Sourcegraph user. It does NOT delete the external\naccount on the external service where it resides.\n\nOnly site admins or the user who is associated with the external account may perform this mutation."
    deleteExternalAccount(externalAccount: ID!): EmptyResponse!
    "Adds an external account to the authenticated user's account. The service type and service ID\nmust correspond to a valid auth provider on the site. The account details must be a stringified\nJSON object that contains valid credentials for the provided service type."
    addExternalAccount(serviceType: String! serviceID: String! accountDetails: String!): EmptyResponse!
    "Sends an invitation to join Sourcegraph to the given email address.\n\nReturns instantly regardless of whether or not an invitation email was actually sent. For example, the email\nmay fail to send if there is a typo or it is invalid, or Sourcegraph may refuse to send it due to spam concerns\nor if the user has been invited too recently."
    inviteEmailToSourcegraph(email: String!): EmptyResponse!
    "Invite the user with the given username to join the organization. The invited user account must already\nexist.\n\nOnly site admins and any organization member may perform this mutation."
    inviteUserToOrganization(organization: ID! username: String email: String): InviteUserToOrganizationResult!
    "Accept or reject an existing organization invitation.\n\nOnly the recipient of the invitation may perform this mutation."
    respondToOrganizationInvitation("The organization invitation." organizationInvitation: ID! "The response to the invitation." responseType: OrganizationInvitationResponseType!): EmptyResponse!
    "Resend the notification about an organization invitation to the recipient.\n\nOnly site admins and any member of the organization may perform this mutation."
    resendOrganizationInvitationNotification("The organization invitation." organizationInvitation: ID!): EmptyResponse!
    "Revoke an existing organization invitation.\n\nIf the invitation has been accepted or rejected, it may no longer be revoked. After an\ninvitation is revoked, the recipient may not accept or reject it. Both cases yield an error.\n\nOnly site admins and any member of the organization may perform this mutation."
    revokeOrganizationInvitation("The organization invitation." organizationInvitation: ID!): EmptyResponse!
    "Immediately add a user as a member to the organization, without sending an invitation email.\n\nOnly site admins may perform this mutation. Organization members may use the inviteUserToOrganization\nmutation to invite users."
    addUserToOrganization(organization: ID! username: String!): EmptyResponse!
    "Removes a user as a member from an organization.\n\nOnly site admins and any member of the organization may perform this mutation."
    removeUserFromOrganization(user: ID! organization: ID!): EmptyResponse
    "Adds a Phabricator repository to Sourcegraph."
    addPhabricatorRepo("The callsign, for example \"MUX\"." callsign: String! "The name, for example \"github.com\/gorilla\/mux\"." name: String "An alias for name. DEPRECATED: use name instead." uri: String "The URL to the phabricator instance (e.g. http:\/\/phabricator.sgdev.org)." url: String!): EmptyResponse
    "Resolves a revision for a given diff from Phabricator."
    resolvePhabricatorDiff("The name of the repository that the diff is based on." repoName: String! "The ID of the diff on Phabricator." diffID: ID! "The base revision this diff is based on." baseRev: String! "The raw contents of the diff from Phabricator.\nRequired if Sourcegraph doesn't have a Conduit API token." patch: String "The description of the diff. This will be used as the commit message." description: String "The name of author of the diff." authorName: String "The author's email." authorEmail: String "When the diff was created." date: String): GitCommit
    "Logs a user event. No longer used, only here for backwards compatibility with IDE and browser extensions."
    logUserEvent(event: UserEvent! userCookieID: String!): EmptyResponse @deprecated(reason: "use logEvent instead")
    "Logs an event."
    logEvent("The name of the event." event: String! "The randomly generated unique user ID stored in a browser cookie." userCookieID: String! "The first sourcegraph URL visited by the user, stored in a browser cookie." firstSourceURL: String "The last sourcegraph URL visited by the user, stored in a browser cookie." lastSourceURL: String "The URL when the event was logged." url: String! "The source of the event." source: EventSource! "An optional cohort ID to identify the user as part of a specific A\/B test.\nThe cohort ID is expected to be a date in the form YYYY-MM-DD" cohortID: String "An optional referrer parameter for the user's current session.\nOnly captured and stored on Sourcegraph Cloud." referrer: String "The original referrer for a user" originalReferrer: String "The session referrer for a user" sessionReferrer: String "The sessions first url for a user" sessionFirstURL: String "Device session ID to identify the user's session for analytics." deviceSessionID: String "The additional argument information." argument: String "Public argument information. PRIVACY: Do NOT include any potentially private information in this field.\nThese properties get sent to our analytics tools for Cloud, so must not include private information,\nsuch as search queries or repository names." publicArgument: String "Device ID used for Amplitude analytics. Used on Sourcegraph Cloud only." deviceID: String "Event ID used to deduplicate events that occur simultaneously in Amplitude analytics.\nSee https:\/\/developers.amplitude.com\/docs\/http-api-v2#optional-keys. Used on Sourcegraph Cloud only." eventID: Int "Insert ID used to deduplicate events that re-occur in the event of retries or\nbackfills in Amplitude analytics. See https:\/\/developers.amplitude.com\/docs\/http-api-v2#optional-keys.\nUsed on Sourcegraph Cloud only." insertID: String "The client that this event is being sent from." client: String "The product category for the event, used for billing purposes." billingProductCategory: String "The billing ID for the event, used for tagging user events for billing aggregation purposes." billingEventID: String "The site ID that the client was connected to when the event was logged." connectedSiteID: String "The connected site's license key, hashed using sha256. Used for uniquely identifying the site." hashedLicenseKey: String): EmptyResponse
    "Logs a batch of events."
    logEvents(events: [Event!]): EmptyResponse
    "All mutations that update settings (global, organization, and user settings) are under this field.\n\nOnly the settings subject whose settings are being mutated (and site admins) may perform this mutation.\n\nThis mutation only affects global, organization, and user settings, not site configuration. For site\nconfiguration (which is a separate set of configuration properties from global\/organization\/user settings),\nuse updateSiteConfiguration."
    settingsMutation(input: SettingsMutationGroupInput!): SettingsMutation
    "DEPRECATED: Use settingsMutation instead. This field is a deprecated alias for settingsMutation and will be\nremoved in a future release."
    configurationMutation(input: SettingsMutationGroupInput!): SettingsMutation @deprecated(reason: "use settingsMutation instead")
    "Updates the site configuration. Returns whether or not a restart is required for the update to be applied.\n\nOnly site admins may perform this mutation."
    updateSiteConfiguration("The last ID of the site configuration that is known by the client, to\nprevent race conditions. An error will be returned if someone else\nhas already written a new update." lastID: Int! "A JSON object containing the entire site configuration. The previous site configuration will be replaced\nwith this new value." input: String!): Boolean!
    "Sets whether the user with the specified user ID is a site admin.\n\nOnly site admins may perform this mutation."
    setUserIsSiteAdmin(userID: ID! siteAdmin: Boolean!): EmptyResponse
    "Invalidates all sessions belonging to a user.\n\nOnly site admins may perform this mutation."
    invalidateSessionsByID(userID: ID!): EmptyResponse
    "Bulk \"invalidateSessionsByID\" action."
    invalidateSessionsByIDs(userIDs: [ID!]!): EmptyResponse
    "Reloads the site by restarting the server. This is not supported for all deployment\ntypes. This may cause downtime.\n\nOnly site admins may perform this mutation."
    reloadSite: EmptyResponse
    "Submits a user satisfaction (NPS) survey."
    submitSurvey(input: SurveySubmissionInput!): EmptyResponse
    "Submits happiness feedback."
    submitHappinessFeedback(input: HappinessFeedbackSubmissionInput!): EmptyResponse
    "Creates a saved search."
    createSavedSearch(description: String! query: String! notifyOwner: Boolean! notifySlack: Boolean! orgID: ID userID: ID): SavedSearch!
    "Updates a saved search"
    updateSavedSearch(id: ID! description: String! query: String! notifyOwner: Boolean! notifySlack: Boolean! orgID: ID userID: ID): SavedSearch!
    "Deletes a saved search"
    deleteSavedSearch(id: ID!): EmptyResponse
    "OBSERVABILITY\n\nSet the status of a test alert of the specified parameters - useful for validating\n'observability.alerts' configuration. Alerts may take up to a minute to fire."
    triggerObservabilityTestAlert("Level of alert to test - either warning or critical." level: String!): EmptyResponse!
    "Updates an out-of-band migration to run in a particular direction.\n\nApplied in the forward direction, an out-of-band migration migrates data into a format that\nis readable by newer Sourcegraph instances. This may be destructive or non-destructive process,\ndepending on the nature and implementation of the migration.\n\nApplied in the reverse direction, an out-of-band migration ensures that data is moved back into\na format that is readable by the previous Sourcegraph instance. Recently introduced migrations\nshould be applied in reverse prior to downgrading the instance."
    setMigrationDirection(id: ID! applyReverse: Boolean!): EmptyResponse!
    "EXPERIMENTAL: Create a new feature flag"
    createFeatureFlag("The name of the feature flag" name: String! "The value of the feature flag. Only set if the new feature flag\nwill be a concrete boolean flag. Mutually exclusive with rolloutBasisPoints." value: Boolean "The ratio of users the feature flag will apply to, expressed in basis points (0.01%).\nOnly set if the new feature flag will be a rollout flag.\nMutually exclusive with value." rolloutBasisPoints: Int): FeatureFlag!
    "EXPERIMENTAL: Delete a feature flag"
    deleteFeatureFlag("The name of the feature flag" name: String!): EmptyResponse!
    "EXPERIMENTAL: Update a feature flag"
    updateFeatureFlag("The name of the feature flag" name: String! "The value of the feature flag. Only set if the new feature flag\nwill be a concrete boolean flag. Mutually exclusive with rollout." value: Boolean "The ratio of users the feature flag will apply to, expressed in basis points (0.01%).\nMutually exclusive with value." rolloutBasisPoints: Int): FeatureFlag!
    "EXPERIMENTAL: Create a new feature flag override for the given org or user"
    createFeatureFlagOverride("The namespace for this feature flag. Must be either a user ID or an org ID." namespace: ID! "The name of the feature flag this override applies to" flagName: String! "The overridden value" value: Boolean!): FeatureFlagOverride!
    "Delete a feature flag override"
    deleteFeatureFlagOverride("The ID of the feature flag override to delete" id: ID!): EmptyResponse!
    "Update a feature flag override"
    updateFeatureFlagOverride("The ID of the feature flag override to update" id: ID! "The updated value of the feature flag override" value: Boolean!): FeatureFlagOverride!
    "Overwrites and saves the temporary settings for the current user.\nIf temporary settings for the user do not exist, they are created."
    overwriteTemporarySettings("The new temporary settings for the current user, as a JSON string." contents: String!): EmptyResponse!
    "Merges the given settings edit with the current temporary settings for the current user.\nKeys in the given edit take priority over key in the temporary settings. The merge is\nnot recursive.\nIf temporary settings for the user do not exist, they are created."
    editTemporarySettings("The settings to merge with the current temporary settings for the current user, as a JSON string." settingsToEdit: String!): EmptyResponse!
    "Sends an email for testing Sourcegraph's email configuration.\n\nOnly administrators can use this API."
    sendTestEmail(to: String!): String!
    "Enqueues a sync for the external service. It will be picked up in the background.\n\nSite-admin or owner of the external service only."
    syncExternalService(id: ID!): EmptyResponse!
    "Cancels an external service sync job. Must be in queued or processing state.\n\nSite-admin or owner of the external service only."
    cancelExternalServiceSync(id: ID!): EmptyResponse!
    "Associate a new key-value pair with a repo."
    addRepoKeyValuePair(repo: ID! key: String! value: String): EmptyResponse! @deprecated(reason: "Use addRepoMetadata instead. This field is a deprecated and will be removed in a future release.")
    "Associate a new key-value pair metadata with a repo."
    addRepoMetadata(repo: ID! key: String! value: String): EmptyResponse!
    "Update a key-value pair associated with a repo."
    updateRepoKeyValuePair(repo: ID! key: String! value: String): EmptyResponse! @deprecated(reason: "Use updateRepoMetadata instead. This field is a deprecated and will be removed in a future release.")
    "Update metadata value for a given metadata key for associated with a repo."
    updateRepoMetadata(repo: ID! key: String! value: String): EmptyResponse!
    "Delete a key-value pair associated with a repo."
    deleteRepoKeyValuePair(repo: ID! key: String!): EmptyResponse! @deprecated(reason: "Use deleteRepoMetadata instead. This field is a deprecated and will be removed in a future release.")
    "Delete a key-value pair metadata associated with a repo."
    deleteRepoMetadata(repo: ID! key: String!): EmptyResponse!
    "INTERNAL ONLY: Reclone a repository from the gitserver. This involves deleting\nthe file on disk, marking it as not-cloned in the database, and then initiating\na repo clone."
    recloneRepository(repo: ID!): EmptyResponse!
    "INTERNAL ONLY: Delete a repository from the gitserver. This involves deleting\nthe file on disk, and marking it as not-cloned in the database."
    deleteRepositoryFromDisk(repo: ID!): EmptyResponse!
    "Create a new package repo reference filter."
    addPackageRepoFilter("Whether the matcher should be for allowlisting or blocklisting." behaviour: PackageMatchBehaviour! "The ecosystem of the package repo reference this matcher should apply to.\nMaps to the external service whos config would be updated when used in the\nset query." kind: PackageRepoReferenceKind! "The package repo reference matcher to persist." filter: PackageVersionOrNameFilterInput!): PackageFilter!
    "Updates a package repo reference filter."
    updatePackageRepoFilter("The ID of the package repo reference filter to update." id: ID! behaviour: PackageMatchBehaviour! "The ecosystem of the package repo reference this matcher should apply to.\nMaps to the external service whos config would be updated when used in the\nset query." kind: PackageRepoReferenceKind! filter: PackageVersionOrNameFilterInput!): EmptyResponse!
    "Deletes a package repo reference filter."
    deletePackageRepoFilter(id: ID!): EmptyResponse!
    "Sets the completions requests quota for the user per day. Quota: Null means\nuse the default quota."
    setUserCompletionsQuota(user: ID! quota: Int): User!
    "Sets the code completions requests quota for the user per day. Quota: Null means\nuse the default quota."
    setUserCodeCompletionsQuota(user: ID! quota: Int): User!
    "Submits a post-signup user survey about intended Cody usage."
    submitCodySurvey(isForWork: Boolean! isForPersonal: Boolean!): EmptyResponse!
    "Create a new executor secret.\nSee argument descriptions for more details."
    createExecutorSecret("The scope for which the secret is usable." scope: ExecutorSecretScope! "The key under which the secret is known. For executions, this is the name\nof the environment variable this secret will be accessible under.\nIt is therefore advised that key only contains uppercase letters, numbers\nand underscores." key: String! "The secret value." value: String! "The namespace this secret is for. If not set, a global secret is created\nthat is accessible by all users.\nCreating a global secret requires site-admin permissions.\nCreating a namespaced secret requires write-access to the namespace." namespace: ID): ExecutorSecret!
    "Update the value of an existing executor secret."
    updateExecutorSecret("The scope of the secret." scope: ExecutorSecretScope! "The identifier of the secret that shall be updated." id: ID! "The new secret value." value: String!): ExecutorSecret!
    "Deletes the given executor secret."
    deleteExecutorSecret("The scope of the secret." scope: ExecutorSecretScope! "The identifier of the secret that shall be deleted." id: ID!): EmptyResponse
    "Creates a team. The name must be unique, display name can be used to set a custom\ndisplay value for the team inside Sourcegraph.\n\nIf readonly is true, the Sourcegraph UI will show a warning banner that this team\nis managed externally, and it can only be modified by site-admins.\nThis is to prevent state drift from external systems that ingest team information into Sourcegraph.\nReadonly can only be set by site-admins.\n\nEither parentTeam XOR parentTeamName can be specified to make the team a child\nteam of the given parent. Only members of the parent team or site-admis can create\na child team."
    createTeam(name: String! displayName: String readonly: Boolean = false parentTeam: ID parentTeamName: String): Team!
    "Update an existing team. ID or Name must be specified, but not both.\n\nTo unset the display name, pass an empty string. Null will make it ignore updates.\n\nEither parentTeam XOR parentTeamName XOR makeRoot can be specified to make the team a child\nteam of the given parent or conversely to make a team a root team (with no parent team).\nThe user has to be a team-member of both the child and parent team for that, and\nneither can be read-only. Site-admin can modify all teams without constraints."
    updateTeam(id: ID name: String displayName: String parentTeam: ID parentTeamName: String makeRoot: Boolean): Team!
    "Delete team deletes a team. ID or Name must be specified, but not both.\nMust be team-member to delete. If the team is marked as read-only, must be site-admin."
    deleteTeam(id: ID name: String): EmptyResponse
    "Add a list of team members to an existing team.\nPeople that already are part of the team are ignored.\n\nEither team XOR teamName can be specified to specify the team.\nMust be team member to add new team members, or site-admin.\n\nFor now, members can only be the IDs of User entities in Sourcegraph.\nLater, we will expand this to allow Persons as well.\n\nIf skipUnmatchedMembers is true, members that are not matched to a user are skipped."
    addTeamMembers(team: ID teamName: String members: [TeamMemberInput!]! skipUnmatchedMembers: Boolean = false): Team!
    "This is a convenience method to forcefully overwrite the full set of members\nof a team. This is handy to sync external state without diffing the current\nmembers vs the desired set of members.\n\nEither team XOR teamName can be specified to specify the team.\nMust be team member to modify team members, or site-admin.\n\nFor now, members can only be the IDs of User entities in Sourcegraph.\nLater, we will expand this to allow Persons as well.\n\nIf skipUnmatchedMembers is true, members that are not matched to a user are skipped."
    setTeamMembers(team: ID teamName: String members: [TeamMemberInput!]! skipUnmatchedMembers: Boolean = false): Team!
    "This mutation removes team membership for the given team and set of members.\nMembers that weren't part of the team are ignored.\n\nEither team XOR teamName can be specified to specify the team.\nMust be team member to remove team members, or site-admin.\n\nFor now, members can only be the IDs of User entities in Sourcegraph.\nLater, we will expand this to allow Persons as well.\n\nIf skipUnmatchedMembers is true, members that are not matched to a user are skipped."
    removeTeamMembers(team: ID teamName: String members: [TeamMemberInput!]! skipUnmatchedMembers: Boolean = false): Team!
    "Marks access_request as rejected"
    setAccessRequestStatus(id: ID! status: AccessRequestStatus!): EmptyResponse
    "Creates a new outbound webhook.\n\nOnly site admins have access to this mutation."
    createOutboundWebhook(input: OutboundWebhookCreateInput!): OutboundWebhook!
    "Deletes an outbound webhook.\n\nOnly site admins have access to this mutation."
    deleteOutboundWebhook(id: ID!): EmptyResponse!
    "Updates an outbound webhook.\n\nOnly site admins have access to this mutation."
    updateOutboundWebhook(id: ID! input: OutboundWebhookUpdateInput!): OutboundWebhook!
    "Upload a changeset spec that will be used in a future update to a batch change. The changeset spec\nis stored and can be referenced by its ID in the applyBatchChange mutation. Just uploading the\nchangeset spec does not result in changes to the batch change or any of its changesets; you need\nto call applyBatchChange to use it.\n\nYou can use this mutation to upload large changeset specs (e.g., containing large diffs) in\nindividual HTTP requests. Then, in the eventual applyBatchChange call, you just refer to the\nchangeset specs by their IDs. This lets you avoid problems when updating large batch changes where\na large HTTP request body (e.g., with many large diffs in the changeset specs) would be\nrejected by the web server\/proxy or would be very slow.\n\nThe returned ChangesetSpec is immutable and expires after a certain period of time (if not\nused in a call to applyBatchChange), which can be queried on ChangesetSpec.expiresAt."
    createChangesetSpec("The raw changeset spec (as JSON). See\nhttps:\/\/sourcegraph.com\/github.com\/sourcegraph\/sourcegraph\/-\/blob\/schema\/changeset_spec.schema.json\nfor the JSON Schema that describes the structure of this input." changesetSpec: String!): ChangesetSpec!
    "FOR INTERNAL USE ONLY.\n\nUpload multiple changeset specs that will be used in a future update to a batch change. The changeset specs\nare stored and can be referenced by their ID in the applyBatchChange mutation. Just uploading the\nchangeset specs does not result in changes to the batch change or any of its changesets; you need\nto call applyBatchChange to use it.\n\nThe returned ChangesetSpecs is immutable and expires after a certain period of time (if not\nused in a call to applyBatchChange), which can be queried on ChangesetSpec.expiresAt."
    createChangesetSpecs("The raw changeset specs (as JSON). See\nhttps:\/\/sourcegraph.com\/github.com\/sourcegraph\/sourcegraph\/-\/blob\/schema\/changeset_spec.schema.json\nfor the JSON Schema that describes the structure of this input." changesetSpecs: [String!]!): [ChangesetSpec!]!
    "Enqueue the given changeset for high-priority syncing."
    syncChangeset(changeset: ID!): EmptyResponse!
    "Re-enqueue the changeset for processing by the reconciler. The changeset must be in FAILED state."
    reenqueueChangeset(changeset: ID!): Changeset!
    "Create a batch change from a batch spec and locally computed changeset specs. The newly created\nbatch change is returned.\nIf a batch change in the same namespace with the same name already exists,\nan error with the error code ErrMatchingBatchChangeExists is returned."
    createBatchChange("The batch spec that describes the desired state of the batch change.\nIt must be in COMPLETED state." batchSpec: ID! "If set, these changeset specs will have their UI publication states set\nto the given values.\n\nAn error will be returned if the same changeset spec ID is included\nmore than once in the array, or if a changeset spec ID is included with\na publication state set in its spec." publicationStates: [ChangesetSpecPublicationStateInput!]): BatchChange!
    "Create a batch spec that will be used to create a batch change (with the createBatchChange\nmutation), or to update an existing batch change (with the applyBatchChange mutation).\n\nThe returned BatchSpec is immutable and expires after a certain period of time (if not used\nin a call to applyBatchChange), which can be queried on BatchSpec.expiresAt.\n\nIf batch changes are unlicensed and the number of changesetSpecIDs is higher than what's allowed in\nthe free tier, an error with the error code ErrBatchChangesUnlicensed is returned."
    createBatchSpec("The namespace (either a user or organization). A batch spec can only be applied to (or\nused to create) batch changes in this namespace." namespace: ID! "The batch spec as YAML (or the equivalent JSON). See\nhttps:\/\/sourcegraph.com\/github.com\/sourcegraph\/sourcegraph\/-\/blob\/schema\/batch_spec.schema.json\nfor the JSON Schema that describes the structure of this input." batchSpec: String! "Changeset specs that were locally computed and then uploaded using createChangesetSpec." changesetSpecs: [ID!]!): BatchSpec!
    "Creates a batch change with an empty batch spec, such as for drafting a new batch\nchange. The user creating the batch change must have permission to create it in the\nnamespace provided. Use `createBatchSpecFromRaw` and `replaceBatchSpecInput` to update\nthe input batch spec after creating."
    createEmptyBatchChange("The namespace (either a user or organization) that this batch change should belong to." namespace: ID! "The (unique) name to identify the batch change by in its namespace." name: String!): BatchChange!
    "Checks if a batch change with the specified name exists, if it doesn't, it creates a batch change\nwith an empty batch spec otherwise returns the existing batch change, this is useful for drafting\nserver-side batch changes with the src-cli tool.\nThe user creating the batch change must have permission to create it in the\nnamespace provided. Use `createBatchSpecFromRaw` and `replaceBatchSpecInput` to update\nthe input batch spec after creating."
    upsertEmptyBatchChange("The namespace (either a user or organization) that this batch change should belong to." namespace: ID! "The (unique) name to identify the batch change by in its namespace." name: String!): BatchChange!
    "Creates a batch spec and triggers a job to evaluate the workspaces. Consumers need to\npoll the batch spec until the resolution is completed to get a full list of all\nworkspaces. This might become streaming so the results will come in over time.\n\nThis mutation should be used when updating an existing batch change whose previous\nbatch spec was already applied. When the previous batch spec was not yet applied, you\ncan use `replaceBatchSpecInput` instead."
    createBatchSpecFromRaw("The raw batch spec as YAML (or the equivalent JSON). See\nhttps:\/\/sourcegraph.com\/github.com\/sourcegraph\/sourcegraph\/-\/blob\/schema\/batch_spec.schema.json\nfor the JSON Schema that describes the structure of this input." batchSpec: String! "If true, repos with a .batchignore file will still be included." allowIgnored: Boolean = false "If true, repos on unsupported codehosts will be included. Resulting changesets in these repos cannot\nbe published." allowUnsupported: Boolean = false "Right away set the execute flag.\n\nTODO: Not implemented yet." execute: Boolean = false "Don't use cache entries." noCache: Boolean = false "The namespace (either a user or organization). A batch spec can only be applied to (or\nused to create) batch changes in this namespace." namespace: ID! "The batch change this batch spec is associated with." batchChange: ID!): BatchSpec!
    "Replaces the original input of the batch spec. All existing resolution jobs and\nworkspaces are deleted and recreated in the background as the `on` section is\nevaluated. This mutation is used for overwriting existing resolutions on unapplied\nbatch specs, so after typing in the editor, we don't create 10s of batch specs. The ID\nof the batch spec to update should NEVER be that of a batch spec that was already\napplied to a batch change, or it will be lost.\n\nFor creating a new batch spec for a batch change whose previous spec was already\napplied, use `createBatchSpecFromRaw` instead."
    replaceBatchSpecInput("The ID of the batch spec resource to update." previousSpec: ID! "The raw batch spec as YAML (or the equivalent JSON). See\nhttps:\/\/sourcegraph.com\/github.com\/sourcegraph\/sourcegraph\/-\/blob\/schema\/batch_spec.schema.json\nfor the JSON Schema that describes the structure of this input." batchSpec: String! "If true, repos with a .batchignore file will still be included." allowIgnored: Boolean = false "If true, repos on unsupported codehosts will be included. Resulting changesets in these repos cannot\nbe published." allowUnsupported: Boolean = false "Right away set the execute flag.\n\nTODO: Not implemented yet." execute: Boolean = false "Don't use cache entries." noCache: Boolean = false): BatchSpec!
    "Creates or updates a batch spec based on the given namespace and name, then\ntriggers a job to evaluate the workspaces.\n\nThis is essentially a wrapper for `createBatchSpecFromRaw` and\n`replaceBatchSpecInput` to facilitate src-cli, and should not be used\notherwise."
    upsertBatchSpecInput("The raw batch spec as YAML (or the equivalent JSON). See\nhttps:\/\/sourcegraph.com\/github.com\/sourcegraph\/sourcegraph\/-\/blob\/schema\/batch_spec.schema.json\nfor the JSON Schema that describes the structure of this input." batchSpec: String! "If true, repos with a .batchignore file will still be included." allowIgnored: Boolean = false "If true, repos on unsupported codehosts will be included. Resulting changesets in these repos cannot\nbe published." allowUnsupported: Boolean = false "Right away set the execute flag.\n\nTODO: Not implemented yet." execute: Boolean = false "Don't use cache entries." noCache: Boolean = false "The namespace (either a user or organization). A batch spec can only be applied to (or\nused to create) batch changes in this namespace." namespace: ID!): BatchSpec!
    "Deletes the batch spec. All associated jobs will be canceled, if still running.\nThis is called by the client, whenever a new run is triggered, to support\nfaster cleanups. We will also purge these in the background, but this'll be\nfaster."
    deleteBatchSpec(batchSpec: ID!): EmptyResponse!
    "Enqueue the workspaces that resulted from evaluation in\n`createBatchSpecFromRaw`to be executed. These will eventually be moved into\nrunning state. resolution is done, to support fast edits.\nOnce the workspace resolution is done, workspace jobs are move to state QUEUED.\nIf resolving is already done by the time this mutation is called, they are\nenqueued immediately.\n\nMust be invoked by the _same_ user that called createBatchSpecFromRaw before.\nCan only be invoked once.\nIf workspace resolution fails, the running flag should be reset to false. API\nconsumers can find this state by looking at BatchSpecWorkspaceResolution.failureMessage.\n\nTODO: This might be blocking with an error for now."
    executeBatchSpec("The ID of the batch spec." batchSpec: ID! "Don't use cache entries. If set, will overwrite the current batchSpec.NoCache\nstate." noCache: Boolean "Right away set the autoApplyEnabled flag on the batch spec.\n\nTODO: Not implemented yet." autoApply: Boolean = false): BatchSpec!
    "Create or update a batch change from a batch spec and locally computed changeset specs. If no\nbatch change exists in the namespace with the name given in the batch spec, a batch change will be\ncreated. Otherwise, the existing batch change will be updated. The batch change is returned.\nClosed batch changes cannot be applied to. In that case, an error with the error code ErrApplyClosedbatch change\nwill be returned."
    applyBatchChange("The batch spec that describes the new desired state of the batch change.\nIt must be in COMPLETED state." batchSpec: ID! "If set, return an error if the batch change identified using the namespace and batch changeSpec\nparameters does not match the batch change with this ID. This lets callers use a stable ID\nthat refers to a specific batch change during an edit session (and is not susceptible to\nconflicts if the underlying batch change is moved to a different namespace, renamed, or\ndeleted). The returned error has the error code ErrEnsureBatchChangeFailed." ensureBatchChange: ID "If set, these changeset specs will have their UI publication states set\nto the given values. This will overwrite any existing UI publication\nstates on the changesets.\n\nAn error will be returned if the same changeset spec ID is included\nmore than once in the array, or if a changeset spec ID is included with\na publication state set in its spec." publicationStates: [ChangesetSpecPublicationStateInput!]): BatchChange!
    "Close a batch change."
    closeBatchChange(batchChange: ID! "Whether to close the changesets associated with this batch change on their respective code\nhosts. \"Close\" means the appropriate final state on the code host (e.g., \"closed\" on\nGitHub and \"declined\" on Bitbucket Server)." closeChangesets: Boolean = false): BatchChange!
    "Move a batch change to a different namespace, or rename it in the current namespace."
    moveBatchChange(batchChange: ID! newName: String newNamespace: ID): BatchChange!
    "Delete a batch change. A deleted batch change is completely removed and can't be un-deleted. The\nbatch change's changesets are kept as-is; to close them, use the closeBatchChange mutation first."
    deleteBatchChange(batchChange: ID!): EmptyResponse
    "Create a new credential for the given user for the given code host.\nIf another token for that code host already exists, an error with the error code\nErrDuplicateCredential is returned."
    createBatchChangesCredential("The user for which to create the credential. If null is provided, a site-wide credential is created." user: ID "The kind of external service being configured." externalServiceKind: ExternalServiceKind! "The URL of the external service being configured." externalServiceURL: String! "The username associated with the credential, if required by the external\nservice kind." username: String "The credential to be stored. This can never be retrieved through the API and will be stored encrypted." credential: String!): BatchChangesCredential!
    "Hard-deletes a given credential."
    deleteBatchChangesCredential(batchChangesCredential: ID!): EmptyResponse!
    "Detach archived changesets from a batch change.\n\nExperimental: This API is likely to change in the future."
    detachChangesets(batchChange: ID! changesets: [ID!]!): BulkOperation!
    "Comment on multiple changesets from a batch change.\n\nExperimental: This API is likely to change in the future."
    createChangesetComments(batchChange: ID! changesets: [ID!]! body: String!): BulkOperation!
    "Reenqueue multiple changesets for processing.\n\nExperimental: This API is likely to change in the future."
    reenqueueChangesets(batchChange: ID! changesets: [ID!]!): BulkOperation!
    "Merge multiple changesets. If squash is true, the commits will be squashed\ninto a single commit on code hosts that support squash-and-merge.\n\nExperimental: This API is likely to change in the future."
    mergeChangesets(batchChange: ID! changesets: [ID!]! squash: Boolean = false): BulkOperation!
    "Close multiple changesets.\n\nExperimental: This API is likely to change in the future."
    closeChangesets(batchChange: ID! changesets: [ID!]!): BulkOperation!
    "Set the UI publication state for multiple changesets. If draft is true, the\nchangesets are published as drafts, provided the code host supports it.\n\nExperimental: This API is likely to change in the future."
    publishChangesets(batchChange: ID! changesets: [ID!]! draft: Boolean = false): BulkOperation!
    "Attempts to cancel the execution of the given batch spec. All workspace jobs\nthat are QUEUED or PROCESSING will be cancelled. The execution must not have completed yet."
    cancelBatchSpecExecution(batchSpec: ID!): BatchSpec!
    "Cancel a single workspace execution. Mostly useful in the \"try out\" UI, but\ncan also be used at later stages. Must be in PROCESSING or QUEUED state."
    cancelBatchSpecWorkspaceExecution(batchSpecWorkspaces: [ID!]!): EmptyResponse!
    "Requeue the workspaces for execution. Previous results and logs will be deleted and\nthe executions are _replaced_. The workspaces must be in a final state (COMPLETED, FAILED)\nto be retryable."
    retryBatchSpecWorkspaceExecution(batchSpecWorkspaces: [ID!]!): EmptyResponse!
    "Requeue all workspaces in the batch spec for execution. Previous results and\nlogs will be deleted and the executions are _replaced_. The workspaces must be in\na final state (COMPLETED, FAILED, CANCELED) to be retryable.\n\nIf includeCompleted is set, then workspaces that successfully completed\nexecution will also be retried and their changeset specs deleted."
    retryBatchSpecExecution(batchSpec: ID! includeCompleted: Boolean = false): BatchSpec!
    "Enqueue the workspace for execution. The workspace must not be running, and\nnot be in a final state. This can be used for running single workspaces before\nrunning the full set."
    enqueueBatchSpecWorkspaceExecution(batchSpecWorkspaces: [ID!]!): EmptyResponse!
    "Sets the autoApplyEnabled on the given batch spec. Must be in PROCESSING state.\n\nTODO: Not implemented yet."
    toggleBatchSpecAutoApply(batchSpec: ID! value: Boolean!): BatchSpec!
    "Deletes a precise index."
    deletePreciseIndex(id: ID!): EmptyResponse
    "Deletes precise indexes by filter criteria."
    deletePreciseIndexes("An (optional) search query that filters the state, repository name, commit, root, and indexer properties." query: String "The index state." states: [PreciseIndexState!] "If supplied, only precise indexes created by an indexer with the given key are modified." indexerKey: String "When specified, only deletes indexes that are latest for the given repository." isLatestForRepo: Boolean "The repository." repository: ID): EmptyResponse
    "Marks a precise index as replaceable by auto-indexing."
    reindexPreciseIndex(id: ID!): EmptyResponse
    "Marks precise indexes by filter criteria as replaceable by auto-indexing."
    reindexPreciseIndexes("An (optional) search query that filters the state, repository name, commit, root, and indexer properties." query: String "The index state." states: [PreciseIndexState!] "If supplied, only precise indexes created by an indexer with the given key are modified." indexerKey: String "When specified, only modifies indexes that are latest for the given repository." isLatestForRepo: Boolean "The repository." repository: ID): EmptyResponse
    "Queues the index jobs for a repository for execution. An optional resolvable revhash\n(commit, branch name, or tag name) can be specified; by default the tip of the default\nbranch will be used.\n\nIf a configuration is supplied, that configuration is used to determine what jobs to\nschedule. If no configuration is supplied, it will go through the regular index scheduling\nrules: first read any in-repo configuration (e.g., sourcegraph.yaml), then look for any\nexisting in-database configuration, finally falling back to the automatically inferred\nconfiguration based on the repo contents at the target commit."
    queueAutoIndexJobsForRepo(repository: ID! rev: String configuration: String): [PreciseIndex!]!
    "Updates the previously set\/overrides the default global auto-indexing job inference Lua script\nwith a new override."
    updateCodeIntelligenceInferenceScript(script: String!): EmptyResponse
    "Updates the indexing configuration associated with a repository."
    updateRepositoryIndexConfiguration(repository: ID! configuration: String!): EmptyResponse
    "Creates a new configuration policy with the given attributes."
    createCodeIntelligenceConfigurationPolicy("If supplied, the repository to which this configuration policy applies. If not supplied,\nthis configuration policy is applied to all repositories." repository: ID "If supplied, the name patterns matching repositories to which this configuration policy\napplies. This option is mutually exclusive with an explicit repository." repositoryPatterns: [String!] name: String! type: GitObjectType! pattern: String! retentionEnabled: Boolean! retentionDurationHours: Int retainIntermediateCommits: Boolean! indexingEnabled: Boolean! indexCommitMaxAgeHours: Int indexIntermediateCommits: Boolean! "embeddingsEnabled, if not provided, currently defaults to false." embeddingsEnabled: Boolean): CodeIntelligenceConfigurationPolicy!
    "Updates the attributes configuration policy with the given identifier."
    updateCodeIntelligenceConfigurationPolicy(id: ID! repositoryPatterns: [String!] name: String! type: GitObjectType! pattern: String! retentionEnabled: Boolean! retentionDurationHours: Int retainIntermediateCommits: Boolean! indexingEnabled: Boolean! indexCommitMaxAgeHours: Int indexIntermediateCommits: Boolean! "embeddingsEnabled, if not provided, currently defaults to false." embeddingsEnabled: Boolean): EmptyResponse
    "Deletes the configuration policy with the given identifier."
    deleteCodeIntelligenceConfigurationPolicy(policy: ID!): EmptyResponse
    "Effectively begins a new ranking map\/reduce job."
    bumpDerivativeGraphKey: EmptyResponse!
    "Deletes the ranking progress object associated with a particular graph key."
    deleteRankingProgress(graphKey: String!): EmptyResponse
    "Create a new dashboard."
    createInsightsDashboard(input: CreateInsightsDashboardInput!): InsightsDashboardPayload!
    "Edit an existing dashboard."
    updateInsightsDashboard(id: ID! input: UpdateInsightsDashboardInput!): InsightsDashboardPayload!
    "Delete a dashboard."
    deleteInsightsDashboard(id: ID!): EmptyResponse!
    "Associate an existing insight view with this dashboard."
    addInsightViewToDashboard(input: AddInsightViewToDashboardInput!): InsightsDashboardPayload!
    "Remove an insight view from a dashboard."
    removeInsightViewFromDashboard(input: RemoveInsightViewFromDashboardInput!): InsightsDashboardPayload!
    "Update an insight series. Restricted to admins only."
    updateInsightSeries(input: UpdateInsightSeriesInput!): InsightSeriesMetadataPayload
    "Create a line chart backed by search insights."
    createLineChartSearchInsight(input: LineChartSearchInsightInput!): InsightViewPayload!
    "Create a pie chart backed by search insights."
    createPieChartSearchInsight(input: PieChartSearchInsightInput!): InsightViewPayload!
    "Update a line chart backed by search insights."
    updateLineChartSearchInsight(id: ID! input: UpdateLineChartSearchInsightInput!): InsightViewPayload!
    "Update a pie chart backed by search insights."
    updatePieChartSearchInsight(id: ID! input: UpdatePieChartSearchInsightInput!): InsightViewPayload!
    "Delete an insight view given the graphql ID."
    deleteInsightView(id: ID!): EmptyResponse!
    "Create a new insight view from an existing view."
    saveInsightAsNewView(input: SaveInsightAsNewViewInput!): InsightViewPayload!
    "Retry the backfill for a failed insight series given the graphql ID of the InsightBackfillQueueItem. Can only be used by a site admin."
    retryInsightSeriesBackfill(id: ID!): InsightBackfillQueueItem!
    "Updates the priority of an insight series backfill making it the highest priority given the graphql ID of the InsightBackfillQueueItem."
    moveInsightSeriesBackfillToFrontOfQueue(id: ID!): InsightBackfillQueueItem!
    "Updates the priority of an insight series backfill making it the lowest priority given the graphql ID of the InsightBackfillQueueItem"
    moveInsightSeriesBackfillToBackOfQueue(id: ID!): InsightBackfillQueueItem!
    "Set the permissions of a repository (i.e., which users may view it on Sourcegraph). This\noperation overwrites the previous permissions for the repository."
    setRepositoryPermissionsForUsers("The repository whose permissions to set." repository: ID! "A list of user identifiers and their repository permissions, which defines the set of\nusers who may view the repository. All users not included in the list will not be\npermitted to view the repository on Sourcegraph." userPermissions: [UserPermissionInput!]!): EmptyResponse!
    "Set 'unrestricted' to true or false on a set of repositories. Repositories with\n'unrestricted' true will be visible to all users on the Sourcegraph instance."
    setRepositoryPermissionsUnrestricted("The repository ids we want to set unrestricted permissions on. Must not contain duplicates." repositories: [ID!]! "true: Any user can view the repo\nfalse: Use existing repo permissions" unrestricted: Boolean!): EmptyResponse!
    "Schedule a permissions sync for given repository. This queries the repository's code host for\nall users' permissions associated with the repository, so that the current permissions apply\nto all users' operations on that repository on Sourcegraph."
    scheduleRepositoryPermissionsSync(repository: ID!): EmptyResponse!
    "Schedule a permissions sync for given user. This queries all code hosts for the user's current\nrepository permissions and syncs them to Sourcegraph, so that the current permissions apply to\nthe user's operations on Sourcegraph."
    scheduleUserPermissionsSync("User to schedule a sync for." user: ID! "Additional options when performing a sync." options: FetchPermissionsOptions): EmptyResponse!
    "Set the sub-repo permissions of a repository (i.e., which paths are allowed or disallowed for\na particular user). This operation overwrites the previous sub-repo permissions for the\nrepository."
    setSubRepositoryPermissionsForUsers("The repository whose permissions to set." repository: ID! "A list of user identifiers and their sub-repository permissions, which defines the set of\npaths within the repository they can access." userPermissions: [UserSubRepoPermission!]!): EmptyResponse!
    "Set the repository permissions for a given Bitbucket project. This mutation will apply the user\ngiven permissions to all the repositories that are part of the Bitbucket project as identified by the\nproject key and all the users that have access to each repository."
    setRepositoryPermissionsForBitbucketProject("Bitbucket project key of which all repository permissions will be updated." projectKey: String! "The bitbucket code host's GraphQL ID where this project is located." codeHost: ID! "A list of user identifiers and their repository permissions, which defines the set of\nusers who may view the repository. All users not included in the list will not be\npermitted to view the repository on Sourcegraph." userPermissions: [UserPermissionInput!]! "Flag to indicate if ALL repositories under the project will allow unrestricted access to all users who have access to the code host." unrestricted: Boolean): EmptyResponse!
    "Cancel permissions sync job with given ID.\nNo error is returned when the job is not in `queued` state or there is no such job\nwith the given ID (latter means that most probably, the job has already been cleaned up)."
    cancelPermissionsSyncJob("ID of the job to be canceled." job: ID! "Optional cancellation reason." reason: String): CancelPermissionsSyncJobResultMessage!
    "Create a code monitor."
    createCodeMonitor("A monitor." monitor: MonitorInput! "A trigger." trigger: MonitorTriggerInput! "A list of actions." actions: [MonitorActionInput!]!): Monitor!
    "Set a code monitor to active\/inactive."
    toggleCodeMonitor("The id of a code monitor." id: ID! "Whether the code monitor should be enabled or not." enabled: Boolean!): Monitor!
    "Delete a code monitor."
    deleteCodeMonitor("The id of a code monitor." id: ID!): EmptyResponse!
    "Update a code monitor. We assume that the request contains a complete code monitor,\nincluding its trigger and all actions. Actions which are stored in the database,\nbut are missing from the request will be deleted from the database. Actions with id=null\nwill be created."
    updateCodeMonitor("The input required to edit a monitor." monitor: MonitorEditInput! "The input required to edit the trigger of a monitor. You can only edit triggers that are\nassociated with the monitor (value of field monitor)." trigger: MonitorEditTriggerInput! "The input required to edit the actions of a monitor. You can only edit actions that are\nassociated with the monitor (value of field monitor)." actions: [MonitorEditActionInput!]!): Monitor!
    "Reset the timestamps of a trigger query. The query will be queued immediately and return\nall results without a limit on the timeframe. Only site admins may perform this mutation."
    resetTriggerQueryTimestamps("The id of the trigger query." id: ID!): EmptyResponse!
    "Triggers a test email for a code monitor action."
    triggerTestEmailAction(namespace: ID! description: String! email: MonitorEmailInput!): EmptyResponse!
    "Triggers a test webhook call for a code monitor action."
    triggerTestWebhookAction(namespace: ID! description: String! webhook: MonitorWebhookInput!): EmptyResponse!
    "Triggers a test Slack webhook message for a code monitor action."
    triggerTestSlackWebhookAction(namespace: ID! description: String! slackWebhook: MonitorSlackWebhookInput!): EmptyResponse!
    "Delete a GitHub App. The GitHub App, along with all of its associated code host connections and\nauthentication provider, will be deleted."
    deleteGitHubApp(gitHubApp: ID!): EmptyResponse
    "Mutations that are only used on Sourcegraph.com.\n\nFOR INTERNAL USE ONLY."
    dotcom: DotcomMutation!
    "Create search context."
    createSearchContext("Search context input." searchContext: SearchContextInput! "List of search context repository revisions." repositories: [SearchContextRepositoryRevisionsInput!]!): SearchContext!
    "Delete search context."
    deleteSearchContext(id: ID!): EmptyResponse!
    "Update search context."
    updateSearchContext("Search context ID." id: ID! "Search context input." searchContext: SearchContextEditInput! "List of search context repository revisions." repositories: [SearchContextRepositoryRevisionsInput!]!): SearchContext!
    "Add a star on a search context for the specified user.\nOnly one star can be created per context and user pair.\nIf the star already exists, this is a no-op."
    createSearchContextStar(searchContextID: ID! userID: ID!): EmptyResponse!
    "Delete a star on a search context for the specified user.\nIf the star does not exist, this is a no-op."
    deleteSearchContextStar(searchContextID: ID! userID: ID!): EmptyResponse!
    "Set the default search context for the specified user."
    setDefaultSearchContext(searchContextID: ID! userID: ID!): EmptyResponse!
    "Create a notebook."
    createNotebook("Notebook input." notebook: NotebookInput!): Notebook!
    "Update a notebook. Only the owner can update it."
    updateNotebook("Notebook ID." id: ID! "Notebook input." notebook: NotebookInput!): Notebook!
    "Delete a notebook. Only the owner can delete it."
    deleteNotebook(id: ID!): EmptyResponse!
    "Create a notebook star for the current user.\nOnly one star can be created per notebook and user pair."
    createNotebookStar(notebookID: ID!): NotebookStar!
    "Delete the notebook star for the current user, if exists."
    deleteNotebookStar(notebookID: ID!): EmptyResponse!
    "Experimental: Schedules a job to create an embedding search index for each listed repository. The indices are used for embeddings search.\nIf force is set to true, then the repo will be re-embedded even if there's already an up-to-date embeddings index."
    scheduleRepositoriesForEmbedding(repoNames: [String!]! force: Boolean): EmptyResponse!
    "Experimental: Cancels the embedding job with the given ID. The job must exist and be in either 'processing' or 'queued' state."
    cancelRepoEmbeddingJob(job: ID!): EmptyResponse!
    "Deletes a role. This mutation targets only non-system roles.\nAny users who were assigned to the role will be unassigned and lose any permissions associated with it."
    deleteRole(role: ID!): EmptyResponse!
    "Creates a role."
    createRole(name: String! permissions: [ID!]!): Role!
    "Set permissions for role. This updates the permissions assigned to a role based on the `permissions` passed\nin the argument. Permissions already assigned to the role that aren't part of the arguments of this mutation\nwill be revoked for the role."
    setPermissions(role: ID! permissions: [ID!]!): EmptyResponse!
    "Set roles for a user. Similar to `setPermissions`, this updates the roles assigned to a user based on the `roles`\npassed in the argument. Permissions already assigned to the role that aren't part of the arguments of this\nmutation will be revoked for the role."
    setRoles(user: ID! roles: [ID!]!): EmptyResponse!
    "addCodeownersFile creates a new Codeowners file for the given repository and file contents."
    addCodeownersFile(input: CodeownersFileInput!): CodeownersIngestedFile!
    "updateCodeownersFile updates an existing Codeowners file for a repository."
    updateCodeownersFile(input: CodeownersFileInput!): CodeownersIngestedFile!
    "deleteCodeownersFiles deletes any existing Codeowners file for the given repositories."
    deleteCodeownersFiles(repositories: [DeleteCodeownersFilesInput!]!): EmptyResponse
    "updateOwnSignalConfigurations updates any configurations keyed by name. It will do nothing if the key doesn't exist."
    updateOwnSignalConfigurations(input: UpdateSignalConfigurationsInput!): [OwnSignalConfiguration!]!
    "assignOwner creates a new assigned owner."
    assignOwner(input: AssignOwnerOrTeamInput!): EmptyResponse
    "removeAssignedOwner removes an assigned owner."
    removeAssignedOwner(input: AssignOwnerOrTeamInput!): EmptyResponse
    "assignTeam creates a new assigned team."
    assignTeam(input: AssignOwnerOrTeamInput!): EmptyResponse
    "removeAssignedTeam removes an assigned owner."
    removeAssignedTeam(input: AssignOwnerOrTeamInput!): EmptyResponse
    "(experimental) Updates the current onboarding tour content."
    updateOnboardingTourContent(input: String!): EmptyResponse!
}

"A namespace is a container for certain types of data and settings, such as a user or organization."
interface Namespace {
    "The globally unique ID of this namespace."
    id: ID!
    "The name of this namespace's component. For a user, this is the username. For an organization,\nthis is the organization name."
    namespaceName: String!
    "The URL to this namespace."
    url: String!
}

"A list of repositories.\n\nThe old `RepositoryConnection` is deprecated and is replaced by\nthis new connection which support proper cursor based pagination.\nThe new connection does not include `precise` argument for totalCount."
type NewRepositoryConnection {
    "A list of repositories."
    nodes: [Repository!]!
    "The total count of repositories in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: ConnectionPageInfo!
}

"A paginated connection for users."
type NewUsersConnection implements Connection {
    "A list of users."
    nodes: [User!]!
    "The total number of users in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: ConnectionPageInfo!
}

"FOR INTERNAL USE ONLY: A status message produced when there are no repositories and no sync jobs in process"
type NoRepositoriesDetected {
    "The message of this status message"
    message: String!
}

"An object with an ID."
interface Node {
    "The ID of the node."
    id: ID!
}

"Information regarding the results of an exhaustive search aggregation"
type NonExhaustiveSearchAggregationResult {
    "A list of the first [LIMIT] aggregation groups in decreasing order"
    groups: [AggregationGroup!]!
    "Boolean indicating if the search query support being persisted as an insight on a dashboard"
    supportsPersistence: Boolean
    "A count to capture the total number of results that are not included in the list of values returned."
    otherResultCount: Int
    "An approximate count of the total number of aggregation groups that were not available in the values list"
    approximateOtherGroupCount: Int
    "The SearchAggregationMode the results relate to"
    mode: SearchAggregationMode!
}

"An enum to describe the reasons why search aggregations are not available"
enum NotAvailableReasonType {
    INVALID_QUERY
    INVALID_AGGREGATION_MODE_FOR_QUERY
    TIMEOUT_EXTENSION_AVAILABLE
    TIMEOUT_NO_EXTENSION_AVAILABLE
    OTHER_ERROR
}

"A notebook with an array of blocks."
type Notebook implements Node {
    "The unique id of the notebook."
    id: ID!
    "The title of the notebook."
    title: String!
    "Array of notebook blocks."
    blocks: [NotebookBlock!]!
    "User that created the notebook or null if the user was removed."
    creator: User
    "User that last updated the notebook or null if that user was removed."
    updater: User
    "Notebook namespace or null if the namespace (user or org) was removed."
    namespace: Namespace
    "Public property controls the visibility of the notebook. A public notebook is available to\nany user on the instance. Private notebooks are only available to their creators."
    public: Boolean!
    "Date and time the notebook was last updated."
    updatedAt: DateTime!
    "Date and time the notebook was created."
    createdAt: DateTime!
    "If current viewer can manage (edit, delete) the notebook."
    viewerCanManage: Boolean!
    "If current viewer has starred the notebook."
    viewerHasStarred: Boolean!
    "Notebook stars."
    stars("Returns the first n notebook stars from the list." first: Int = 50 "Opaque pagination cursor." after: String): NotebookStarConnection!
}

"Notebook blocks are a union of distinct block types: Markdown, Query, File, Symbol, and Compute."
union NotebookBlock = MarkdownBlock | QueryBlock | FileBlock | SymbolBlock

"Enum of possible block types."
enum NotebookBlockType {
    MARKDOWN
    QUERY
    FILE
    SYMBOL
}

"A paginated list of notebooks."
type NotebookConnection {
    "A list of notebooks."
    nodes: [Notebook!]!
    "The total number of notebooks in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"Input for a new notebook."
input NotebookInput {
    "The title of the notebook."
    title: String!
    "Array of notebook blocks."
    blocks: [CreateNotebookBlockInput!]!
    "Notebook namespace (user or org). Controls the visibility of the notebook\nand who can edit the notebook. Only the notebook creator can update the namespace."
    namespace: ID!
    "Public property controls the visibility of the notebook. A public notebook is available to\nany user on the instance. Private notebooks are only available to their creators."
    public: Boolean!
}

"A notebook star."
type NotebookStar {
    "User that starred the notebook."
    user: User!
    "Date and time the notebook star was created."
    createdAt: DateTime!
}

"A paginated list of notebook stars."
type NotebookStarConnection {
    "A list of notebook stars."
    nodes: [NotebookStar!]!
    "The total number of notebook stars in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"NotebooksOrderBy enumerates the ways notebooks can be ordered."
enum NotebooksOrderBy {
    NOTEBOOK_UPDATED_AT
    NOTEBOOK_CREATED_AT
    NOTEBOOK_STAR_COUNT
}

"(experimental) Onboarding tour content wrapper object."
type OnboardingTour {
    "(experimental) The current version of the onboarding tour content."
    current: OnboardingTourContent
}

"(experimental) Content for a specific tour versioned by ID"
type OnboardingTourContent {
    "(experimental) GraphQL ID of the content tour object."
    id: ID!
    "(experimental) JSON value of the onboarding content."
    value: String!
}

"An organization, which is a group of users."
type Org implements Node & SettingsSubject & Namespace {
    "The unique ID for the organization."
    id: ID!
    "The organization's name. This is unique among all organizations on this Sourcegraph site."
    name: String!
    "The organization's chosen display name."
    displayName: String
    "The date when the organization was created."
    createdAt: DateTime!
    "A list of users who are members of this organization."
    members("The limit argument for forward pagination." first: Int "The limit argument for backward pagination." last: Int "The cursor argument for forward pagination." after: String "The cursor argument for backward pagination." before: String "Return users whose usernames or display names match the query." query: String): NewUsersConnection!
    "The latest settings for the organization.\nOnly organization members and site admins can access this field."
    latestSettings: Settings
    "All settings for this organization, and the individual levels in the settings cascade (global > organization)\nthat were merged to produce the final merged settings.\nOnly organization members and site admins can access this field."
    settingsCascade: SettingsCascade!
    "DEPRECATED"
    configurationCascade: ConfigurationCascade! @deprecated(reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release.")
    "DEPRECATED\nA pending invitation for the viewer to join this organization, if any."
    viewerPendingInvitation: OrganizationInvitation @deprecated(reason: "Use invitationByToken operation instead. This field is deprecated and will be removed in a future release.")
    "Whether the viewer has admin privileges on this organization. Currently, all of an organization's members\nhave admin privileges on the organization."
    viewerCanAdminister: Boolean!
    "Whether the viewer is a member of this organization."
    viewerIsMember: Boolean!
    "The URL to the organization."
    url: String!
    "The URL to the organization's settings."
    settingsURL: String
    "The name of this user namespace's component. For organizations, this is the organization's name."
    namespaceName: String!
    "The list of all available executor secrets for execution in this orgs namespace."
    executorSecrets("The scope for which secrets shall be returned." scope: ExecutorSecretScope! "Only return N records." first: Int = 50 "Opaque cursor for pagination." after: String): ExecutorSecretConnection!
    "A list of batch changes initially applied in this organization."
    batchChanges("Returns the first n batch changes from the list." first: Int = 50 "Opaque pagination cursor." after: String "Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`." state: BatchChangeState "Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it." states: [BatchChangeState!] "Only include batch changes that the viewer can administer." viewerCanAdminister: Boolean): BatchChangeConnection!
}

"A list of organizations."
type OrgConnection {
    "A list of organizations."
    nodes: [Org!]!
    "The total count of organizations in the connection. This total count may be larger\nthan the number of nodes in this object when the result is paginated."
    totalCount: Int!
}

"Result organization members count and pending invitations count."
type OrgMembersSummary {
    "The unique ID for the Org."
    id: ID!
    "Total number of members for the org."
    membersCount: Int!
    "Total number of pending invites for the org."
    invitesCount: Int!
}

"An invitation to join an organization as a member."
type OrganizationInvitation implements Node {
    "The ID of the invitation."
    id: ID!
    "The organization that the invitation is for."
    organization: Org!
    "The user who sent the invitation."
    sender: User!
    "The user who received the invitation."
    recipient: User
    "The email address that the invitation was sent to."
    recipientEmail: String
    "The date when this invitation was created."
    createdAt: DateTime!
    "The most recent date when a notification was sent to the recipient about this invitation."
    notifiedAt: DateTime
    "The date when this invitation was responded to by the recipient."
    respondedAt: DateTime
    "The recipient's response to this invitation, or no response (null)."
    responseType: OrganizationInvitationResponseType
    "The URL where the recipient can respond to the invitation when pending, or null if not pending."
    respondURL: String
    "The date when this invitation was revoked."
    revokedAt: DateTime
    "The date when this invitation is going to expire."
    expiresAt: DateTime
    "Boolean flag which returns true if the email on the invite matches a verified email of the user"
    isVerifiedEmail: Boolean
}

"The recipient's possible responses to an invitation to join an organization as a member."
enum OrganizationInvitationResponseType {
    "The invitation was accepted by the recipient."
    ACCEPT
    "The invitation was rejected by the recipient."
    REJECT
}

"An organization membership."
type OrganizationMembership {
    "The organization."
    organization: Org!
    "The user."
    user: User!
    "The time when this was created."
    createdAt: DateTime!
    "The time when this was updated."
    updatedAt: DateTime!
}

"A list of organization memberships."
type OrganizationMembershipConnection {
    "A list of organization memberships."
    nodes: [OrganizationMembership!]!
    "The total count of organization memberships in the connection. This total count may be larger than the number\nof nodes in this object when the result is paginated."
    totalCount: Int!
}

"An out-of-band migration is a process that runs in the background of the instance that moves\ndata from one format into another format. Out-of-band migrations"
type OutOfBandMigration implements Node {
    "The unique identifier of this migration."
    id: ID!
    "The team that owns this migration (e.g., code-intelligence)."
    team: String!
    "The component this migration affects (e.g., codeintel-db.lsif_data_documents)."
    component: String!
    "A human-readable summary of the migration."
    description: String!
    "The Sourcegraph version in which this migration was introduced. The format of this version\nincludes only major and minor parts separated by a dot. The patch version can always be assumed\nto be zero as we'll never introduce or deprecate an out-of-band migration within a patch release.\n\nIt is necessary to completely this migration in reverse (if destructive) before downgrading\nto or past this version. Otherwise, the previous instance version will not be aware of the\nnew data format."
    introduced: String!
    "The Sourcegraph version by which this migration is assumed to have completed. The format of\nthis version mirrors introduced and includes only major and minor parts separated by a dot.\n\nIt is necessary to have completed this migration before upgrading to or past this version.\nOtherwise, the next instance version will no longer be aware of the old data format."
    deprecated: String
    "The progress of the migration (in the forward direction). In the range [0, 1]."
    progress: Float!
    "The time the migration record was inserted."
    created: DateTime!
    "The last time the migration progress or error list was updated."
    lastUpdated: DateTime
    "If false, the migration moves data destructively, and a previous version of Sourcegraph\nwill encounter errors when interfacing with the target data unless the migration is first\nrun in reverse prior to a downgrade."
    nonDestructive: Boolean!
    "If true, the migration will run in reverse."
    applyReverse: Boolean!
    "A list of errors that have occurred while performing this migration (in either direction).\nThis list is bounded by a maximum size, and older errors will replaced by newer errors as\nthe list capacity is reached."
    errors: [OutOfBandMigrationError!]!
}

"An error that occurred while performing an out-of-band migration."
type OutOfBandMigrationError {
    "The error message."
    message: String!
    "The time the error occurred."
    created: DateTime!
}

"A single outbound request."
type OutboundRequest implements Node {
    "The request log item ID."
    id: ID!
    "The time the request was sent at."
    startedAt: DateTime!
    "The method used in the HTTP request. E.g. GET, POST, etc."
    method: String!
    "The full URL the request was sent to."
    url: String!
    "The headers sent with the HTTP request."
    requestHeaders: [HTTPHeader!]!
    "The body content of the HTTP message."
    requestBody: String!
    "The HTTP status code received."
    statusCode: Int!
    "The headers received with the HTTP response."
    responseHeaders: [HTTPHeader!]!
    "The total time the request took to complete, in milliseconds."
    durationMs: Int!
    "Any error message got from the request Doer in case of an error, otherwise an empty string."
    errorMessage: String!
    "Stack information to figure out where the ExternalClientFactory was created."
    creationStackFrame: String!
    "Stack information to figure out where in the code base the request was initiated."
    callStack: String!
}

"A list of logged outbound requests."
type OutboundRequestConnection {
    "A list of outbound requests."
    nodes: [OutboundRequest!]!
    "The total number of outbound request log items in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"An outbound webhook registered within Sourcegraph."
type OutboundWebhook implements Node {
    "The outbound webhook ID."
    id: ID!
    "The outbound webhook URL."
    url: String!
    "The event types that the outbound webhook will receive."
    eventTypes: [OutboundWebhookScopedEventType]!
    "Stats on the payloads dispatched to this outbound webhook within the webhook\nlog retention period."
    stats: OutboundWebhookLogStats!
    "Logged payloads sent to this outbound webhook, optionally filtered by error\nstate. Logs are considered \"errored\" when either a network error occurred\nwhile dispatching the payload, or when a HTTP response outside the range\n[100, 399].\n\nLogs will be returned in time order, from newest to oldest."
    logs(first: Int = 50 after: String onlyErrors: Boolean): OutboundWebhookLogConnection!
}

"A list of outbound webhooks."
type OutboundWebhookConnection {
    "The outbound webhooks in the current page."
    nodes: [OutboundWebhook!]!
    "The total number of matching outbound webhooks."
    totalCount: Int!
    "Connection page metadata."
    pageInfo: PageInfo!
}

"Input for the createOutboundWebhook mutation."
input OutboundWebhookCreateInput {
    "The outbound webhook URL."
    url: String!
    "The secret shared with the outbound webhook."
    secret: String!
    "The event types the outbound webhook will receive.\n\nAt least one event type must be provided."
    eventTypes: [OutboundWebhookScopedEventTypeInput!]!
}

"An event type that a webhook can be registered to be notified of."
type OutboundWebhookEventType {
    "The event type key, as used when constructing\nOutboundWebhookScopedEventTypeInput instances and as returned in\nOutboundWebhook.eventTypes."
    key: String!
    "A human readable description of the event type."
    description: String!
}

"An outbound webhook job, which singularly represents an individual event that\nmay generate one or more webhook payloads."
type OutboundWebhookJob {
    "The outbound webhook job ID."
    id: ID!
    "The event type."
    eventType: String!
    "The scope. Currently unused."
    scope: String
    "The payload sent to each outbound webhook registered for this event type."
    payload: String!
}

"A single logged request sent to an outbound webhook."
type OutboundWebhookLog {
    "The log ID."
    id: ID!
    "The outbound webhook job that triggered the request."
    job: OutboundWebhookJob!
    "When the request was sent."
    sentAt: DateTime!
    "The status code returned from the outbound webhook, or 0 if a network error\noccurred."
    statusCode: Int!
    "The request sent to the outbound webhook."
    request: WebhookLogRequest!
    "The response received from the outbound webhook, or null if no response was\nreceived due to a network error."
    response: WebhookLogResponse
    "The error message if a network error occurred."
    error: String
}

"A list of outbound webhook logs."
type OutboundWebhookLogConnection {
    "The logs in the current page."
    nodes: [OutboundWebhookLog!]!
    "The total number of matching outbound webhook logs."
    totalCount: Int!
    "Connection page metadata."
    pageInfo: PageInfo!
}

"Stats on outbound webhook logs."
type OutboundWebhookLogStats {
    "The total number of webhook payloads logged over the webhook log retention\nperiod."
    total: Int!
    "The total number of webhook payloads logged over the webhook log retention\nperiod that resulted in errors from the webhook."
    errored: Int!
}

"An event type an outbound webhook has opted to receive."
type OutboundWebhookScopedEventType {
    "The event type, which must match a key returned from\noutboundWebhookEventTypes."
    eventType: String!
    "An optional scope for the event type.\n\nCurrently unused."
    scope: String
}

"Event type input for the outbound webhook mutations."
input OutboundWebhookScopedEventTypeInput {
    "The event type, which must match a key returned from\noutboundWebhookEventTypes."
    eventType: String!
    "An optional scope for the event type.\n\nCurrently unused."
    scope: String
}

"Input for the updateOutboundWebhook mutation."
input OutboundWebhookUpdateInput {
    "The outbound webhook URL."
    url: String!
    "The event types the outbound webhook will receive. This list replaces the\nevent types previously registered on the webhook.\n\nAt least one event type must be provided."
    eventTypes: [OutboundWebhookScopedEventTypeInput!]!
}

"OwnSignalConfiguration represents the configuration for an ownership signal."
type OwnSignalConfiguration {
    "The name of the signal configuration, this serves as the primary key."
    name: String!
    "The description of the signal configuration."
    description: String!
    "Whether or not the signal configuration is enabled."
    isEnabled: Boolean!
    "A list of repository name patterns to exclude from the signal."
    excludedRepoPatterns: [String!]!
}

"OwnSignalConfigurationUpdate represents an update to an OwnSignalConfiguration."
input OwnSignalConfigurationUpdate {
    "A list of repository name patterns to exclude from the signal."
    excludedRepoPatterns: [String!]!
    "Whether or not the signal configuration should be enabled."
    enabled: Boolean!
    "The new name for the signal configuration."
    name: String!
}

"Ownables are resources that can have ownership information attached."
interface Ownable {
    "Ownership summary for this entity."
    ownership("Returns the first n ownership records from the list." first: Int "Opaque pagination cursor." after: String "Return only ownership for the given reasons." reasons: [OwnershipReasonType!]): OwnershipConnection!
}

"An owner is any entity that can own other resources."
union Owner = Person | Team

"Ownership is the collection of data points that make Sourcegraph suggest the contained\nowner as owner of the Ownable this is attached to."
type Ownership {
    "The owner this entry refers to. Can be a person or a team."
    owner: Owner!
    "The reasons why Sourcegraph determined this entity as an owner."
    reasons: [OwnershipReason!]!
}

"A list of ownership entries."
type OwnershipConnection {
    "The total count of items in the connection."
    totalCount: Int!
    "The total number of owners in this connection.\nHere an owner is as opposed to an ownership inference signal."
    totalOwners: Int!
    "The pagination info for the connection."
    pageInfo: PageInfo!
    "The page set of Ownership entries in this connection."
    nodes: [Ownership!]!
}

"A union of all the different ownership reasons."
union OwnershipReason = CodeownersFileEntry | RecentContributorOwnershipSignal | RecentViewOwnershipSignal | AssignedOwner

"The only way we can recognize ownership at this point is through CODEOWNERS file entry."
enum OwnershipReasonType {
    CODEOWNERS_FILE_ENTRY
    ASSIGNED_OWNER
    RECENT_CONTRIBUTOR_OWNERSHIP_SIGNAL
    RECENT_VIEW_OWNERSHIP_SIGNAL
}

"Statistics about code ownership computed for given context (usually a repository or directory)."
type OwnershipStats {
    "Total files considered for ownership statistics (owned + unowned)."
    totalFiles: Int!
    "Total files with ownership stemming from CODEOWNERS files."
    totalCodeownedFiles: Int!
    "Total files with any ownership defined (both CODEOWNERS and assigned)."
    totalOwnedFiles: Int!
    "Total files with assigned ownership."
    totalAssignedOwnershipFiles: Int!
    "When statistics were last updated."
    updatedAt: DateTime
}

"Filters package repo references of the matching scheme\/kind, applying to either\nreferences of matching names or versions of a specific package name.\nOne of either nameFilter or versionFilter must be provided."
type PackageFilter {
    "Opaque ID string."
    id: ID!
    "The behaviour of the filter when applied to a matching package repo reference or version."
    behaviour: PackageMatchBehaviour!
    "The schemes\/kinds of package repo references this filter should apply to only."
    kind: PackageRepoReferenceKind!
    "Optional name-matching filter."
    nameFilter: PackageNameFilter
    "Optional package-specific version-matching filter."
    versionFilter: PackageVersionFilter
}

"Whether a package repo reference filter is part of the allowlist or blocklist"
enum PackageMatchBehaviour {
    "Blocks a package repo reference from syncing."
    BLOCK
    "Allows a package repo reference to be synced."
    ALLOW
}

"A package repo reference filter that matches names."
type PackageNameFilter {
    "Glob string to match names."
    packageGlob: String!
}

"A package repo reference filter that matches names."
input PackageNameFilterInput {
    "Glob string to match names."
    packageGlob: String!
}

"Connection resolver for either a list of package repo references or versions."
union PackageRepoOrVersionConnection = PackageRepoReferenceConnection | PackageRepoReferenceVersionConnection

"A reference to a package repo, such as a maven artifact, rust crate etc."
type PackageRepoReference {
    "A unique ID for the package repo reference."
    id: ID!
    "The external service kind under which this package repo\nreference is uniquely identified."
    kind: PackageRepoReferenceKind!
    "The name of the package, in a format relevant to the specific ecosystem e.g.\nmaven artifact coordinates (com.sample:text), npm scoped packages (@monkeys\/banana)."
    name: String!
    "The versions of this package known to the sourcegraph instance."
    versions: [PackageRepoReferenceVersion!]!
    "Indicates whether a package repo reference has been blocked by a blocklist entry and\/or\nno matching entry in a non-empty allowlist"
    blocked: Boolean!
    "The synthetic repository (aka the package repo) created to store the contents of the\nsynced versions of the package repo reference. This type is subject to change once\npackage repos and other non-git code hosts become first-class."
    repository: Repository
}

"List of package repo references."
type PackageRepoReferenceConnection {
    "A list of package repo references."
    nodes: [PackageRepoReference!]!
    "The total number of package repo references in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"A kind of package repo reference.\nExternalServiceKind, with a more specific set of values."
enum PackageRepoReferenceKind {
    GOMODULES
    JVMPACKAGES
    NPMPACKAGES
    PYTHONPACKAGES
    RUSTPACKAGES
    RUBYPACKAGES
}

"A version of a package repo reference."
type PackageRepoReferenceVersion {
    "A unique ID for the package repo reference version."
    id: ID!
    "The package repo reference that this ID is for."
    packageRepoReferenceID: ID!
    "The version string. Not guaranteed to be semver or any other format."
    version: String!
}

"List of package repo reference versions."
type PackageRepoReferenceVersionConnection {
    "A list of package repo versions."
    nodes: [PackageRepoReferenceVersion!]!
    "The total number of package repo versions in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"A package repo reference filter that matches versions for a specific name."
type PackageVersionFilter {
    "Exact package name to match."
    packageName: String!
    "Glob string to match versions."
    versionGlob: String!
}

"A package repo reference filter that matches versions for a specific name."
input PackageVersionFilterInput {
    "Exact package name to match."
    packageName: String!
    "Glob string to match versions."
    versionGlob: String!
}

"A name or version matching filter for. One of either nameFilter or versionFilter must be provided."
input PackageVersionOrNameFilterInput {
    "Optional name-matching filter."
    nameFilter: PackageNameFilterInput
    "Optional package-specific version-matching filter."
    versionFilter: PackageVersionFilterInput
}

"Pagination information for forward-only pagination. See https:\/\/facebook.github.io\/relay\/graphql\/connections.htm#sec-undefined.PageInfo."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
}

"Parent Sourcegraph instance"
type ParentSourcegraphDetails {
    "Sourcegraph instance URL."
    url: String!
}

"EXPERIMENTAL: A Perforce changelist."
type PerforceChangelist {
    "The changelist ID."
    cid: String!
    "The canonical URL to this changelist."
    canonicalURL: String!
    "The corresponding git commit of this changelist."
    commit: GitCommit!
}

"A permission"
type Permission implements Node {
    "The globally unique identifier for this permission."
    id: ID!
    "The namespace in which this permission belongs to."
    namespace: PermissionNamespace!
    "The unique action which is granted to a bearer of this permission."
    action: String!
    "A unique, human-readable string used to represent a permission, taking the form: <namespace>:<object_id>#<relation>@<user_id | user_group>"
    displayName: String!
    "The date and time when the permission was created."
    createdAt: DateTime!
}

"A list of permissions."
type PermissionConnection {
    "A list of permissions."
    nodes: [Permission!]!
    "The total count of permissions in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: ConnectionPageInfo!
}

"A namespace represents a distinct context within which permission policies\nare defined and enforced."
enum PermissionNamespace {
    "This represents the Batch Changes namespace."
    BATCH_CHANGES
    "Code ownership namespace used for permitting to assign ownership\nwithin Sourcegraph."
    OWNERSHIP
    "Repo Metadata namespace used for permitting to edit repository\nkey-value pair metadata."
    REPO_METADATA
}

"PermissionSource indicates where a permission originated from.\n\nREPO_SYNC: The permission was synced from the code host, via repo-centric permission sync.\nUSER_SYNC: The permission was synced from the code host using user-centric permission sync.\nAPI: The permission was set explicitly via the GraphQL API."
enum PermissionSource {
    REPO_SYNC
    USER_SYNC
    API
}

"Permissions information of a repository or a user."
type PermissionsInfo {
    "The permission levels that a user has on the repository."
    permissions: [RepositoryPermission!]!
    "The last complete synced time, the value is updated only after a user- or repo-\ncentric sync of permissions. It is null when the complete sync never happened."
    syncedAt: DateTime
    "The last updated time of permissions, the value is updated whenever there is a\nchange to the database row (i.e. incremental update)."
    updatedAt: DateTime
    "What was the source of the last permission update. The value is updated whenever different source last touched the database row (i.e. permission sync or explicit permissions update)"
    source: PermissionSource
    "If true for a repo, it indicates access to the repo is allowed for all users.\nIt will always be false for users."
    unrestricted: Boolean!
    "The connection for repository permissions accessible to the user."
    repositories("Number of nodes returned during forward pagination. Maximum number of returned nodes is 100. Up to 20 nodes are returned by default." first: Int "Number of nodes returned during backward pagination. Maximum number of returned nodes is 100. Up to 20 nodes are returned by default." last: Int "Opaque pagination cursor to be used when paginating forwards." after: String "Opaque pagination cursor to be used when paginating backwards." before: String "Search query to filter repositories based on name." query: String): PermissionsInfoRepositoriesConnection
    "The connection for users who have access to the repository."
    users("Number of nodes returned during forward pagination. Maximum number of returned nodes is 100." first: Int "Number of nodes returned during backward pagination. Maximum number of returned nodes is 100." last: Int "Opaque pagination cursor to be used when paginating forwards." after: String "Opaque pagination cursor to be used when paginating backwards." before: String "Search query to filter users based on username or display name." query: String): PermissionsInfoUsersConnection
}

"Connection for repository permissions accessible to the user"
type PermissionsInfoRepositoriesConnection implements Connection {
    "List of repository permission info nodes"
    nodes: [PermissionsInfoRepositoryNode!]!
    "The total number of repository permission info nodes in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: ConnectionPageInfo!
}

"Repository permission node defining why the repository is accessible to the user"
type PermissionsInfoRepositoryNode {
    "The ID of the repository."
    id: ID!
    "The repository corresponding to the permission."
    repository: Repository
    "The reason why the current user has permission to access the repository."
    reason: String!
    "The timestamp when the permission was last updated at."
    updatedAt: DateTime
}

"Repository permission node defining why the repository is accessible to the user."
type PermissionsInfoUserNode {
    "The ID of the User."
    id: ID!
    "The user corresponding to the permission."
    user: User
    "The reason why the user has access to the repository."
    reason: String!
    "The timestamp when the permission was last updated at."
    updatedAt: DateTime
}

"Connection for user permission who has access to the repository."
type PermissionsInfoUsersConnection implements Connection {
    "List of repository permission info nodes"
    nodes: [PermissionsInfoUserNode!]!
    "The total number of repository permission info nodes in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: ConnectionPageInfo!
}

"State of a permission sync job."
type PermissionsSyncJob implements Node {
    "Unique node ID."
    id: ID!
    "State of a permission sync job."
    state: PermissionsSyncJobState!
    "Failure message for failed sync job."
    failureMessage: String
    "Reason for triggering a permission sync job."
    reason: PermissionsSyncJobReasonWithGroup!
    "Reason for cancellation of a given permission sync job."
    cancellationReason: String
    "User who triggered this permission sync job."
    triggeredByUser: User
    "Time when permission sync job was queued."
    queuedAt: DateTime!
    "Time when permission sync job processing was started."
    startedAt: DateTime
    "Time when permission sync job processing finished."
    finishedAt: DateTime
    "Time after which permission sync job processing should be started."
    processAfter: DateTime
    "How long did it take for permission sync job to complete."
    ranForMs: Int
    "Number of permission sync job processing resets."
    numResets: Int
    "Number of permission sync job processing failures."
    numFailures: Int
    "Time of last heartbeat of a permission sync job processing."
    lastHeartbeatAt: DateTime
    "Hostname of a worker on which permission sync job is processing."
    workerHostname: String!
    "Flag showing that given permission sync job should be canceled instead of being processed."
    cancel: Boolean!
    "Subject of a permission sync job (repository or user)."
    subject: PermissionsSyncJobSubject!
    "Priority of a permission sync job."
    priority: PermissionsSyncJobPriority!
    "Flag showing that there are no permissions for a given repository\/user."
    noPerms: Boolean!
    "Flag showing that caches should be invalidated during permission sync job processing."
    invalidateCaches: Boolean!
    "Number of added permissions during permission sync job processing."
    permissionsAdded: Int!
    "Number of removed permissions during permission sync job processing."
    permissionsRemoved: Int!
    "Number of found permissions during permission sync job processing."
    permissionsFound: Int!
    "State of providers (code hosts) during permission sync job."
    codeHostStates: [CodeHostState!]!
    "Show if the job has finished with a partially successful result."
    partialSuccess: Boolean!
    "Rank of the permissions syncing job in processing queue."
    placeInQueue: Int
}

"Permission sync job priority."
enum PermissionsSyncJobPriority {
    LOW
    MEDIUM
    HIGH
}

"State types of permission sync jobs."
enum PermissionsSyncJobReason {
    REASON_USER_OUTDATED_PERMS
    REASON_USER_NO_PERMS
    REASON_REPO_OUTDATED_PERMS
    REASON_REPO_NO_PERMS
    REASON_REPO_UPDATED_FROM_CODE_HOST
    REASON_USER_EMAIL_REMOVED
    REASON_USER_EMAIL_VERIFIED
    REASON_USER_ADDED
    REASON_USER_ADDED_TO_ORG
    REASON_USER_REMOVED_FROM_ORG
    REASON_USER_ACCEPTED_ORG_INVITE
    REASON_GITHUB_USER_EVENT
    REASON_GITHUB_USER_ADDED_EVENT
    REASON_GITHUB_USER_REMOVED_EVENT
    REASON_GITHUB_USER_MEMBERSHIP_ADDED_EVENT
    REASON_GITHUB_USER_MEMBERSHIP_REMOVED_EVENT
    REASON_GITHUB_TEAM_ADDED_TO_REPO_EVENT
    REASON_GITHUB_TEAM_REMOVED_FROM_REPO_EVENT
    REASON_GITHUB_ORG_MEMBER_ADDED_EVENT
    REASON_GITHUB_ORG_MEMBER_REMOVED_EVENT
    REASON_GITHUB_REPO_EVENT
    REASON_GITHUB_REPO_MADE_PRIVATE_EVENT
    REASON_MANUAL_REPO_SYNC
    REASON_MANUAL_USER_SYNC
    REASON_EXTERNAL_ACCOUNT_ADDED
    REASON_EXTERNAL_ACCOUNT_DELETED
}

"Sync reason groups of permission sync jobs."
enum PermissionsSyncJobReasonGroup {
    MANUAL
    WEBHOOK
    SCHEDULE
    SOURCEGRAPH
    UNKNOWN
}

"Compound type for a permissions sync job trigger reason.\nConsists of a reason group (PermissionsSyncJobReasonGroup) and a reason itself, providing details\nabout why\/how the sync was triggered."
type PermissionsSyncJobReasonWithGroup {
    "PermissionsSyncJobReasonGroup combines multiple permission sync job trigger reasons into groups with similar grounds."
    group: PermissionsSyncJobReasonGroup!
    "Reason with details about why\/how the sync was triggered."
    reason: PermissionsSyncJobReason
}

"State types of permissions sync jobs."
enum PermissionsSyncJobState {
    QUEUED
    PROCESSING
    FAILED
    ERRORED
    COMPLETED
    CANCELED
}

"Union type for a subject of a permission sync job (repository or user)."
union PermissionsSyncJobSubject = User | Repository

"Permissions sync jobs."
type PermissionsSyncJobsConnection implements Connection {
    "Permissions sync jobs."
    nodes: [PermissionsSyncJob!]!
    "The total number of jobs in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: ConnectionPageInfo!
}

"Type of search for permissions sync jobs: user or repository."
enum PermissionsSyncJobsSearchType {
    USER
    REPOSITORY
}

"Various permissions syncing statistics."
type PermissionsSyncingStats {
    "The number of permissions sync jobs in the queue."
    queueSize: Int!
    "The number of users with latest permissions sync job failing."
    usersWithLatestJobFailing: Int!
    "The number of repositories with latest permissions sync job failing."
    reposWithLatestJobFailing: Int!
    "The number of users with no permissions."
    usersWithNoPermissions: Int!
    "The number of repositories with no permissions."
    reposWithNoPermissions: Int!
    "The number of users with old permissions."
    usersWithStalePermissions: Int!
    "The number of repository with old permissions."
    reposWithStalePermissions: Int!
}

"A person."
type Person {
    "The name."
    name: String!
    "The email."
    email: String!
    "The name if set; otherwise the email username."
    displayName: String!
    "The avatar URL, if known."
    avatarURL: String
    "The corresponding user account for this person, if one exists."
    user: User
}

"A Phabricator repository."
type PhabricatorRepo {
    "The canonical repo name (e.g. \"github.com\/gorilla\/mux\")."
    name: String!
    "An alias for name."
    uri: String! @deprecated(reason: "use name instead")
    "The unique Phabricator identifier for the repo, like \"MUX\""
    callsign: String!
    "The URL to the phabricator instance (e.g. http:\/\/phabricator.sgdev.org)"
    url: String!
}

"View presentation for an insight pie chart."
type PieChartInsightViewPresentation {
    "The title for the pie chart."
    title: String!
    "The threshold for which groups fall into the \"other category\". Only categories with a percentage greater than\nthis value will be separately rendered."
    otherThreshold: Float!
}

"Options for a pie chart"
input PieChartOptionsInput {
    "The title for the pie chart."
    title: String!
    "The threshold for which groups fall into the \"other category\". Only categories with a percentage greater than\nthis value will be separately rendered."
    otherThreshold: Float!
}

"Input for a pie chart search insight"
input PieChartSearchInsightInput {
    "The query string."
    query: String!
    "The scope of repositories."
    repositoryScope: RepositoryScopeInput!
    "Options for this pie chart."
    presentationOptions: PieChartOptionsInput!
    "The dashboard IDs to associate this insight with once created."
    dashboards: [ID!]
}

"A zero-based position inside a file."
type Position {
    "The line number (zero-based) of the position."
    line: Int!
    "The character offset (zero-based) in the line of the position."
    character: Int!
}

"The configuration and execution summary of a step to be performed prior to indexing."
type PreIndexStep {
    "The working directory relative to the cloned repository root."
    root: String!
    "The name of the Docker image to run."
    image: String!
    "The arguments to supply to the Docker container's entrypoint."
    commands: [String!]!
    "The execution summary (if completed or errored) of the docker command."
    logEntry: ExecutionLogEntry
}

"Metadata and status about a precise code intelligence index."
type PreciseIndex implements Node {
    "The ID."
    id: ID!
    "The project for which this index provides code intelligence."
    projectRoot: CodeIntelGitTree
    "The original 40-character commit commit supplied at creation."
    inputCommit: String!
    "The original root supplied at creation."
    inputRoot: String!
    "The original indexer name supplied at creation."
    inputIndexer: String!
    "The tags, if any, associated with this commit."
    tags: [String!]!
    "The indexer used to produce this index."
    indexer: CodeIntelIndexer
    "The current state."
    state: PreciseIndexState!
    "The time the index was queued for indexing."
    queuedAt: DateTime
    "The time the index job started running."
    indexingStartedAt: DateTime
    "The time the index job stopped running."
    indexingFinishedAt: DateTime
    "The time the index data file was uploaded."
    uploadedAt: DateTime
    "The time the upload data file started being processed."
    processingStartedAt: DateTime
    "The time the upload data file stopped being processed."
    processingFinishedAt: DateTime
    "The indexing or processing error message."
    failure: String
    "The rank of this index job or processing job in its respective queue."
    placeInQueue: Int
    "The configuration and execution summary (if completed or errored) of this index job."
    steps: IndexSteps
    "If set, this index has been marked as replaceable by a new auto-indexing job."
    shouldReindex: Boolean!
    "Whether or not this index provides intelligence for the tip of the default branch. Find reference\nqueries will return symbols from remote repositories only when this property is true. This property\nis updated asynchronously and is eventually consistent with the git data known by the instance."
    isLatestForRepo: Boolean!
    "The list of retention policies associated with this index."
    retentionPolicyOverview(matchesOnly: Boolean! query: String after: String first: Int): CodeIntelligenceRetentionPolicyMatchesConnection!
    "Audit logs representing each state change of the upload in order from earliest to latest."
    auditLogs: [LSIFUploadAuditLog!]
}

"A list of precise code intelligence indexes."
type PreciseIndexConnection {
    "The current page of indexes."
    nodes: [PreciseIndex!]!
    "The total number of results (over all pages) in this list."
    totalCount: Int
    "Metadata about the current page of results."
    pageInfo: PageInfo!
}

"Possible states for PreciseIndexes."
enum PreciseIndexState {
    UPLOADING_INDEX
    QUEUED_FOR_PROCESSING
    PROCESSING
    PROCESSING_ERRORED
    COMPLETED
    DELETING
    DELETED
    QUEUED_FOR_INDEXING
    INDEXING
    INDEXING_ERRORED
    INDEXING_COMPLETED
}

"A not-yet-committed preview of a diff on a repository."
type PreviewRepositoryComparison {
    "The repository that is the base (left-hand side) of this comparison."
    baseRepository: Repository!
    "The file diffs for each changed file."
    fileDiffs("Return the first n file diffs from the list." first: Int "Return file diffs after the given cursor." after: String "A list of paths or directories used to filter the diffs" paths: [String!]): FileDiffConnection!
}

"A product license that was created on Sourcegraph.com.\nFOR INTERNAL USE ONLY."
type ProductLicense implements Node {
    "The unique ID of this product license."
    id: ID!
    "The product subscription associated with this product license."
    subscription: ProductSubscription!
    "Information about this product license."
    info: ProductLicenseInfo
    "The license key."
    licenseKey: String!
    "Site ID of the instance that uses the license."
    siteID: String
    "The date when this product license was created."
    createdAt: DateTime!
    "The date when this product license was revoked."
    revokedAt: DateTime
    "The reason for revoking product license."
    revokeReason: String
    "The version of the license."
    version: Int!
}

"A list of product licenses.\nFOR INTERNAL USE ONLY."
type ProductLicenseConnection {
    "A list of product licenses."
    nodes: [ProductLicense!]!
    "The total count of product licenses in the connection. This total count may be larger than the number of\nnodes in this object when the result is paginated."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"Information about this site's product license (which activates certain Sourcegraph features)."
type ProductLicenseInfo {
    "The full name of the product that this license is for. To get the product name for the current\nSourcegraph site, use ProductSubscriptionStatus.productNameWithBrand instead (to handle cases where there is\nno license)."
    productNameWithBrand: String!
    "Tags indicating the product plan and features activated by this license."
    tags: [String!]!
    "The number of users allowed by this license."
    userCount: Int!
    "The date when this license expires."
    expiresAt: DateTime!
    "The Salesforce subscription ID associated with this license."
    salesforceSubscriptionID: String
    "The Salesforce opportunity ID associated with this license."
    salesforceOpportunityID: String
    "This indicates if the current license is valid. It will be false if:\n- The license key has expired\n- The license key is in use on another instance\n- The license key was revoked"
    isValid: Boolean!
    "This indicates the reason the license is invalid. It'll be null if `isValid` is true."
    licenseInvalidityReason: String
    "The license key, hashed using sha256."
    hashedKey: String
}

"An input type that describes a product license to be generated and signed.\nFOR INTERNAL USE ONLY."
input ProductLicenseInput {
    "The tags that indicate which features are activated by this license."
    tags: [String!]!
    "The number of users for which this product subscription is valid."
    userCount: Int!
    "The expiration date of this product license, expressed as the number of seconds since the epoch."
    expiresAt: Int!
    "The Salesforce subscription ID associated with this product license."
    salesforceSubscriptionID: String
    "The Salesforce opportunity ID associated with this product license."
    salesforceOpportunityID: String
}

"A product subscription that was created on Sourcegraph.com.\nFOR INTERNAL USE ONLY."
type ProductSubscription implements Node {
    "The unique ID of this product subscription."
    id: ID!
    "The unique UUID of this product subscription. Unlike ProductSubscription.id, this does not\nencode the type and is not a GraphQL node ID."
    uuid: String!
    "A name for the product subscription derived from its ID. The name is not guaranteed to be unique."
    name: String!
    "The user (i.e., customer) to whom this subscription is granted, or null if the account has been deleted."
    account: User
    "The currently active product license associated with this product subscription, if any."
    activeLicense: ProductLicense
    "A list of product licenses associated with this product subscription.\nOnly Sourcegraph.com site admins may list inactive product licenses (other viewers should use\nProductSubscription.activeLicense)."
    productLicenses("Returns the first n product licenses from the list." first: Int): ProductLicenseConnection!
    "The most preferable Sourcegraph access token to use for authenticating as the\nsubscription holder with managed Sourcegraph services.\nNull only if creating a token failed, for example when no active license exists."
    currentSourcegraphAccessToken: String
    "Available access tokens for authenticating as the subscription holder with managed\nSourcegraph services."
    sourcegraphAccessTokens: [String!]!
    "Cody Gateway access granted to this subscription. Properties may be inferred from the active license, or be defined in overrides."
    codyGatewayAccess: CodyGatewayAccess!
    "The date when this product subscription was created."
    createdAt: DateTime!
    "Whether this product subscription was archived."
    isArchived: Boolean!
    "The URL to view this product subscription."
    url: String!
    "The URL to view this product subscription in the site admin area.\nOnly Sourcegraph.com site admins may query this field."
    urlForSiteAdmin: String
}

"A list of product subscriptions.\nFOR INTERNAL USE ONLY."
type ProductSubscriptionConnection {
    "A list of product subscriptions."
    nodes: [ProductSubscription!]!
    "The total count of product subscriptions in the connection. This total count may be larger than the number of\nnodes in this object when the result is paginated."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"Information about this site's product subscription (which enables access to and renewals of a product license)."
type ProductSubscriptionStatus {
    "The full name of the product in use, such as \"Sourcegraph Enterprise\"."
    productNameWithBrand: String!
    "The max number of user accounts that have been active on this Sourcegraph site for the current license.\nIf no license is in use, returns zero."
    actualUserCount: Int!
    "The date and time when the max number of user accounts that have been active on this Sourcegraph site for\nthe current license was reached. If no license is in use, returns an empty string."
    actualUserCountDate: String!
    "The number of users allowed. If there is a license, this is equal to ProductLicenseInfo.userCount. Otherwise,\nit is the user limit for instances without a license, or null if there is no limit."
    maximumAllowedUserCount: Int
    "The number of free users allowed on a site without a license before a warning is shown to all users, or null\nif a valid license is in use."
    noLicenseWarningUserCount: Int
    "The product license associated with this subscription, if any."
    license: ProductLicenseInfo
}

"Public provider-specific data about the external account."
type PublicExternalAccountData {
    "The text name the user is using on the external account, if any."
    displayName: String
    "The login or username the user is using on the external account, if any."
    login: String
    "Link to the user profile page for the external account."
    url: String
}

"A quadruple that represents all possible states of the published value: true, false, 'draft', or null."
scalar PublishedValue

"A query."
type Query {
    "The root of the query."
    root: Query! @deprecated(reason: "this will be removed.")
    "Looks up a node by ID."
    node(id: ID!): Node
    "Looks up a repository by either name or cloneURL."
    repository("Query the repository by name, for example \"github.com\/gorilla\/mux\"." name: String "Query the repository by a Git clone URL (format documented here: https:\/\/git-scm.com\/docs\/git-clone_git_urls_a_id_urls_a)\nby checking for a code host configuration that matches the clone URL.\nWill not actually check the code host to see if the repository actually exists." cloneURL: String "An alias for name. DEPRECATED: use name instead." uri: String): Repository
    "Looks up a repository by either name or cloneURL or hashedName. When the\nrepository does not exist on the server, it returns a Redirect to an\nexternal Sourcegraph URL that may have this repository instead. Otherwise,\nthis query returns null."
    repositoryRedirect("Query the repository by name, for example \"github.com\/gorilla\/mux\"." name: String "Query the repository by a Git clone URL (format documented here: https:\/\/git-scm.com\/docs\/git-clone_git_urls_a_id_urls_a)\nby checking for a code host configuration that matches the clone URL.\nWill not actually check the code host to see if the repository actually exists." cloneURL: String "Query the repository by hashed name.\nHashed name is a SHA256 checksum of the absolute repo name in lower case,\nfor example \"github.com\/sourcegraph\/sourcegraph\" -> \"a6c905ceb7dec9a565945ceded8c7fa4154250df8b928fb40673b535d9a24c2f\"" hashedName: String): RepositoryRedirect
    "Lists external services under given namespace.\nIf no namespace is given, it returns all external services."
    externalServices("Returns the first n external services from the list." first: Int "Opaque pagination cursor." after: String "If provided, fetch external services which contain a repo with the given ID." repo: ID): ExternalServiceConnection!
    "Lists all namespaces for a given external service connection.\nA namespace is an entity on the code host that repositories are assignable to."
    externalServiceNamespaces("The GraphQL ID of the external service whose configuration will be used to define the code host remote url to\nsubmit requests to and the token value to authenticate with.\nIf no external service exists which provides the necessary request parameters then leave ID nil and\nprovide kind, remote code host token and url." id: ID "The kind of the external service." kind: ExternalServiceKind! "The secret token value that is used to authenticate." token: String! "The url of the external service." url: String!): ExternalServiceNamespaceConnection!
    "Lists all repositories for a given external service connection."
    externalServiceRepositories("The GraphQL ID of the external service whose configuration will be used to define the code host remote url to\nsubmit requests to and the token value to authenticate with.\nIf no external service exists which provides the necessary request parameters then leave ID nil and\nprovide kind, remote code host token and url." id: ID "The kind of the external service." kind: ExternalServiceKind! "The secret token value that is used to authenticate." token: String! "The url of the external service." url: String! "Repository query string." query: String! "A list of repository names to exclude from results (in the form of owner\/name)." excludeRepos: [String!]! "Returns the first n repositories matching the query and excludeRepos criteria." first: Int): ExternalServiceRepositoryConnection!
    "List all repositories."
    repositories("Returns the first n repositories from the list." first: Int "Returns the last n repositories from the list." last: Int "Return repositories whose names match the query." query: String "An opaque cursor that is used for pagination." after: String "An opaque cursor that is used for pagination." before: String "Return repositories whose names are in the list." names: [String!] "Include cloned repositories." cloned: Boolean = true "Include only repositories of the given clone status." cloneStatus: CloneStatus "Include repositories that are not yet cloned and for which cloning is not in progress." notCloned: Boolean = true "Include repositories that have a text search index." indexed: Boolean = true "Include repositories that do not have a text search index." notIndexed: Boolean = true "Include repositories that have embeddings." embedded: Boolean = true "Include repositories that don't have embeddings." notEmbedded: Boolean = true "Include only repositories that have encountered errors when cloning or fetching" failedFetch: Boolean = false "Include repositories that are corrupt" corrupted: Boolean = false "Return repositories that are associated with the given external service." externalService: ID "Sort field." orderBy: RepositoryOrderBy = REPOSITORY_NAME "Sort direction." descending: Boolean = false): NewRepositoryConnection!
    "Query package repo references."
    packageRepoReferences("The exact package repo reference kind to filter by." kind: PackageRepoReferenceKind "If supplied, only package repo references that match the given\nterms by their name will be returned.\nTODO: fuzzy vs exact?" name: String "Returns the first n package repo references from the list." first: Int "Opaque pagination cursor." after: String): PackageRepoReferenceConnection!
    "Query package repo reference filters."
    packageRepoFilters("Whether the matcher should be for allowlisting or blocklisting." behaviour: PackageMatchBehaviour "The ecosystem of the package repo reference this matcher should apply to.\nMaps to the external service whos config would be updated when used in the\nset query." kind: PackageRepoReferenceKind): [PackageFilter!]
    "Returns either a list of package repo references,\nor the versions of a single package repo reference,\nthat match the provided matcher."
    packageRepoReferencesMatchingFilter("The kind of the package repo reference this matcher should apply to." kind: PackageRepoReferenceKind! "The matcher for which to return matching results." filter: PackageVersionOrNameFilterInput! "Returns the first n package\/package version matches from the list." first: Int "Opaque pagination cursor." after: String): PackageRepoOrVersionConnection!
    "Looks up a Phabricator repository by name."
    phabricatorRepo("The name, for example \"github.com\/gorilla\/mux\"." name: String "An alias for name. DEPRECATED: use name instead." uri: String): PhabricatorRepo
    "The current user."
    currentUser: User
    "Looks up a user by username or email address."
    user("Query the user by username." username: String "Query the user by verified email address." email: String): User
    "List all users."
    users("Returns the first n users from the list." first: Int "Opaque pagination cursor." after: String "Return users whose usernames or display names match the query." query: String "Returns users who have been active in a given period of time." activePeriod: UserActivePeriod "Returns users who have NOT been active since a given point in time." inactiveSince: DateTime): UserConnection!
    "Looks up an organization by name."
    organization(name: String!): Org
    "List all organizations."
    organizations("Returns the first n organizations from the list." first: Int "Return organizations whose names or display names match the query." query: String): OrgConnection!
    "Renders Markdown to HTML. The returned HTML is already sanitized and\nescaped and thus is always safe to render."
    renderMarkdown(markdown: String! options: MarkdownOptions): String!
    "EXPERIMENTAL: Syntax highlights a code string."
    highlightCode(code: String! fuzzyLanguage: String! disableTimeout: Boolean! isLightTheme: Boolean): String!
    "Looks up an instance of a type that implements SettingsSubject (i.e., something that has settings). This can\nbe a site (which has global settings), an organization, or a user."
    settingsSubject(id: ID!): SettingsSubject
    "The settings for the viewer. The viewer is either an anonymous visitor (in which case viewer settings is\nglobal settings) or an authenticated user (in which case viewer settings are the user's settings)."
    viewerSettings: SettingsCascade!
    "DEPRECATED"
    viewerConfiguration: ConfigurationCascade! @deprecated(reason: "use viewerSettings instead")
    "The configuration for clients."
    clientConfiguration: ClientConfigurationDetails!
    "Runs a search."
    search("The version of the search syntax being used.\nAll new clients should use the latest version." version: SearchVersion = V1 "PatternType controls the search pattern type, if and only if it is not specified in the query string using\nthe patternType: field." patternType: SearchPatternType "The search query (such as \"foo\" or \"repo:myrepo foo\")." query: String = ""): Search
    "List of saved searches based on namespace"
    savedSearches("The namespace to list the saved searches for." namespace: ID! "The limit argument for forward pagination." first: Int "The limit argument for backward pagination." last: Int "The cursor argument for forward pagination." after: String "The cursor argument for backward pagination." before: String): SavedSearchesConnection!
    "EXPERIMENTAL: Return the parse tree of a search query."
    parseSearchQuery("The search query (such as \"repo:myrepo foo\")." query: String = "" "The parser to use for this query." patternType: SearchPatternType = standard "The output corresponding to a phase in the parser pipeline." outputPhase: SearchQueryOutputPhase = PARSE_TREE "The parser output format." outputFormat: SearchQueryOutputFormat = JSON "The level of output format verbosity." outputVerbosity: SearchQueryOutputVerbosity = BASIC): String!
    "The current site."
    site: Site!
    "Retrieve responses to surveys."
    surveyResponses("Returns the first n survey responses from the list." first: Int): SurveyResponseConnection!
    "FOR INTERNAL USE ONLY: Lists all status messages"
    statusMessages: [StatusMessage!]!
    "FOR INTERNAL USE ONLY: Query repository statistics for the site."
    repositoryStats: RepositoryStats!
    "Look up a namespace by ID."
    namespace(id: ID!): Namespace
    "Look up a namespace by name, which is a username or organization name."
    namespaceByName("The name of the namespace." name: String!): Namespace
    "Returns true if any of the code hosts supplied are syncing now or within \"seconds\" from now."
    codeHostSyncDue(ids: [ID!]! seconds: Int!): Boolean!
    "Retrieve all registered out-of-band migrations."
    outOfBandMigrations: [OutOfBandMigration!]!
    "Retrieve the list of defined feature flags"
    featureFlags: [FeatureFlag!]!
    "Retrieve a feature flag"
    featureFlag(name: String!): FeatureFlag!
    "Evaluates a feature flag for the current user\nReturns null if feature flag does not exist"
    evaluateFeatureFlag(flagName: String!): Boolean
    "Retrieve all evaluated feature flags for the current user"
    evaluatedFeatureFlags: [EvaluatedFeatureFlag!]!
    "Retrieve the value of a feature flag for the organization"
    organizationFeatureFlagValue(orgID: ID! flagName: String!): Boolean!
    "Retrieve all organization feature flag overrides for the current user"
    organizationFeatureFlagOverrides: [FeatureFlagOverride!]!
    "Retrieves the temporary settings for the current user."
    temporarySettings: TemporarySettings!
    "Returns recently received webhooks across all external services, optionally\nlimiting the returned values to only those that didn't match any external\nservice.\n\nOnly site admins can access this field."
    webhookLogs("Returns the first n webhook logs." first: Int "Opaque pagination cursor." after: String "Only include webhook logs that resulted in errors." onlyErrors: Boolean "Only include webhook logs that were not matched to an external service." onlyUnmatched: Boolean "Only include webhook logs on or after this time." since: DateTime "Only include webhook logs on or before this time." until: DateTime "Only include webhook logs of given webhook ID." webhookID: ID "Only include webhook logs that have no webhook ID set." legacyOnly: Boolean): WebhookLogConnection!
    "Get a log of the latest outbound external requests. Only available to site admins."
    outboundRequests("Returns the first n log items. If omitted then it returns all of them." first: Int "Opaque pagination cursor." after: String): OutboundRequestConnection!
    "Get a list of background jobs that are currently known in the system."
    backgroundJobs("Returns the first n jobs. If omitted then it returns all of them." first: Int "Opaque pagination cursor." after: String "The maximum number of recent runs to return for each routine." recentRunCount: Int): BackgroundJobConnection!
    "EXPERIMENTAL: Get invitation based on the JWT in the invitation URL"
    invitationByToken("The token that uniquely identifies the invitation" token: String!): OrganizationInvitation!
    "Get pending invitations for the specific organization"
    pendingInvitations("The organization ID" organization: ID!): [OrganizationInvitation!]!
    "Search for users that opt-in to search autocomplete."
    autocompleteMembersSearch("The organization ID" organization: ID! "Return users whose usernames or display names match the query." query: String!): [AutocompleteMemberSearchItem!]!
    "Get started organization summary"
    orgMembersSummary("The organization ID" organization: ID!): OrgMembersSummary!
    "Lists webhooks. Only available to site admins.\nIf no kind is given, it returns all webhooks.\nIf first is omitted, 20 items are returned"
    webhooks("Returns the first n webhooks from the list." first: Int "Opaque pagination cursor." after: String "Optionally filter by kind." kind: ExternalServiceKind): WebhookConnection!
    "List slow GraphQL requests that were recently captured (requires site-admin permissions)."
    slowRequests("Opaque pagnination cursor." after: String): SlowRequestConnection!
    "Roles returns all the roles in the database that matches the arguments."
    roles("The limit argument for forward pagination." first: Int "The limit argument for backward pagination." last: Int "The cursor argument for forward pagination." after: String "The cursor argument for backward pagination." before: String): RoleConnection!
    "This returns all permissions in a paginated format."
    permissions("The limit argument for forward pagination." first: Int "The limit argument for backward pagination." last: Int "The cursor argument for forward pagination." after: String "The cursor argument for backward pagination." before: String): PermissionConnection!
    "The list of all globally available executor secrets."
    executorSecrets("The scope for which secrets shall be returned." scope: ExecutorSecretScope! "Only return N records." first: Int = 50 "Opaque cursor for pagination." after: String): ExecutorSecretConnection!
    "Retrieve active executor compute instances."
    executors("An (optional) search query that searches over the hostname, queue name, os, architecture, and\nversion properties." query: String "Whether to show only executors that have sent a heartbeat in the last fifteen minutes." active: Boolean "Returns the first n executors." first: Int = 50 "Opaque pagination cursor." after: String): ExecutorConnection!
    "Returns true if executors have been configured on the Sourcegraph instance.\nThis is based on heuristics and doesn't necessarily mean that they would be\nworking."
    areExecutorsConfigured: Boolean!
    "Get a single team by name. Returns null if not found."
    team(name: String!): Team
    "Get the global list of all root teams. (Those without a parent team)."
    teams("Returns the first n teams from the list." first: Int "Opaque pagination cursor." after: String "Search can be used to do a text-search over the team names." search: String "Do not include any teams that have this ancestor in parent-team relationship.\nThis includes the team with the ID mentioned (that is a team is considered\nits own ancestor)." exceptAncestor: ID "If set to true, child teams (ones that have parent set) are also returned.\nIf not specified, the default behavior is to only include top-level teams." includeChildTeams: Boolean): TeamConnection!
    "List access requests."
    accessRequests(status: AccessRequestStatus "Returns the first n access requests from the list." first: Int last: Int after: String before: String): AccessRequestConnection!
    "Repository key-value pair metadata"
    repoMeta: RepoMetadata
    "List of all configured code hosts on this instance.\n\nSite-admin only."
    codeHosts(first: Int = 50 after: String search: String): CodeHostConnection!
    "Returns the outbound webhooks registered within Sourcegraph, optionally filtered by\nevent type and scope. To filter by scope, event type is also required. If the event\ntype and scope are both omitted, all webhooks are returned.\n\nOnly site admins have access to this query."
    outboundWebhooks(first: Int = 50 after: String eventType: String scope: String): OutboundWebhookConnection!
    "Returns all possible outbound webhook event types.\n\nOnly site admins have access to this query."
    outboundWebhookEventTypes: [OutboundWebhookEventType!]!
    "A list of batch changes."
    batchChanges("Returns the first n batch changes from the list." first: Int = 50 "Opaque pagination cursor." after: String "Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`." state: BatchChangeState "Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it." states: [BatchChangeState!] "Only include batch changes that the viewer can administer." viewerCanAdminister: Boolean): BatchChangeConnection!
    "Looks up a batch change by namespace and name."
    batchChange("The namespace where the batch change lives." namespace: ID! "The batch changes name." name: String!): BatchChange
    "Stats on all the changesets across the instance for Batch Changes."
    globalChangesetsStats: GlobalChangesetsStats!
    "All globally configured code hosts usable with Batch Changes."
    batchChangesCodeHosts("Returns the first n code hosts from the list." first: Int = 50 "Opaque pagination cursor." after: String): BatchChangesCodeHostConnection!
    "Returns a list of available bulk operations for changesets belonging to a batch change."
    availableBulkOperations("The batch change the selected changesets belong to." batchChange: ID! "The changesets to query for bulk operations applicable to." changesets: [ID!]!): [BulkOperationType!]!
    "A list of batch specs.\n\n\nSite-admin only.\n\nExperimental: This API is likely to change in the future."
    batchSpecs("Returns the first n batch specs from the list." first: Int = 50 "Opaque pagination cursor." after: String "Include locally executed (i.e. with src-cli) batch specs in the list of specs returned." includeLocallyExecutedSpecs: Boolean "Exclude the empty batch specs that are initially created and applied to draft batch changes." excludeEmptySpecs: Boolean): BatchSpecConnection!
    "Determines if a batch change credential is authorized for a code host."
    checkBatchChangesCredential(batchChangesCredential: ID!): EmptyResponse!
    "Takes the batch spec as input and resolves the workspaces for it, without persisting them.\nThis endpoint is used in src-cli to resolve workspaces."
    resolveWorkspacesForBatchSpec(batchSpec: String!): [ResolvedBatchSpecWorkspace!]!
    "Returns the max number of changesets are allowed for License that does not have the batch change feature."
    maxUnlicensedChangesets: Int!
    "Query precise code intelligence indexes."
    preciseIndexes("If supplied, only precise indexes for the given repository will be returned." repo: ID "If supplied, only precise indexes that match the given terms by their state,\nrepository name, commit, root, and indexer fields will be returned.." query: String "If supplied, only precise indexes in one of the provided states are returned." states: [PreciseIndexState!] "If supplied, only precise indexes created by an indexer with the given key are returned." indexerKey: String "If supplied, only precise indexes that are a dependency of the specified index are returned." dependencyOf: ID "If supplied, only precise indexes that are a dependent of the specified index are returned." dependentOf: ID "When specified, merges the list of existing uploads with data from\nuploads that have been deleted but for which audit logs still exist.\nOnly makes sense when state filter is unset or equal to 'DELETED'." includeDeleted: Boolean "If specified, this limits the number of results per request." first: Int "If specified, this indicates that the request should be paginated and to fetch results starting\nat this cursor.\n\nA future request can be made for more results by passing in the 'PreciseIndexConnection.pageInfo.endCursor'\nthat is returned." after: String): PreciseIndexConnection!
    "Provides a summary of code intelligence on the instance."
    codeIntelSummary: CodeIntelSummary!
    "A list of unique indexer keys queryable via the `preciseIndexes.indexerKey` filter."
    indexerKeys("If supplied, only indexers associated with the given repository will be returned." repo: ID): [String!]!
    "Return the currently set auto-indexing job inference script. Does not return\nthe value stored in the environment variable or the default shipped scripts,\nonly the value set via UI\/GraphQL."
    codeIntelligenceInferenceScript: String!
    "Return (but do not enqueue) descriptions of auto indexing jobs at the current revision."
    inferAutoIndexJobsForRepo(repository: ID! rev: String script: String): InferAutoIndexJobsResult!
    "Returns precise code intelligence configuration policies that control data retention\nand (if enabled) auto-indexing behavior."
    codeIntelligenceConfigurationPolicies("If repository is supplied, then only the configuration policies that apply to\nrepository are returned. If repository is not supplied, then all policies are\nreturned." repository: ID "An (optional) search query that searches over the name property." query: String "If set to true, then only configuration policies with SCIP data retention enabled are returned.\nIf set to false, then configuration policies with SCIP data retention enabled are filtered out." forDataRetention: Boolean "If set to true, then only configuration policies with indexing enabled are returned.\nIf set to false, then configuration policies with indexing enabled are filtered out." forIndexing: Boolean "If set to true, then only configuration policies with embeddings enabled are returned.\nIf set to false, then configuration policies with embeddings enabled are filtered out." forEmbeddings: Boolean "If set to true, then only protected configuration policies are returned.\nIf set to false, then only un-protected configuration policies are returned.\nIf unset, policies are returned regardless if they're protected or not." protected: Boolean "When specified, indicates that this request should be paginated and\nthe first N results (relative to the cursor) should be returned. i.e.\nhow many results to return per page." first: Int "When specified, indicates that this request should be paginated and\nto fetch results starting at this cursor.\n\nA future request can be made for more results by passing in the\n'CodeIntelligenceConfigurationPolicyConnection.pageInfo.endCursor'\nthat is returned." after: String): CodeIntelligenceConfigurationPolicyConnection!
    "The set of repositories that match the given glob pattern. This resolver is used by the UI to\npreview what repositories match a code intelligence policy in a given repository."
    previewRepositoryFilter("A set of patterns matching the name of the matching repository." patterns: [String!]! "When specified, indicates that this request should return the first N items." first: Int): RepositoryFilterPreview!
    "Gets the progress of the current and historic precise ranking jobs."
    rankingSummary: GlobalRankingSummary!
    "Return known vulnerabilities."
    vulnerabilities("The maximum number of results to return." first: Int "If supplied, indicates which results to skip over during pagination." after: String): VulnerabilityConnection!
    "Return known vulnerability matches."
    vulnerabilityMatches("The maximum number of results to return." first: Int "If supplied, indicates which results to skip over during pagination." after: String "Programming language of the vulnerability." language: String "Severity of the vulnerability." severity: String "The name of the repository to filter by." repositoryName: String): VulnerabilityMatchConnection!
    "Return known vulnerability matches grouped by repository."
    vulnerabilityMatchesCountByRepository("The maximum number of results to return." first: Int "If supplied, indicates which results to skip over during pagination." after: String "A string pattern that could match the name of a repository." repositoryName: String): VulnerabilityMatchCountByRepositoryConnection!
    "Returns a count of the vulnerability matches grouped by severity."
    vulnerabilityMatchesSummaryCounts: VulnerabilityMatchesSummaryCount!
    "Return dashboards visible to the authenticated user."
    insightsDashboards(first: Int after: String id: ID): InsightsDashboardConnection!
    "Return all insight views visible to the authenticated user."
    insightViews(first: Int after: String id: ID "Allow you to exclude subset of insights by their ids." excludeIds: [ID!] "Allow you to search insight views by their title or data series labels." find: String isFrozen: Boolean filters: InsightViewFiltersInput seriesDisplayOptions: SeriesDisplayOptionsInput): InsightViewConnection!
    "Generate an ephemeral time series for a Search based code insight, generally for the purposes of live preview."
    searchInsightLivePreview(input: SearchInsightLivePreviewInput!): [SearchInsightLivePreviewSeries!]!
    "Generate an ephemeral set of time series for a code insight, generally for the purposes of live preview."
    searchInsightPreview(input: SearchInsightPreviewInput!): [SearchInsightLivePreviewSeries!]!
    "Retrieve information about queued insights series and their breakout by status. Restricted to admins only."
    insightSeriesQueryStatus: [InsightSeriesQueryStatus!]!
    "Retrieve information about an insight view and its status. Restricted to admins only."
    insightViewDebug(id: ID!): InsightViewDebug
    "Validates a query for determining insight scope and returns the number of repositories it matches for the caller."
    validateScopedInsightQuery(query: String!): ScopedInsightQueryPayload!
    "Returns the number of repositories matched given a valid query."
    previewRepositoriesFromQuery(query: String!): RepositoryPreviewPayload!
    "Fetch information related to the queue of backfilling insights."
    insightAdminBackfillQueue("Returns the first n queue items from the list." first: Int "Returns the last n queue items from the list." last: Int "An opaque cursor that is used for pagination." after: String "An opaque cursor that is used for pagination." before: String "How to order the list." orderBy: BackfillQueueOrderBy = STATE "Sort direction." descending: Boolean = false "List of states to filter list by." states: [InsightQueueItemState!] "Text to filter the list, checking the Insight Title and Series Label" textSearch: String): InsightBackfillQueueItemConnection!
    "The repositories a user is authorized to access with the given permission.\nThis isn’t defined in the User type because we store permissions for users\nthat don’t yet exist (i.e. late binding). Only one of \"username\" or \"email\"\nis required to identify a user."
    authorizedUserRepositories("The username." username: String "One of the email addresses." email: String "Permission that the user has on the repositories." perm: RepositoryPermission = READ "Number of repositories to return after the given cursor." first: Int! "Opaque pagination cursor." after: String): RepositoryConnection!
    "Returns a list of usernames or emails that have associated pending permissions.\nThe returned list can be used to query authorizedUserRepositories for pending permissions."
    usersWithPendingPermissions: [String!]!
    "INTERNAL ONLY: Returns a list of the types of authz providers that have been configured and will be used for\ndetermining which repositories the user has access to."
    authzProviderTypes: [String!]!
    "Returns a list of recent permissions sync jobs for a given set of parameters."
    permissionsSyncJobs("Number of jobs returned. Maximum number of returned jobs is 500. Up to 100 jobs are returned by default." first: Int "The number of nodes to return starting from the end (latest).\nNote: Use either last or first (see above) in the query. Setting both will\nreturn an error." last: Int "Opaque pagination cursor to be used when paginating forwards that may be also used\nin conjunction with \"first\" to return the first N nodes." after: String "Opaque pagination cursor to be used when paginating backwards that may be\nalso used in conjunction with \"last\" to return the last N nodes." before: String "Optional filter for PermissionsSyncJobReasonGroup." reasonGroup: PermissionsSyncJobReasonGroup "Optional filter for PermissionsSyncJobState." state: PermissionsSyncJobState "Type of search for permissions sync jobs: user or repository." searchType: PermissionsSyncJobsSearchType "Term used to search for permissions sync jobs." query: String "Optional filter to find permissions sync jobs for a user. Please provide either this or repoID, but not both." userID: ID "Optional filter to find permissions sync jobs for a repository. Please provide either this or userID, but not both." repoID: ID "Optional filter to filter only partially successful sync jobs." partial: Boolean): PermissionsSyncJobsConnection!
    "Returns various permissions syncing statistics."
    permissionsSyncingStats: PermissionsSyncingStats!
    "Returns a list of Bitbucket Project permissions sync jobs for a given set of parameters."
    bitbucketProjectPermissionJobs("Bitbucket project keys which sync jobs are queried" projectKeys: [String!] "Job status, one of the following: queued, processing, completed, errored, failed." status: String "Number of jobs returned. Maximum number of returned jobs is 500. 100 jobs are returned by default." count: Int): BitbucketProjectPermissionJobs!
    "A list of monitors. Site-admin only."
    monitors("Returns the first n monitors from the list." first: Int! "Opaque pagination cursor." after: String): MonitorConnection!
    "All configured GitHub Apps, optionally filtered by the domain in which they are used."
    gitHubApps(domain: GitHubAppDomain): GitHubAppConnection!
    "Looks up a GitHub App by its ID."
    gitHubApp(id: ID!): GitHubApp
    "Looks up a GitHub App by its AppID and BaseURL."
    gitHubAppByAppID(appID: Int! baseURL: String!): GitHubApp
    "Checks whether the given feature is enabled on Sourcegraph."
    enterpriseLicenseHasFeature(feature: String!): Boolean!
    "Parse license key and returns features alongside its availability.\nIf licenseKey is omitted, uses current instance license."
    licenseInfo(licenseKey: String): LicenseInfo!
    "Queries that are only used on Sourcegraph.com.\n\nFOR INTERNAL USE ONLY."
    dotcom: DotcomQuery!
    "All available user-defined search contexts. Excludes auto-defined contexts."
    searchContexts("Returns the first n search contexts from the list." first: Int = 50 "Opaque pagination cursor." after: String "Query to filter the search contexts by spec." query: String "Include search contexts matching the provided namespaces. A union of all matching search contexts is returned.\nID can either be a user ID, org ID, or nil to match instance-level contexts. Empty namespaces list\ndefaults to returning all available search contexts.\nExample: `namespaces: [user1, org1, org2, nil]` will return search contexts created by user1 + contexts\ncreated by org1 + contexts created by org2 + all instance-level contexts." namespaces: [ID] = [  ] "Sort field.\nDespite the value, the results are always sorted with the global context first,\nuser's default context next, followed by the user's starred contexts,\nfollowed by the rest of the contexts.\nThis controls the order of these internal groups." orderBy: SearchContextsOrderBy = SEARCH_CONTEXT_SPEC "Sort direction." descending: Boolean = false): SearchContextConnection!
    "Fetch search context by spec (global, @username, @username\/ctx, etc.)."
    searchContextBySpec(spec: String!): SearchContext
    "Determines whether the search context is within the set of search contexts available to the current user.\nThe set consists of contexts created by the user, contexts created by the users' organizations, and instance-level contexts."
    isSearchContextAvailable(spec: String!): Boolean!
    "Gets the default search context for the current user. This context is guaranteed to be available to the user."
    defaultSearchContext: SearchContext
    "All available notebooks."
    notebooks("Returns the first n notebooks from the list." first: Int = 50 "Opaque pagination cursor." after: String "Query to filter notebooks by title and blocks content." query: String "Filter to notebooks made by a single creator." creatorUserID: ID "Filter to notebooks that were starred by the user." starredByUserID: ID "Filter to notebooks associated with a specific namespace (user or org)." namespace: ID "Sort field." orderBy: NotebooksOrderBy = NOTEBOOK_UPDATED_AT "Sort direction." descending: Boolean = false): NotebookConnection!
    "Computes valus from search results."
    compute("The search query." query: String = ""): [ComputeResult!]!
    "Returns information about aggregating the potential results of a search query."
    searchQueryAggregate(query: String! patternType: SearchPatternType!): SearchQueryAggregate!
    "Experimental: Searches a repository for similar code and text results using embeddings.\nWe separated code and text results because text results tended to always feature at the top of the combined results,\nand didn't leave room for the code."
    embeddingsSearch("The repository to search." repo: ID! "The query used for embeddings search." query: String! "The number of code results to return." codeResultsCount: Int! "The number of text results to return. Text results contain Markdown files and similar file types primarily used for writing documentation." textResultsCount: Int!): EmbeddingsSearchResults!
    "Experimental: Searches a set of repositories for similar code and text results using embeddings.\nWe separated code and text results because text results tended to always feature at the top of the combined results,\nand didn't leave room for the code."
    embeddingsMultiSearch("The repository to search." repos: [ID!]! "The query used for embeddings search." query: String! "The number of code results to return." codeResultsCount: Int! "The number of text results to return. Text results contain Markdown files and similar file types primarily used for writing documentation." textResultsCount: Int!): EmbeddingsSearchResults!
    "Experimental: Determines whether the given query requires further context before it can be answered.\nFor example:\n  - \"What are Sourcegraph Notebooks\" requires additional information from the Sourcegraph repository (Notebooks Markdown docs, etc.).\n  - \"Translate the previous code to Typescript\" does not need additional context since it is referring to the existing context (or conversation)."
    isContextRequiredForChatQuery(query: String!): Boolean!
    "Experimental: Repo embedding jobs list."
    repoEmbeddingJobs("Number of jobs returned. Up to 100 jobs are returned by default." first: Int "The number of nodes to return starting from the end (latest).\nNote: Use either last or first (see above) in the query. Setting both will\nreturn an error." last: Int "Opaque pagination cursor to be used when paginating forwards that may be also used\nin conjunction with \"first\" to return the first N nodes." after: String "Opaque pagination cursor to be used when paginating backwards that may be\nalso used in conjunction with \"last\" to return the last N nodes." before: String "Filter by the name of the repository." query: String "Filter by the state of the job." state: String): RepoEmbeddingJobsConnection!
    "EXPERIMENTAL: Get pieces of context related to the query from a set of repositories."
    getCodyContext("The repositories to search." repos: [ID!]! "A natural language query string." query: String! "The number of code results to return." codeResultsCount: Int! "The number of text results to return. Text results contain Markdown files and similar file types primarily used for writing documentation." textResultsCount: Int!): [CodyContextResult!]!
    "codeownersIngestedFiles returns all existing manually ingested codeowners files."
    codeownersIngestedFiles(first: Int after: Int): CodeownersIngestedFileConnection!
    "List all ownership signal configurations"
    ownSignalConfigurations: [OwnSignalConfiguration!]!
    "Returns ownership stats for the whole Sourcegraph instance"
    instanceOwnershipStats: OwnershipStats!
    "Returns a string of completion responses"
    completions(input: CompletionsInput! fast: Boolean = false): String!
    "EXPERIMENTAL: Searches the instances indexed code for code matching snippet."
    snippetAttribution(snippet: String! first: Int): SnippetAttributionConnection!
    "(experimental) Returns onboarding tour content."
    onboardingTourContent: OnboardingTour!
}

"Query block allows performing inline search queries within a notebook."
type QueryBlock {
    "ID of the block."
    id: String!
    "A Sourcegraph search query string."
    queryInput: String!
}

"The result for Mutation.randomizeUserPassword."
type RandomizeUserPasswordResult {
    "The reset password URL that the user must visit to sign into their account again. If the builtin\nusername-password authentication provider is not enabled, this field's value is null.\n\nIf email sending (SMTP) is configured on this instance, an email containing this URL\nwill also be sent to the primary email address associated with the user."
    resetPasswordURL: String
    "If true, then an email with the password reset URL was sent to the primary email\naddress associated with the user. If false, email sending (SMTP) might not be configured\non this instance, or an error may have occurred - check the error logs with log scope\n'randomizeUserPassword' for more details."
    emailSent: Boolean!
}

"A range inside a file. The start position is inclusive, and the end position is exclusive."
type Range {
    "The start position of the range (inclusive)."
    start: Position!
    "The end position of the range (exclusive)."
    end: Position!
}

"Summary of one precise ranking job."
type RankingSummary {
    "Identifier of the current ranking job. Corresponds to values in the site configuration."
    graphKey: String!
    "True if the output of this ranking job is currently visible to the Zoekt indexserver."
    visibleToZoekt: Boolean!
    "Progress of the path mapping stage."
    pathMapperProgress: RankingSummaryProgress!
    "Progress of the reference mapping stage."
    referenceMapperProgress: RankingSummaryProgress!
    "Progress of the reducer stage."
    reducerProgress: RankingSummaryProgress
}

"Progress of one stage of a precise ranking job."
type RankingSummaryProgress {
    "When the job started."
    startedAt: DateTime!
    "When the job completed (if finished)."
    completedAt: DateTime
    "How many records have been processed."
    processed: Int!
    "How many total items will be processed."
    total: Int!
}

"A signal derived from recent code contributors."
type RecentContributorOwnershipSignal {
    "Descriptive title to display in the UI for the determination."
    title: String!
    "More detailed description to display in the UI for the determination."
    description: String!
}

"A signal derived from recent code file views."
type RecentViewOwnershipSignal {
    "Descriptive title to display in the UI for the determination."
    title: String!
    "More detailed description to display in the UI for the determination."
    description: String!
}

"Recorded command is a Git command and its metadata which was run for particular repo."
type RecordedCommand {
    "When the command started its execution."
    start: DateTime!
    "Command run time in seconds."
    duration: Float!
    "The command itself (e.g. \"git fetch\")."
    command: String!
    "Directory in which the command has been run."
    dir: String!
    "Path to command executable (git executable in most cases)."
    path: String!
}

"RecordedCommandConnection is a connection containing a list of RecordedCommand nodes."
type RecordedCommandConnection {
    "A list of recorded commands for given repository."
    nodes: [RecordedCommand!]!
    "The total number of recorded commands for given repository in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"A reference to another Sourcegraph instance."
type Redirect {
    "The URL of the other Sourcegraph instance."
    url: String!
}

"Input object for adding insight view to dashboard."
input RemoveInsightViewFromDashboardInput {
    "ID of the insight view to remove from the dashboard"
    insightViewId: ID!
    "ID of the dashboard."
    dashboardId: ID!
}

"Stats on all the changesets that have been applied to this repository by batch changes."
type RepoChangesetsStats {
    "The count of unpublished changesets."
    unpublished: Int!
    "The count of draft changesets."
    draft: Int!
    "The count of open changesets."
    open: Int!
    "The count of merged changesets."
    merged: Int!
    "The count of closed changesets."
    closed: Int!
    "The count of all changesets."
    total: Int!
}

"A corruption log entry that that records the time of when corruption was detected and a reason why the repo is regarded\nas corrupt"
type RepoCorruptionLog {
    "The time at which the repository was detected to be corrupt"
    timestamp: DateTime!
    "The reason why this repository was regarded as corrupt"
    reason: String!
}

"A repo embedding job."
type RepoEmbeddingJob implements Node {
    "Unique node ID."
    id: ID!
    "State of a repo embedding job."
    state: RepoEmbeddingJobState!
    "Failure message for failed job."
    failureMessage: String
    "Time when repo embedding job was queued."
    queuedAt: DateTime!
    "Time when repo embedding job processing was started."
    startedAt: DateTime
    "Time when repo embedding job processing finished."
    finishedAt: DateTime
    "Time after which repo embedding job processing should be started."
    processAfter: DateTime
    "Number of repo embedding job processing resets."
    numResets: Int!
    "Number of repo embedding job processing failures."
    numFailures: Int!
    "Time of last heartbeat of a repo embedding job processing."
    lastHeartbeatAt: DateTime
    "Hostname of a worker on which repo embedding job is processing."
    workerHostname: String!
    "Flag showing that given repo embedding job should be canceled instead of being processed."
    cancel: Boolean!
    "The embedded repository."
    repo: Repository
    "The revision at which the repo was embedded."
    revision: GitCommit
    "Statistics about the embeddings index job.\nThis will be updated periodically while the embeddings job is processing."
    stats: RepoEmbeddingsStats!
}

"State types of repo embedding sync jobs."
enum RepoEmbeddingJobState {
    QUEUED
    PROCESSING
    FAILED
    ERRORED
    COMPLETED
    CANCELED
}

"Repo embedding jobs."
type RepoEmbeddingJobsConnection implements Connection {
    "Repo embedding jobs."
    nodes: [RepoEmbeddingJob!]!
    "The total number of jobs in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: ConnectionPageInfo!
}

"Statistics about an embeddings index job.\nThis will be updated periodically while the embeddings job is processing."
type RepoEmbeddingsStats {
    "The number of files scheduled to be embedded."
    filesScheduled: Int!
    "The number of files we generated embeddings for.\nThis will be updated periodically while the embeddings job is processing."
    filesEmbedded: Int!
    "The number of files skipped.\nThis will be updated periodically while the embeddings job is processing."
    filesSkipped: Int!
}

"Repo key-value pair metadata"
type RepoMetadata {
    "Returns paginated list of repo metadata distinct keys matching a query"
    keys(query: String "Pagination paramters" first: Int last: Int after: String before: String): RepoMetadataKeyOrValueConnection!
    "Repo metadata key"
    key(key: String!): RepoMetadataKeyResult
}

"Repo metadata key or value connection result`"
type RepoMetadataKeyOrValueConnection {
    "Total count of repo key-value pair metadata"
    totalCount: Int!
    "A list of repo key-value pair metadata"
    nodes: [String!]!
    "Pagination information."
    pageInfo: BidirectionalPageInfo!
}

"Repo metadata key result"
type RepoMetadataKeyResult {
    "Returns paginated list of repo metadata distinct values matching a query"
    values(query: String "Pagination paramters" first: Int last: Int after: String before: String): RepoMetadataKeyOrValueConnection!
}

"A repository is a Git source control repository that is mirrored from some origin code host."
type Repository implements Node & GenericSearchResultInterface {
    "The repository's unique ID."
    id: ID!
    "The repository's name, as a path with one or more components. It conventionally consists of\nthe repository's hostname and path (joined by \"\/\"), minus any suffixes (such as \".git\").\nExamples:\n- github.com\/foo\/bar\n- my-code-host.example.com\/myrepo\n- myrepo"
    name: String!
    "DEPRECATED: Use name."
    uri: String! @deprecated(reason: "Use name.")
    "The source of this repository from where it was imported \/ converted."
    sourceType: RepositoryType!
    "The repository's description."
    description: String!
    "The primary programming language in the repository."
    language: String!
    "DEPRECATED: This field is unused in known clients.\nThe date when this repository was created on Sourcegraph."
    createdAt: DateTime!
    "DEPRECATED: This field is unused in known clients.\nThe date when this repository's metadata was last updated on Sourcegraph."
    updatedAt: DateTime
    "Returns information about the given commit in the repository, or null if no commit exists with the given rev."
    commit("The Git revision specifier (revspec) for the commit." rev: String! "Optional input revspec used to construct non-canonical URLs and other \"friendly\" field values. Used by\nclients that must ensure consistency of revision resolution within a session\/request (so they use full\nSHAs) but also preserve the user input rev (for user friendliness)." inputRevspec: String): GitCommit
    "EXPERIMENTAL: Returns infomration about the given changelist of the perforce depot, or null if\nno changelist exists with the given cid or it is not a perforce depot."
    changelist(cid: String!): PerforceChangelist
    "The first commit inside the repo"
    firstEverCommit: GitCommit
    "Information and status related to mirroring, if this repository is a mirror of another repository (e.g., on\nsome code host). In this case, the remote source repository is external to Sourcegraph and the mirror is\nmaintained by the Sourcegraph site (not the other way around)."
    mirrorInfo: MirrorRepositoryInfo!
    "Information about this repository from the external service that it originates from (such as GitHub, GitLab,\nPhabricator, etc.)."
    externalRepository: ExternalRepository!
    "Whether the repository is a fork."
    isFork: Boolean!
    "Whether the repository has been archived."
    isArchived: Boolean!
    "Whether the repository is private."
    isPrivate: Boolean!
    "Lists all external services which yield this repository."
    externalServices("Returns the first n external services from the list." first: Int): ExternalServiceConnection!
    "Whether the repository is currently being cloned."
    cloneInProgress: Boolean! @deprecated(reason: "use Repository.mirrorInfo.cloneInProgress instead")
    "Information about the text search index for this repository, or null if text search indexing\nis not enabled or supported for this repository."
    textSearchIndex: RepositoryTextSearchIndex
    "The URL to this repository."
    url: String!
    "The URLs to this repository on external services associated with it."
    externalURLs: [ExternalLink!]!
    "The repository's default Git branch (HEAD symbolic ref). If the repository is currently being cloned or is\nempty, this field will be null."
    defaultBranch: GitRef
    "The repository's Git refs."
    gitRefs("Returns the first n Git refs from the list." first: Int "Return Git refs whose names match the query." query: String "Return only Git refs of the given type.\nKnown issue: It is only supported to retrieve Git branch and tag refs, not\nother Git refs." type: GitRefType "Ordering for Git refs in the list." orderBy: GitRefOrder "Ordering is an expensive operation that doesn't scale for lots of\nreferences. If this is true we fallback on not ordering. This should\nnever be false in interactive API requests." interactive: Boolean = true): GitRefConnection!
    "The repository's Git branches."
    branches("Returns the first n Git branches from the list." first: Int "Return Git branches whose names match the query." query: String "Ordering for Git branches in the list." orderBy: GitRefOrder "Ordering is an expensive operation that doesn't scale for lots of\nreferences. If this is true we fallback on not ordering. This should\nnever be false in interactive API requests." interactive: Boolean = true): GitRefConnection!
    "The repository's Git tags."
    tags("Returns the first n Git tags from the list." first: Int "Return Git tags whose names match the query." query: String): GitRefConnection!
    "A Git comparison in this repository between a base and head commit."
    comparison("The base of the diff (\"old\" or \"left-hand side\"), or \"HEAD\" if not specified." base: String "The head of the diff (\"new\" or \"right-hand side\"), or \"HEAD\" if not specified." head: String "Attempt to fetch missing revisions from remote if they are not found" fetchMissing: Boolean = true): RepositoryComparison!
    "The repository's contributors."
    contributors("The Git revision range to compute contributors in." revisionRange: String "The date after which to count contributions." afterDate: String "Return contributors to files in this path." path: String "Returns the first n contributors from the list." first: Int last: Int after: String before: String): RepositoryContributorConnection!
    "Whether the viewer has admin privileges on this repository."
    viewerCanAdminister: Boolean!
    "A markdown string that is rendered prominently."
    label: Markdown!
    "A markdown string of that is rendered less prominently."
    detail: Markdown!
    "The result previews of the result."
    matches: [SearchResultMatch!]!
    "Information and status related to the commit graph of this repository calculated\nfor use by code intelligence features."
    codeIntelligenceCommitGraph: CodeIntelligenceCommitGraph!
    "The star count the repository has in the code host."
    stars: Int!
    "A set of user-defined key-value pairs associated with the repo."
    keyValuePairs: [KeyValuePair!]! @deprecated(reason: "Use repo.metadata instead. This field is a deprecated and will be removed in a future release.")
    "A set of user-defined key-value pairs metadata associated with the repo."
    metadata: [KeyValuePair!]!
    "The size of repo when cloned on disk"
    diskSizeBytes: BigInt
    "Returns true if embeddings for the repo are generated."
    embeddingExists: Boolean!
    "Returns a list of all recorded commands for given repository."
    recordedCommands("Maximum number of recorded commands returned.\nIf a query specifies a limit higher than 40, it will be capped at 40.\nThe default value is 40. This prevents returning an excessive number\nof recorded commands for performance reasons." limit: Int = 40 "Skips initial \"offset\" number of recorded commands.\n(Default: 0)" offset: Int = 0): RecordedCommandConnection!
    "Stats on all the changesets that have been created in this repository by batch\nchanges."
    changesetsStats: RepoChangesetsStats!
    "A list of batch changes that have applied a changeset to this repository."
    batchChanges("Returns the first n batch changes from the list." first: Int = 50 "Opaque pagination cursor." after: String "Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`." state: BatchChangeState "Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it." states: [BatchChangeState!] "Only include batch changes that the viewer can administer." viewerCanAdminister: Boolean): BatchChangeConnection!
    "A diff stat for all the changesets that have been applied to this repository\nby batch changes."
    batchChangesDiffStat: DiffStat!
    "Gets the indexing configuration associated with the repository."
    indexConfiguration: IndexConfiguration
    "Provides a summary of the most recent upload and index status."
    codeIntelSummary: CodeIntelRepositorySummary!
    "The set of git objects that match the given git object type and glob pattern.\nThis resolver is used by the UI to preview what names match a code intelligence\npolicy in a given repository."
    previewGitObjectFilter("The type of Git object described by the configuration policy." type: GitObjectType! "A pattern matching the name of the matching Git object." pattern: String! "When specified, indicates that this request should return the first N items." first: Int "When specified, the total number of matching Git objects younger than this value\nwill be returned along with the total number of matching objects. This does not\naffect the set of objects returned as items." countObjectsYoungerThanHours: Int): GitObjectFilterPreview!
    "A list of authorized users to access this repository with the given permission.\nThis API currently only returns permissions from the Sourcegraph provider, i.e.\n\"permissions.userMapping\" in site configuration."
    authorizedUsers("Permission that the user has on this repository." permission: RepositoryPermission = READ "Number of users to return after the given cursor." first: Int! "Opaque pagination cursor." after: String): UserConnection!
    "The permissions information of the repository for the authenticated user.\nIt is null when there is no permissions data stored for the repository."
    permissionsInfo: PermissionsInfo
    "Returns all embedding jobs for the repo."
    embeddingJobs("Number of jobs returned. Up to 100 jobs are returned by default." first: Int "The number of nodes to return starting from the end (latest).\nNote: Use either last or first (see above) in the query. Setting both will\nreturn an error." last: Int "Opaque pagination cursor to be used when paginating forwards that may be also used\nin conjunction with \"first\" to return the first N nodes." after: String "Opaque pagination cursor to be used when paginating backwards that may be\nalso used in conjunction with \"last\" to return the last N nodes." before: String "Filter by the state of the job." state: String): RepoEmbeddingJobsConnection!
    "A file containing manually ingested codeowners data, if any. Null if no data has been uploaded."
    ingestedCodeowners: CodeownersIngestedFile
}

"The differences between two concrete Git commits in a repository."
type RepositoryComparison {
    "The repository that is the base (left-hand side) of this comparison."
    baseRepository: Repository!
    "The repository that is the head (right-hand side) of this comparison. Cross-repository\ncomparisons are not yet supported, so this is always equal to\nRepositoryComparison.baseRepository."
    headRepository: Repository!
    "The range that this comparison represents."
    range: GitRevisionRange!
    "The commits in the comparison range, excluding the base and including the head."
    commits("Return the first n commits from the list." first: Int "Filter to only the commits that modify files that match path.\nPath can be either a file or a containing directory." path: String): GitCommitConnection!
    "The file diffs for each changed file."
    fileDiffs("Return the first n file diffs from the list." first: Int "Return file diffs after the given cursor." after: String "A list of paths or directories used to filter the diffs" paths: [String!]): FileDiffConnection!
}

"Either a preview or an actual repository comparison."
union RepositoryComparisonInterface = RepositoryComparison | PreviewRepositoryComparison

"Deprecated! A list of repositories."
type RepositoryConnection {
    "A list of repositories."
    nodes: [Repository!]!
    "The total count of repositories in the connection. This total count may be larger\nthan the number of nodes in this object when the result is paginated.\nThis requires admin permissions and will return null for all non-admin users.\nIn some cases, the total count can't be computed quickly; if so, it is null. Pass\nprecise: true to always compute total counts even if it takes a while."
    totalCount(precise: Boolean = false): Int
    "Pagination information."
    pageInfo: PageInfo!
}

"A contributor to a repository."
type RepositoryContributor {
    "The personal information for the contributor."
    person: Person!
    "The number of contributions made by this contributor."
    count: Int!
    "The repository in which the contributions occurred."
    repository: Repository!
    "Commits by the contributor."
    commits("Return the first n commits." first: Int): GitCommitConnection!
}

"A list of contributors to a repository."
type RepositoryContributorConnection {
    "A list of contributors to a repository."
    nodes: [RepositoryContributor!]!
    "The total count of contributors in the connection, if available. This total count may be larger than the\nnumber of nodes in this object when the result is paginated."
    totalCount: Int!
    "Pagination information."
    pageInfo: BidirectionalPageInfo!
}

"A decorated connection of repositories resulting from 'previewRepositoryFilter'."
type RepositoryFilterPreview {
    "A list of repositories composing the current page."
    nodes: [CodeIntelRepository!]!
    "The total number of repositories in this result set."
    totalCount: Int!
    "If every repository currently on the instance is matched by this filter."
    matchesAllRepos: Boolean!
    "The maximum number of repository matches a single policy can make."
    limit: Int
    "The number of repositories matching the given filter. This value exceeds the\nvalue of totalCount of the result when totalMatches > limit."
    totalMatches: Int!
}

"RepositoryOrderBy enumerates the ways a repositories list can be ordered."
enum RepositoryOrderBy {
    REPOSITORY_NAME
    REPO_CREATED_AT
    "deprecated (use the equivalent REPOSITORY_CREATED_AT)"
    REPOSITORY_CREATED_AT
    SIZE
}

"Different repository permission levels."
enum RepositoryPermission {
    READ
}

"Information about the number of repositories matched from a query"
type RepositoryPreviewPayload {
    "The query used to find number of repository matches."
    query: String!
    "The number of repositories matched."
    numberOfRepositories: Int
}

"A repository or a link to another Sourcegraph instance location where this repository may be located."
union RepositoryRedirect = Repository | Redirect

"A custom repository scope for an insight data series."
input RepositoryScopeInput {
    "The list of repositories included in this scope."
    repositories: [String!]!
    "A search query to select repositories for this scope."
    repositoryCriteria: String
}

"Describes a scope of repositories, this type is used for both the search based scopes and all repositories"
type RepositorySearchScope {
    "The user provided search used to generate the list of repositories the insight runs over."
    search: String!
    "Indicates if this search scope represents all repositories"
    allRepositories: Boolean!
}

"FOR INTERNAL USE ONLY: A repository statistic"
type RepositoryStats {
    "The amount of bytes stored in .git directories"
    gitDirBytes: BigInt!
    "The number of lines indexed"
    indexedLinesCount: BigInt!
    "The number of all repositories in the instance, without soft-deleted or blocked repositories."
    total: Int!
    "The number of cloned repositories in the instance. This number might be\nhigher than 'total', if soft-deleted repositories haven't been cleaned up\nyet."
    cloned: Int!
    "The number of repositories in the instance that are currently being cloned."
    cloning: Int!
    "The number of repositories in the instance that not cloned yet."
    notCloned: Int!
    "The number of repositories where initial cloning or subsequent fetching resulted in an error."
    failedFetch: Int!
    "The number of indexed repositories"
    indexed: Int!
    "The number of repositories that are currently corrupt"
    corrupted: Int!
    "The number of repositories that have embeddings"
    embedded: Int!
}

"Information about a repository's text search index."
type RepositoryTextSearchIndex {
    "The indexed repository."
    repository: Repository!
    "The status of the text search index, if available."
    status: RepositoryTextSearchIndexStatus
    "Git refs in the repository that are configured for text search indexing."
    refs: [RepositoryTextSearchIndexedRef!]!
    "Information about the indexserver that hosts the repo's index."
    host: repositoryIndexserverHost
}

"The status of a repository's text search index."
type RepositoryTextSearchIndexStatus {
    "The date that the index was last updated."
    updatedAt: DateTime!
    "The byte size of the original content."
    contentByteSize: BigInt!
    "The number of files in the original content."
    contentFilesCount: Int!
    "The byte size of the index."
    indexByteSize: Int!
    "The number of index shards."
    indexShardsCount: Int!
    "EXPERIMENTAL: The number of newlines appearing in the index."
    newLinesCount: Int!
    "EXPERIMENTAL: The number of newlines in the default branch."
    defaultBranchNewLinesCount: Int!
    "EXPERIMENTAL: The number of newlines in the other branches."
    otherBranchesNewLinesCount: Int!
}

"A Git ref (usually a branch) in a repository that is configured to be indexed for text search."
type RepositoryTextSearchIndexedRef {
    "The Git ref (usually a branch) that is configured to be indexed for text search. To find the specific commit\nSHA that was indexed, use RepositoryTextSearchIndexedRef.indexedCommit; this field's ref target resolves to\nthe current target, not the target at the time of indexing."
    ref: GitRef!
    "Whether a text search index exists for this ref."
    indexed: Boolean!
    "Whether the text search index is of the current commit for the Git ref. If false, the index is stale."
    current: Boolean!
    "The indexed Git commit (which may differ from the ref's current target if the index is out of date). If\nindexed is false, this field's value is null."
    indexedCommit: GitObject
    "EXPERIMENTAL: Information about the files that were not indexed."
    skippedIndexed: SkippedIndexed
}

"All possible types of currently supported repositories, even though they may be stored\nas a git repository on disk."
enum RepositoryType {
    GIT_REPOSITORY
    PERFORCE_DEPOT
}

"A not persisted resolved workspace, returned from resolveWorkspacesForBatchSpec."
type ResolvedBatchSpecWorkspace {
    "The repository to run over."
    repository: Repository!
    "The branch to run over."
    branch: GitRef!
    "The path to run in."
    path: String!
    "If true, only the files within the workspace will be fetched."
    onlyFetchWorkspace: Boolean!
    "If true, this workspace has been skipped, because some rule forced this.\nFor now, the only one is a .batchignore file existing in the repository."
    ignored: Boolean!
    "If true, this workspace has been skipped, because the code host on which\nthe repository is hosted is not supported."
    unsupported: Boolean!
    "If this workspace was resolved based on a search, this is the list of paths\nto files that have been included in the search results."
    searchResultPaths: [String!]!
}

"A role"
type Role implements Node {
    "The globally unique identifier for this role."
    id: ID!
    "The human readable name for this role."
    name: String!
    "Indicates whether a role is a default system role, which cannot be modified or deleted, or a custom role added by a site admin."
    system: Boolean!
    "The list of permissions that will be granted to any user with this role."
    permissions("The limit argument for forward pagination." first: Int "The limit argument for backward pagination." last: Int "The cursor argument for forward pagination." after: String "The cursor argument for backward pagination." before: String): PermissionConnection!
    "The date and time when the role was created."
    createdAt: DateTime!
}

"A list of roles."
type RoleConnection {
    "A list of roles."
    nodes: [Role!]!
    "The total count of roles in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: ConnectionPageInfo!
}

"Pairs a root directory with comparison key used to match index configurations for the same repository \"project\"."
type RootWithKey {
    "The root."
    root: String!
    "A hash of the root and indexer values.\n\nThis value can be used to quickly compare whether or not explicit configuration and inferred configuration\nrefer to the same \"project\" in a given repository. See `AutoIndexJobDescription.comparisonKey`."
    comparisonKey: String!
}

"Input for saving a new view on an insight."
input SaveInsightAsNewViewInput {
    "The insight view ID we are creating a new view from."
    insightViewId: ID!
    "The options for this line chart."
    options: LineChartOptionsInput!
    "The dashboard ID to associate this insight with once created."
    dashboard: ID
    "The default values for filters and aggregates for this line chart."
    viewControls: InsightViewControlsInput
}

"A saved search query, defined in settings."
type SavedSearch implements Node {
    "The unique ID of this saved query."
    id: ID!
    "The description."
    description: String!
    "The query."
    query: String!
    "Whether or not to notify the owner of the saved search via email. This owner is either\na single user, or every member of an organization that owns the saved search."
    notify: Boolean!
    "Whether or not to notify on Slack."
    notifySlack: Boolean!
    "The user or org that owns this saved search."
    namespace: Namespace!
    "The Slack webhook URL associated with this saved search, if any."
    slackWebhookURL: String
}

"A paginated connection for saved search queries, defined in settings."
type SavedSearchesConnection implements Connection {
    "A list of saved searches."
    nodes: [SavedSearch!]!
    "The total number of saved searches in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: ConnectionPageInfo!
}

"A summary of a schema drift."
type SchemaDriftSummary {
    "Name of the table that contains the drift"
    name: String!
    "The problem that was found"
    problem: String!
    "The suggested solution to the problem"
    solution: String!
    "The diff of the schema drift"
    diff: String
    "The SQL to fix the schema drift"
    statements: [String!]
    "The Sourcegraph URL that contains the potential fix"
    urlHint: String
}

"Information about scope query validity"
type ScopedInsightQueryPayload {
    "The original query."
    query: String!
    "Whether the query is valid."
    isValid: Boolean!
    "The reason why the query is invalid."
    invalidReason: String
}

"A search."
type Search {
    "The results."
    results: SearchResults!
    "A subset of results (excluding actual search results) which are heavily\ncached and thus quicker to query. Useful for e.g. querying sparkline\ndata."
    stats: SearchResultsStats!
}

"Supported aggregation modes for search aggregations"
enum SearchAggregationMode {
    REPO
    PATH
    AUTHOR
    CAPTURE_GROUP
    REPO_METADATA
}

"Indicates that a search aggregation is not available"
type SearchAggregationNotAvailable {
    "The specific reason a search aggregation is not available"
    reason: String!
    "The general reason a search aggregation is not available"
    reasonType: NotAvailableReasonType!
    "The SearchAggregationMode that is unavailable"
    mode: SearchAggregationMode!
}

"Defines how the data series is generated."
union SearchAggregationResult = ExhaustiveSearchAggregationResult | NonExhaustiveSearchAggregationResult | SearchAggregationNotAvailable

"A search-related alert message."
type SearchAlert {
    "The title."
    title: String!
    "The description."
    description: String
    "An identifier indicating the kind of alert"
    kind: String
    "\"Did you mean: ____\" query proposals"
    proposedQueries: [SearchQueryDescription!]
}

"A search context. Specifies a set of repositories to be searched."
type SearchContext implements Node {
    "The unique id of the search context."
    id: ID!
    "The name of the search context."
    name: String!
    "The owner (user or org) of the search context. If nil, search context is considered instance-level."
    namespace: Namespace
    "The description of the search context."
    description: String!
    "Fully-qualified search context spec for use when querying.\nExamples: global, @username, @username\/ctx, and @org\/ctx."
    spec: String!
    "Whether the search context is autodefined by Sourcegraph.\nThe only autodefined context currently is the global search context (\"global\")."
    autoDefined: Boolean!
    "Sourcegraph search query that defines the search context.\ne.g. \"r:^github\\.com\/org (rev:bar or rev:HEAD) file:^sub\/dir\""
    query: String!
    "Repositories and their revisions that will be searched when querying."
    repositories: [SearchContextRepositoryRevisions!]!
    "Public property controls the visibility of the search context. Public search context is available to\nany user on the instance. If a public search context contains private repositories, those are filtered out\nfor unauthorized users. Private search contexts are only available to their owners. Private user search context\nis available only to the user, private org search context is available only to the members of the org, and private\ninstance-level search contexts are available only to site-admins."
    public: Boolean!
    "Date and time the search context was last updated."
    updatedAt: DateTime!
    "If current viewer can manage (edit, delete) the search context."
    viewerCanManage: Boolean!
    "If the viewer has set this context as default."
    viewerHasAsDefault: Boolean!
    "If the viewer has starred this context."
    viewerHasStarred: Boolean!
}

"A list of search contexts"
type SearchContextConnection {
    "A list of search contexts."
    nodes: [SearchContext!]!
    "The total number of search contexts in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"Input for editing an existing search context."
input SearchContextEditInput {
    "Search context name. Not the same as the search context spec. Search context namespace and search context name\nare used to construct the fully-qualified search context spec.\nExample mappings from search context spec to search context name: global -> global, @user -> user, @org -> org,\n@user\/ctx1 -> ctx1, @org\/ctxs\/ctx -> ctxs\/ctx."
    name: String!
    "Search context description."
    description: String!
    "Public property controls the visibility of the search context. Public search context is available to\nany user on the instance. If a public search context contains private repositories, those are filtered out\nfor unauthorized users. Private search contexts are only available to their owners. Private user search context\nis available only to the user, private org search context is available only to the members of the org, and private\ninstance-level search contexts are available only to site-admins."
    public: Boolean!
    "Sourcegraph search query that defines the search context.\ne.g. \"r:^github\\.com\/org (rev:bar or rev:HEAD) file:^sub\/dir\""
    query: String!
}

"Input for a new search context."
input SearchContextInput {
    "Search context name. Not the same as the search context spec. Search context namespace and search context name\nare used to construct the fully-qualified search context spec.\nExample mappings from search context spec to search context name: global -> global, @user -> user, @org -> org,\n@user\/ctx1 -> ctx1, @org\/ctxs\/ctx -> ctxs\/ctx."
    name: String!
    "Search context description."
    description: String!
    "Public property controls the visibility of the search context. Public search context is available to\nany user on the instance. If a public search context contains private repositories, those are filtered out\nfor unauthorized users. Private search contexts are only available to their owners. Private user search context\nis available only to the user, private org search context is available only to the members of the org, and private\ninstance-level search contexts are available only to site-admins."
    public: Boolean!
    "Namespace of the search context (user or org). If not set, search context is considered instance-level."
    namespace: ID
    "Sourcegraph search query that defines the search context.\ne.g. \"r:^github\\.com\/org (rev:bar or rev:HEAD) file:^sub\/dir\""
    query: String!
}

"Specifies a set of revisions to be searched within a repository."
type SearchContextRepositoryRevisions {
    "The repository to be searched."
    repository: Repository!
    "The set of revisions to be searched."
    revisions: [String!]!
}

"Input for a set of revisions to be searched within a repository."
input SearchContextRepositoryRevisionsInput {
    "ID of the repository to be searched."
    repositoryID: ID!
    "Revisions in the repository to be searched."
    revisions: [String!]!
}

"SearchContextsOrderBy enumerates the ways a search contexts list can be ordered."
enum SearchContextsOrderBy {
    SEARCH_CONTEXT_SPEC
    SEARCH_CONTEXT_UPDATED_AT
}

"A search filter."
type SearchFilter {
    "The value."
    value: String!
    "The string to be displayed in the UI."
    label: String!
    "Number of matches for a given filter."
    count: Int!
    "Whether the results returned are incomplete."
    limitHit: Boolean!
    "The kind of filter. Should be \"file\" or \"repo\"."
    kind: String!
}

"Defines an insight data series that is constructed from a Sourcegraph search query."
type SearchInsightDataSeriesDefinition {
    "Unique ID for the series."
    seriesId: String!
    "The query string."
    query: String!
    "A scope of repositories defined for this series. Series with repository scopes defined by a search query are not identifiable via this field"
    repositoryScope: InsightRepositoryScope! @deprecated(reason: "use repositoryDefinition instead")
    "A definition of Repositories this series will operate over."
    repositoryDefinition: InsightRepositoryDefinition!
    "The scope of time for which the insight data is generated."
    timeScope: InsightTimeScope!
    "Whether or not the the time series are derived from the captured groups of the search results."
    generatedFromCaptureGroups: Boolean!
    "Whether or not the series has been pre-calculated, or still needs to be resolved. This field is largely only used\nfor the code insights webapp, and should be considered unstable (planned to be deprecated in a future release)."
    isCalculated: Boolean!
    "The field to group results by. (For compute powered insights only.) This field is experimental and should be considered unstable in the API."
    groupBy: GroupByField
}

"Required input to generate a time series for a search insight using live preview."
input SearchInsightLivePreviewInput {
    "The query string."
    query: String!
    "The desired label for the series. Will be overwritten when series are dynamically generated."
    label: String!
    "The scope of repositories."
    repositoryScope: RepositoryScopeInput!
    "The scope of time."
    timeScope: TimeScopeInput!
    "Whether or not to generate the timeseries results from the query capture groups."
    generatedFromCaptureGroups: Boolean!
    "Use this field to specify a compute insight. Note: this is experimental and should be considered unstable"
    groupBy: GroupByField
}

"Input object for a live preview search based code insight."
type SearchInsightLivePreviewSeries {
    "The data points for the time series."
    points: [InsightDataPoint!]!
    "The label for the data series."
    label: String!
}

"Required input to generate a live preview for an insight."
input SearchInsightPreviewInput {
    "The scope of repositories."
    repositoryScope: RepositoryScopeInput!
    "The scope of time."
    timeScope: TimeScopeInput!
    "The series to generate previews for"
    series: [SearchSeriesPreviewInput!]!
}

"The search pattern type."
enum SearchPatternType {
    standard
    literal
    regexp
    structural
    lucky
    keyword
}

"Information about search aggregations"
type SearchQueryAggregate {
    "A list of the possible aggregation modes and if they are available"
    modeAvailability: [AggregationModeAvailability!]!
    "A result of aggregating a search query for the specified aggregation mode.\nmode - the requested aggregation mode, if null a default will be selected based on the search query\nlimit - is the maximum number of aggregation groups to return, this limit will not override any internal limits.\nextendedTimeout - indicates of the aggregation request should use an extended timeout."
    aggregations(mode: SearchAggregationMode limit: Int = 50 extendedTimeout: Boolean = false): SearchAggregationResult!
}

"Additional information describing attributes of a query."
type SearchQueryAnnotation {
    "A name for this query annotation label."
    name: String!
    "An opaque value for this query annotation."
    value: String!
}

"A search query description."
type SearchQueryDescription {
    "The description."
    description: String
    "The query."
    query: String!
    "Additional optional information describing attributes of this query."
    annotations: [SearchQueryAnnotation!]
}

"The output format to emit for a parsed query."
enum SearchQueryOutputFormat {
    "JSON format."
    JSON
    "S-expression format."
    SEXP
    "Mermaid flowchart format."
    MERMAID
}

"Represents phases in query parsing. The parse tree corresponds closely to the\ninput query syntax. A subsequent processing phase on the parse tree generates a\njob tree. The job tree is an internal representation analogous to a database\nquery plan. The job tree discards information about query syntax and corresponds\nclosely to backend services (text search, git commit search, etc.)."
enum SearchQueryOutputPhase {
    PARSE_TREE
    JOB_TREE
}

"The output format to emit for a parsed query."
enum SearchQueryOutputVerbosity {
    "Minimal verbosity outputs only nodes."
    MINIMAL
    "Basic verbosity outputs nodes and essential fields associated with nodes."
    BASIC
    "Maximal verbosity outputs nodes and all information associated with nodes."
    MAXIMAL
}

"A search result."
union SearchResult = FileMatch | CommitSearchResult | Repository

"A match in a search result. Matches make up the body content of a search result."
type SearchResultMatch {
    "URL for the individual result match."
    url: String!
    "A markdown string containing the preview contents of the result match."
    body: Markdown!
    "A list of highlights that specify locations of matches of the query in the body. Each highlight is\na line number, character offset, and length. Currently, highlights are only displayed on match bodies\nthat are code blocks. If the result body is a code block, exclude the markdown code fence lines in\nthe line and character count. Leave as an empty list if no highlights are available."
    highlights: [Highlight!]!
}

"Search results."
type SearchResults {
    "The results. Inside each SearchResult there may be multiple matches, e.g.\na FileMatch may contain multiple line matches."
    results: [SearchResult!]!
    "The total number of matches returned by this search. This is different\nthan the length of the results array in that e.g. a single results array\nentry may contain multiple matches. For example, the results array may\ncontain two file matches and this field would report 6 (\"3 line matches\nper file\") while the length of the results array would report 3\n(\"3 FileMatch results\").\nTypically, 'approximateResultCount', not this field, is shown to users."
    matchCount: Int!
    "DEPRECATED: Renamed to 'matchCount' for less ambiguity."
    resultCount: Int! @deprecated(reason: "renamed to matchCount for less ambiguity")
    "The approximate number of results. This is like the length of the results\narray, except it can indicate the number of results regardless of whether\nor not the limit was hit. Currently, this is represented as e.g. \"5+\"\nresults.\nThis string is typically shown to users to indicate the true result count."
    approximateResultCount: String!
    "Whether or not the results limit was hit.\nIn paginated requests, this field is always false. Use 'pageInfo.hasNextPage' instead."
    limitHit: Boolean!
    "Integers representing the sparkline for the search results."
    sparkline: [Int!]!
    "Repositories from results."
    repositories: [Repository!]!
    "The number of repositories that had results (for clients\nthat just wish to know how many without querying the, sometimes extremely\nlarge, list)."
    repositoriesCount: Int!
    "Repositories that are busy cloning onto gitserver.\nIn paginated search requests, some repositories may be cloning. These are reported here\nand you may choose to retry the paginated request with the same cursor after they have\ncloned OR you may simply continue making further paginated requests and choose to skip\nthe cloning repositories."
    cloning: [Repository!]!
    "Repositories or commits that do not exist.\nIn paginated search requests, some repositories may be missing (e.g. if Sourcegraph is\naware of them but is temporarily unable to serve them). These are reported here and you\nmay choose to retry the paginated request with the same cursor and they may no longer be\nmissing OR you may simply continue making further paginated requests and choose to skip\nthe missing repositories."
    missing: [Repository!]!
    "Repositories or commits which we did not manage to search in time. Trying\nagain usually will work.\nIn paginated search requests, this field is not relevant."
    timedout: [Repository!]!
    "DEPRECATED: This field is not used in known clients, and will always return `false`.\nTrue if indexed search is enabled but was not available during this search."
    indexUnavailable: Boolean!
    "An alert message that should be displayed before any results."
    alert: SearchAlert
    "The time it took to generate these results."
    elapsedMilliseconds: Int!
    "Dynamic filters generated by the search results"
    dynamicFilters: [SearchFilter!]!
}

"Statistics about search results."
type SearchResultsStats {
    "The approximate number of results returned."
    approximateResultCount: String!
    "The sparkline."
    sparkline: [Int!]!
    "Statistics about the languages represented in the search results.\nKnown issue: The LanguageStatistics.totalBytes field values are incorrect in the result."
    languages: [LanguageStatistics!]!
}

"Required input to generate a live preview for a series."
input SearchSeriesPreviewInput {
    "The query string."
    query: String!
    "The desired label for the series. Will be overwritten when series are dynamically generated."
    label: String!
    "Whether or not to generate the timeseries results from the query capture groups."
    generatedFromCaptureGroups: Boolean!
    "Use this field to specify a compute insight. Note: this is experimental and should be considered unstable"
    groupBy: GroupByField
}

"The version of the search syntax."
enum SearchVersion {
    "Search syntax that defaults to regexp search."
    V1
    "Search syntax that defaults to literal-only search."
    V2
    "Search syntax that defaults to standard search."
    V3
}

"Options that affect which series to display for an insight."
type SeriesDisplayOptions {
    "Sort options for the series."
    sortOptions: SeriesSortOptions!
    "Max number of series to return."
    limit: Int
    "Max number of samples to return for all the series on the view."
    numSamples: Int
}

"Input type for series display options."
input SeriesDisplayOptionsInput {
    "Sort options for the series."
    sortOptions: SeriesSortOptionsInput
    "Max number of series to return."
    limit: Int
    "Max number of samples to return."
    numSamples: Int
}

"Sort direction for series."
enum SeriesSortDirection {
    ASC
    DESC
}

"Sort mode for series."
enum SeriesSortMode {
    RESULT_COUNT
    LEXICOGRAPHICAL
    DATE_ADDED
}

"Series sort options."
type SeriesSortOptions {
    "Sort mode for series."
    mode: SeriesSortMode
    "Sort direction for series."
    direction: SeriesSortDirection
}

"Input type for series sort options."
input SeriesSortOptionsInput {
    "Sort mode for series."
    mode: SeriesSortMode!
    "Sort direction for series."
    direction: SeriesSortDirection!
}

"An active user session."
type Session {
    "Whether the user can sign out of this session on Sourcegraph."
    canSignOut: Boolean!
}

"Settings is a version of a configuration settings file."
type Settings {
    "The ID."
    id: Int!
    "The subject that these settings are for."
    subject: SettingsSubject!
    "The author, or null if there is no author or the authoring user was deleted."
    author: User
    "The time when this was created."
    createdAt: DateTime!
    "The stringified JSON contents of the settings. The contents may include \"\/\/\"-style comments and trailing\ncommas in the JSON."
    contents: JSONCString!
    "DEPRECATED: This field will be removed in a future release.\nThe configuration."
    configuration: Configuration! @deprecated(reason: "use the contents field instead")
}

"The configurations for all of the relevant settings subjects, plus the merged settings."
type SettingsCascade {
    "The other settings subjects that are applied with lower precedence than this subject to\nform the final merged settings. For example, a user in 2 organizations would have the following\nsettings subjects: site (global settings), org 1, org 2, and the user."
    subjects: [SettingsSubject!]!
    "The effective final merged settings as (stringified) JSON, merged from all of the subjects."
    final: String!
    "DEPRECATED: This field will be removed in a future release.\nThe effective final merged settings, merged from all of the subjects."
    merged: Configuration! @deprecated(reason: "use final instead")
}

"An edit to a JSON property in a settings JSON object. The JSON property to edit can be nested."
input SettingsEdit {
    "The key path of the property to update.\n\nInserting into an existing array is not yet supported."
    keyPath: [KeyPathSegment!]!
    "The new JSON-encoded value to insert. If the field's value is not set, the property is removed. (This is\ndifferent from the field's value being the JSON null value.)\n\nWhen the value is a non-primitive type, it must be specified using a GraphQL variable, not an inline literal,\nor else the GraphQL parser will return an error."
    value: JSONValue
    "Whether to treat the value as a JSONC-encoded string, which makes it possible to perform an edit that\npreserves (or adds\/removes) comments."
    valueIsJSONCEncodedString: Boolean = false
}

"Mutations that update settings (global, organization, or user settings). These mutations are grouped together\nbecause they:\n- are all versioned to avoid race conditions with concurrent editors\n- all apply to a specific settings subject (i.e., a user, an organization, or the whole site)\n\nGrouping them lets us extract those common parameters to the Mutation.settingsMutation field."
type SettingsMutation {
    "Edit a single property in the settings object."
    editSettings("The edit to apply to the settings." edit: SettingsEdit!): UpdateSettingsPayload
    "DEPRECATED"
    editConfiguration(edit: ConfigurationEdit!): UpdateSettingsPayload @deprecated(reason: "Use editSettings instead. This field is a deprecated alias for it and will be removed in a future release.")
    "Overwrite the existing settings with the new settings."
    overwriteSettings("A JSON object (stringified) of the settings. Trailing commas and \"\/\/\"-style comments are supported. The\nentire previous settings value will be overwritten by this new value." contents: String!): UpdateSettingsPayload
}

"Input for Mutation.settingsMutation, which contains fields that all settings (global, organization, and user\nsettings) mutations need."
input SettingsMutationGroupInput {
    "The subject whose settings to mutate (organization, user, etc.)."
    subject: ID!
    "The ID of the last-known settings known to the client, or null if there is none. This field is used to\nprevent race conditions when there are concurrent editors."
    lastID: Int
}

"SettingsSubject is something that can have settings: a site (\"global settings\", which is different from \"site\nconfiguration\"), an organization, or a user."
interface SettingsSubject {
    "The ID."
    id: ID!
    "The latest settings."
    latestSettings: Settings
    "The URL to the settings."
    settingsURL: String
    "Whether the viewer can modify the subject's settings."
    viewerCanAdminister: Boolean!
    "All settings for this subject, and the individual levels in the settings cascade (global > organization > user)\nthat were merged to produce the final merged settings."
    settingsCascade: SettingsCascade!
    "DEPRECATED"
    configurationCascade: ConfigurationCascade! @deprecated(reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release.")
}

"A signature."
type Signature {
    "The person."
    person: Person!
    "The date."
    date: String!
}

"A site is an installation of Sourcegraph that consists of one or more\nservers that share the same configuration and database.\nThe site is a singleton; the API only ever returns the single global site."
type Site implements SettingsSubject {
    "The site's opaque GraphQL ID. This is NOT the \"site ID\" as it is referred to elsewhere;\nuse the siteID field for that. (GraphQL node types conventionally have an id field of type\nID! that globally identifies the node.)"
    id: ID!
    "The site ID."
    siteID: String!
    "The site's configuration. Only visible to site admins.\n\nIf returnSafeConfigsOnly is true, returns a subset of the configuration classified\nas safe config."
    configuration(returnSafeConfigsOnly: Boolean): SiteConfiguration!
    "The site's latest site-wide settings (which are the second-lowest-precedence\nin the configuration cascade for a user)."
    latestSettings: Settings
    "The global settings for this site, and the final merged settings.\nAll viewers can access this field."
    settingsCascade: SettingsCascade!
    "DEPRECATED"
    configurationCascade: ConfigurationCascade! @deprecated(reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release.")
    "The URL to the site's settings."
    settingsURL: String
    "Whether the viewer can reload the site (with the reloadSite mutation)."
    canReloadSite: Boolean!
    "Whether the viewer can modify the subject's settings."
    viewerCanAdminister: Boolean!
    "A list of all access tokens on this site."
    accessTokens("Returns the first n access tokens from the list." first: Int): AccessTokenConnection!
    "A list of all authentication providers. This information is visible to all viewers and does not contain any\nsecret information."
    authProviders: AuthProviderConnection!
    "A list of all user external accounts on this site."
    externalAccounts("Returns the first n external accounts from the list." first: Int "Include only external accounts associated with this user." user: ID "Include only external accounts with this service type." serviceType: String "Include only external accounts with this service ID." serviceID: String "Include only external accounts with this client ID." clientID: String): ExternalAccountConnection!
    "The build version of the Sourcegraph software that is running on this site (of the form\nNNNNN_YYYY-MM-DD_XXXXX, like 12345_2018-01-01_abcdef)."
    buildVersion: String!
    "The product version of the Sourcegraph software that is running on this site."
    productVersion: String!
    "Information about software updates for the version of Sourcegraph that this site is running."
    updateCheck: UpdateCheck!
    "Whether the site needs to be configured to add repositories."
    needsRepositoryConfiguration: Boolean!
    "Whether the external services haven been created from a configuration file\nspecified in the EXTSVC_CONFIG_FILE."
    externalServicesFromFile: Boolean!
    "Whether the external services can be updated even if `externalServicesFromFile` is\ntrue. All changes made while `externalServicesFromFile` is true will be discarded once\nSourcegraph restarts."
    allowEditExternalServicesWithFile: Boolean!
    "The number of external services distinguished by local repositories and remote repositories.\nLocal repository code host connections are only supported in Sourcegraph App."
    externalServicesCounts: ExternalServicesCounts!
    "Whether the site is over the limit for free user accounts, and a warning needs to be shown to all users.\nOnly applies if the site does not have a valid license."
    freeUsersExceeded: Boolean!
    "Alerts to display to the viewer."
    alerts: [Alert!]!
    "BACKCOMPAT: Always returns true."
    hasCodeIntelligence: Boolean!
    "Whether the server sends emails to users to verify email addresses. If false, then site admins must manually\nverify users' email addresses."
    sendsEmailVerificationEmails: Boolean!
    "Information about this site's product subscription status."
    productSubscription: ProductSubscriptionStatus!
    "Usage statistics for this site."
    usageStatistics("Days of history (based on current UTC time)." days: Int "Weeks of history (based on current UTC time)." weeks: Int "Months of history (based on current UTC time)." months: Int): SiteUsageStatistics!
    "New usage statistics\/analytics for this site."
    analytics: Analytics!
    "List all users."
    users("Return users whose usernames or display names match the query." query: String "Returns users who have been active in a given period of time." siteAdmin: Boolean "Returns users that contain filter in the username field." username: String "Returns users that contain filter in the email field." email: String "Returns users for the given lastActive enum period.\nWhen omitted does NOT apply and returns for all period available." lastActiveAt: SiteUsersDateRangeInput "Returns either deleted or not deleted users. Returns all users when omitted." deletedAt: SiteUsersDateRangeInput "Returns users who where created within a given date time range." createdAt: SiteUsersDateRangeInput "Returns users whose events count within a given range." eventsCount: SiteUsersNumberRangeInput): SiteUsers!
    "Monitoring overview for this site.\nNote: This is primarily used for displaying recently-fired alerts in the web app. If your intent\nis to monitor Sourcegraph, it is better to configure alerting or query Prometheus directly in\norder to ensure that if the frontend goes down you still receive alerts:\nConfigure alerting: https:\/\/docs.sourcegraph.com\/admin\/observability\/alerting\nQuery Prometheus directly: https:\/\/docs.sourcegraph.com\/admin\/observability\/alerting_custom_consumption"
    monitoringStatistics("Days of history (based on current UTC time)." days: Int): MonitoringStatistics!
    "Whether changes can be made to site settings through the API. When global settings are configured through\nthe GLOBAL_SETTINGS_FILE environment variable, site settings edits cannot be made through the API."
    allowSiteSettingsEdits: Boolean!
    "FOR INTERNAL USE ONLY: Returns information about instance upgrade readiness."
    upgradeReadiness: UpgradeReadiness!
    "FOR INTERNAL USE ONLY: The state of readiness to auto upgrade the Sourcegraph instance via migrator commands."
    autoUpgradeEnabled: Boolean!
    "Wether the current App installation has a connected Sourcegraph.com account."
    appHasConnectedDotComAccount: Boolean!
    "The quota of completions requests allowed per user in a day. Null, if unlimited."
    perUserCompletionsQuota: Int
    "The quota of code completions requests allowed per user in a day. Null, if unlimited."
    perUserCodeCompletionsQuota: Int
    "Whether users are required to have a verified email in order to access Cody."
    requiresVerifiedEmailForCody: Boolean!
    "Whether Cody is enabled for this site."
    isCodyEnabled: Boolean!
    "If Cody is enabled, this returns how Cody is configured to talk to the LLM."
    codyLLMConfiguration: CodyLLMConfiguration
    "Returns the status of the Cody Rate limits when using the `sourcegraph` provider.\nIf the instance is not using the Cody Gateway there will be no rate limits.\n\nSite-admin only."
    codyGatewayRateLimitStatus: [CodyGatewayRateLimitStatus!]
}

"The configuration for a site."
type SiteConfiguration {
    "The unique identifier of this site configuration version."
    id: Int!
    "The effective configuration JSON."
    effectiveContents: JSONCString!
    "Messages describing validation problems or usage of deprecated configuration in the configuration JSON.\nThis includes both JSON Schema validation problems and other messages that perform more advanced checks\non the configuration (that can't be expressed in the JSON Schema)."
    validationMessages: [String!]!
    "EXPERIMENTAL: A list of diffs to depict what changed since the previous version of this\nconfiguration.\nOnly site admins may perform this query."
    history("The number of nodes to return starting from the beginning (oldest).\nNote: Use either first or last (see below) in the query. Setting both will\nreturn an error." first: Int "The number of nodes to return starting from the end (latest).\nNote: Use either last or first (see above) in the query. Setting both will\nreturn an error." last: Int "Opaque pagination cursor to be used when paginating forwards that may be also used\nin conjunction with \"first\" to return the first N nodes." after: String "Opaque pagination cursor to be used when paginating backwards that may be\nalso used in conjunction with \"last\" to return the last N nodes." before: String): SiteConfigurationChangeConnection
}

"A diff representing the change in the site config compared to the previous version."
type SiteConfigurationChange implements Node {
    "The ID of the site config in the history."
    id: ID!
    "The user who made this change. If empty, it indicates that either the\nauthor's information is not available or the change in the site config was applied\nvia an internal process (example: site startup or SITE_CONFIG_FILE being reloaded)."
    author: User
    "The diff string when diffed against the previous site config."
    diff: String!
    "The timestamp when this change in the site config was applied."
    createdAt: DateTime!
    "The timestamp when this change in the site config was modified. Usually\nthis should be the same as createdAt as entries in the site config history are\nconsidered immutable."
    updatedAt: DateTime!
}

"A list of site config diffs. Diff generation may not be available from the very\nstart depending on when the value of redacted_contents is available in the\ndatabase."
type SiteConfigurationChangeConnection implements Connection {
    "A list of diffs in the site config"
    nodes: [SiteConfigurationChange!]!
    "The total number of diffs in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: ConnectionPageInfo!
}

"SiteUsagePeriod describes a site's usage statistics for a given timespan.\nThis information is visible to all viewers."
type SiteUsagePeriod {
    "The time when this started."
    startTime: String!
    "The user count."
    userCount: Int!
    "The registered user count."
    registeredUserCount: Int!
    "The anonymous user count."
    anonymousUserCount: Int!
    "The count of registered users that have been active on a code host integration.\nExcludes anonymous users."
    integrationUserCount: Int!
}

"SiteUsageStatistics describes a site's aggregate usage statistics.\nThis information is visible to all viewers."
type SiteUsageStatistics {
    "Recent daily active users."
    daus: [SiteUsagePeriod!]!
    "Recent weekly active users."
    waus: [SiteUsagePeriod!]!
    "Recent monthly active users."
    maus: [SiteUsagePeriod!]!
}

"Site user."
type SiteUser {
    "The unique ID for the user."
    id: ID!
    "User's username."
    username: String!
    "User's primary email."
    email: String
    "User's display name"
    displayName: String
    "The datetime when user was created in the system."
    createdAt: String!
    "The datetime when user was last active."
    lastActiveAt: String
    "The datetime when user was deleted."
    deletedAt: String
    "Whether user is site admin or not."
    siteAdmin: Boolean!
    "Whether the user is controlled through SCIM."
    scimControlled: Boolean!
    "Total number of user's event_logs."
    eventsCount: Float!
    "Whether or not the user account is locked."
    locked: Boolean!
}

"SiteUserOrderBy enumerates the ways a users list can be ordered."
enum SiteUserOrderBy {
    USERNAME
    "User's primary email."
    EMAIL
    "The total number of user's event_logs."
    EVENTS_COUNT
    "The last event_log datetime."
    LAST_ACTIVE_AT
    "The datetime when user was added to the system."
    CREATED_AT
    "The datetime when user was soft deleted."
    DELETED_AT
    "Whether the user is site admin or not."
    SITE_ADMIN
}

"Site users."
type SiteUsers {
    "User total count."
    totalCount: Float!
    "List of users."
    nodes("Returns the \"limit\" number users from the list." limit: Int "Skips initial \"offset\" number of users." offset: Int "Returns users ordered by a given column." orderBy: SiteUserOrderBy "Returns ordered users in descending order provided by orderBy field." descending: Boolean): [SiteUser!]!
}

"SiteUsersDateRangeInput argument to filter based on date range or date equals to null"
input SiteUsersDateRangeInput {
    "Less than or equal to"
    lte: DateTime
    "Greater than or equal to"
    gte: DateTime
    "Negation"
    not: Boolean
    "Equal to Null"
    empty: Boolean
}

"SiteUsersNumberRangeInput argument to filter based on the number range"
input SiteUsersNumberRangeInput {
    "Less than or equal to"
    gte: Float
    "Greater than or equal to"
    lte: Float
}

"EXPERIMENTAL: Information about the files that were not indexed."
type SkippedIndexed {
    "The count of files that were not indexed."
    count: BigInt!
    "The query to retrieve the list of files that were not indexed."
    query: String!
}

"A logged slow GraphQL request, captured by the backend."
type SlowRequest {
    "The index of this request."
    index: String!
    "The date at which this request was started."
    start: DateTime!
    "The duration of the request."
    duration: Float!
    "The user associated with that request, if any."
    user: User
    "The name of the GraphQL request."
    name: String!
    "The source from which the request originated."
    source: String!
    "The repository referenced by the request, if any."
    repository: Repository
    "The variables used to build the GraphQL request."
    variables: String!
    "The errors returned if the request failed."
    errors: [String!]!
    "The GraphQL query."
    query: String!
    "The file path referenced by the request, if any."
    filepath: String
}

"The result for Query.slowRequests."
type SlowRequestConnection {
    "A list of slow graphql requests logs."
    nodes: [SlowRequest!]!
    "The total number of slow graphql logs in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"The SCIP snapshot decoration for a single SCIP Occurrence."
type SnapshotData {
    "The byte offset in the document immediately after the line the occurrence is on."
    offset: Int!
    "The formatted SCIP symbol string."
    data: String!
    "Any additional lines of snapshot output such as relationships, documentation etc."
    additional: [String!]
}

"EXPERIMENTAL: Attribution result from snippetAttribution."
type SnippetAttribution {
    "The name of the repository containing the snippet.\n\nNote: we do not return a type Repository since repositoryName may\nrepresent a repository not on this instance. eg a match from the\nsourcegraph.com open source corpus."
    repositoryName: String!
}

"EXPERIMENTAL: A list of snippet attributions."
type SnippetAttributionConnection {
    "totalCount is the total number of repository attributions we found before\nstopping the search.\n\nNote: if we didn't finish searching the full corpus then limitHit will be\ntrue. For filtering use case this means if limitHit is true you need to be\nconservative with TotalCount and assume it could be higher."
    totalCount: Int!
    "limitHit is true if we stopped searching before looking into the full\ncorpus. If limitHit is true then it is possible there are more than\ntotalCount attributions."
    limitHit: Boolean!
    "The pagination info for the connection."
    pageInfo: PageInfo!
    "The page set of SnippetAttribution entries in this connection."
    nodes: [SnippetAttribution!]!
}

"Speaker type, human or assistant"
enum SpeakerType {
    HUMAN
    ASSISTANT
}

"FOR INTERNAL USE ONLY: A status message"
union StatusMessage = GitUpdatesDisabled | NoRepositoriesDetected | CloningProgress | ExternalServiceSyncError | SyncError | IndexingProgress

"A Git submodule"
type Submodule {
    "The remote repository URL of the submodule."
    url: String!
    "The commit of the submodule."
    commit: String!
    "The path to which the submodule is checked out."
    path: String!
}

"An individual response to a user satisfaction (NPS) survey."
type SurveyResponse {
    "The unique ID of the survey response"
    id: ID!
    "The user who submitted the survey (if they were authenticated at the time)."
    user: User
    "The email that the user manually entered (if they were NOT authenticated at the time)."
    email: String
    "User's likelihood of recommending Sourcegraph to a friend, from 0-10."
    score: Int!
    "The answer to \"What is the most important reason for the score you gave\"."
    reason: String
    "The answer to \"What can Sourcegraph do to provide a better product\""
    better: String
    "The answer to \"What do you use Sourcegraph for?\"."
    otherUseCase: String
    "The time when this response was created."
    createdAt: DateTime!
}

"A list of survey responses"
type SurveyResponseConnection {
    "A list of survey responses."
    nodes: [SurveyResponse!]!
    "The total count of survey responses in the connection. This total count may be larger\nthan the number of nodes in this object when the result is paginated."
    totalCount: Int!
    "The count of survey responses submitted since 30 calendar days ago at 00:00 UTC."
    last30DaysCount: Int!
    "The average score of survey responses in the connection submitted since 30 calendar days ago at 00:00 UTC."
    averageScore: Float!
    "The net promoter score (NPS) of survey responses in the connection submitted since 30 calendar days ago at 00:00 UTC.\nReturn value is a signed integer, scaled from -100 (all detractors) to +100 (all promoters).\nSee https:\/\/en.wikipedia.org\/wiki\/Net_Promoter for explanation."
    netPromoterScore: Int!
}

"Input for a user satisfaction (NPS) survey submission."
input SurveySubmissionInput {
    "User-provided email address, if there is no currently authenticated user. If there is, this value\nwill not be used."
    email: String
    "User's likelihood of recommending Sourcegraph to a friend, from 0-10."
    score: Int!
    "The answer to \"What do you use Sourcegraph for?\"."
    otherUseCase: String
    "The answer to \"What would make Sourcegraph better?\""
    better: String
}

"Possible answers to \"You use Sourcegraph to...\" in the NPS Survey."
enum SurveyUseCase {
    UNDERSTAND_NEW_CODE
    FIX_SECURITY_VULNERABILITIES
    REUSE_CODE
    RESPOND_TO_INCIDENTS
    IMPROVE_CODE_QUALITY
}

"A code symbol (e.g., a function, variable, type, class, etc.).\nIt is derived from DocumentSymbol as defined in the Language Server Protocol (see https:\/\/microsoft.github.io\/language-server-protocol\/specifications\/specification-3-14\/#textDocument_documentSymbol)."
type Symbol {
    "The name of the symbol."
    name: String!
    "The name of the symbol that contains this symbol, if any. This field's value is not guaranteed to be\nstructured in such a way that callers can infer a hierarchy of symbols."
    containerName: String
    "The kind of the symbol."
    kind: SymbolKind!
    "The programming language of the symbol."
    language: String!
    "The location where this symbol is defined."
    location: Location!
    "The URL to this symbol (using the input revision specifier, which may not be immutable)."
    url: String!
    "The canonical URL to this symbol (using an immutable revision specifier)."
    canonicalURL: String!
    "Whether or not the symbol is local to the file it's defined in."
    fileLocal: Boolean!
}

"FileBlock specifies a symbol to display within the block."
type SymbolBlock {
    "ID of the block."
    id: String!
    "Symbol block input."
    symbolInput: SymbolBlockInput!
}

"SymbolBlockInput contains the information necessary to find the symbol."
type SymbolBlockInput {
    "Name of the repository, e.g. \"github.com\/sourcegraph\/sourcegraph\"."
    repositoryName: String!
    "Path within the repository, e.g. \"client\/web\/file.tsx\"."
    filePath: String!
    "An optional revision, e.g. \"pr\/feature-1\", \"a9505a2947d3df53558e8c88ff8bcef390fc4e3e\".\nIf omitted, we use the latest revision (HEAD)."
    revision: String
    "Number of lines to show before and after the matched symbol line."
    lineContext: Int!
    "The symbol name."
    symbolName: String!
    "Name of the symbol container."
    symbolContainerName: String!
    "The symbol kind."
    symbolKind: SymbolKind!
}

"A list of symbols."
type SymbolConnection {
    "A list of symbols."
    nodes: [Symbol!]!
    "Pagination information."
    pageInfo: PageInfo!
}

"SymbolInfo contains hover and definition methods. It's returned by GitBlob.symbolInfo(line, character)."
type SymbolInfo {
    "The definition of the symbol."
    definition: SymbolLocation
    "The hover for the symbol."
    hover: String
}

"All possible kinds of symbols. This set matches that of the Language Server Protocol\n(https:\/\/microsoft.github.io\/language-server-protocol\/specification#workspace_symbol)."
enum SymbolKind {
    UNKNOWN
    FILE
    MODULE
    NAMESPACE
    PACKAGE
    CLASS
    METHOD
    PROPERTY
    FIELD
    CONSTRUCTOR
    ENUM
    INTERFACE
    FUNCTION
    VARIABLE
    CONSTANT
    STRING
    NUMBER
    BOOLEAN
    ARRAY
    OBJECT
    KEY
    NULL
    ENUMMEMBER
    STRUCT
    EVENT
    OPERATOR
    TYPEPARAMETER
}

"SymbolLocation is a single-line range within a repository. It's returned by SymbolInfo.definition."
type SymbolLocation {
    "The repo."
    repo: String!
    "The commit."
    commit: String!
    "The path."
    path: String!
    "The range."
    range: LineRange
    "The line."
    line: Int! @deprecated(reason: "use range.line instead")
    "The character."
    character: Int! @deprecated(reason: "use range.character instead")
    "The length."
    length: Int! @deprecated(reason: "use range.length instead")
}

"FOR INTERNAL USE ONLY: A status message produced when repositories could not\nbe synced"
type SyncError {
    "The message of this status message"
    message: String!
}

"A team is a grouping of users\/persons into a common handle. Teams are commonly used to define\ncodeowners."
type Team implements Node {
    "The unique ID of the team."
    id: ID!
    "The name of the team. Needs to be globally unique across usernames, organization\nnames, and team names. Team names can use alphanumeric characters, - dash\nand \/ forward slash."
    name: String!
    "URL to link to the teams profile page."
    url: String!
    "URL to an avatar of this team."
    avatarURL: String
    "A human readable name substitute for the name. Null, if not defined."
    displayName: String
    "A team can be made read-only from the CLI instructing the UI to show a warning\nbanner that this is managed externally, and management features will only be\navailable to site-admins. It can also still be manipulated from the CLI."
    readonly: Boolean!
    "The teams direct members. That is members that are strictly part of this team,\nbut not members of child teams. Team membership is NOT inherited."
    members("Returns the first n team members from the list." first: Int "Opaque pagination cursor." after: String "Optionally apply a text search filter over the results." search: String): TeamMemberConnection!
    "Parent team can be null, if this is a root team."
    parentTeam: Team
    "The list of direct child teams."
    childTeams("Returns the first n teams from the list." first: Int "Opaque pagination cursor." after: String "Optionally apply a text search filter over the results." search: String): TeamConnection!
    "True, if the current user can modify this team."
    viewerCanAdminister: Boolean!
    "The creator of this team. Null, if the user was deleted."
    creator: User
    "True, if the team is external, i.e. not found in our database.\nExample: CODEOWNERS files can contain references to GitHub teams which are not the part of Sourcegraph teams."
    external: Boolean!
}

"A list of teams."
type TeamConnection {
    "The total count of items in the connection."
    totalCount: Int!
    "The pagination info for the connection."
    pageInfo: PageInfo!
    "The current page of teams in this connection."
    nodes: [Team!]!
}

"A team member is an entity that can be associated to a team.\n\nFor now, this will be User, and will be expanded to User | Person later."
interface TeamMember {
    "All the teams this TeamMember is a direct member of."
    teams("Returns the first n teams from the list." first: Int "Opaque pagination cursor." after: String "Optionally apply a text search filter over the results." search: String): TeamConnection!
}

"A list of team members."
type TeamMemberConnection {
    "The total count of items in the connection."
    totalCount: Int!
    "The pagination info for the connection."
    pageInfo: PageInfo!
    "The current page of team members in this connection."
    nodes: [TeamMember!]!
}

"Options to specify a user for team membership. Multiple options can be provided,\nwith the following precedence order: (Other mismatches will be discarded)\n- UserID\n- Username\n- Email\n- External Account fields\n\nExamples:\n- If ID is set and no match, return.\n- If ID and username is set, and ID matches but username doesn't, match."
input TeamMemberInput {
    "Explicitly define a user by ID."
    userID: ID
    "Explicitly define a user by username in Sourcegraph."
    username: String
    "If the email is associated to a user and verified, the user account will be matched."
    email: String
    "If the user has an associated external account, use this.\nexternalAccountServiceID and externalAccountServiceType must be set and\neither of externalAccountAccountID externalAccountLogin are required as well.\nService ID for the GitHub OAuth provider, for example, is https:\/\/github.com\/."
    externalAccountServiceID: String
    "If the user has an associated external account, use this.\nexternalAccountServiceID and externalAccountServiceType must be set and\neither of externalAccountAccountID externalAccountLogin are required as well.\nService Type for the GitHub OAuth provider, for example, is github."
    externalAccountServiceType: String
    "If the user has an associated external account, use this.\nexternalAccountServiceID and externalAccountServiceType must be set and\neither of externalAccountAccountID externalAccountLogin are required as well.\nAccount ID is the unique identifier on the external account platform."
    externalAccountAccountID: String
    "If the user has an associated external account, use this.\nexternalAccountServiceID and externalAccountServiceType must be set and\neither of externalAccountAccountID externalAccountLogin are required as well.\nAccount Login is usually the username on the external account platform."
    externalAccountLogin: String
}

"Temporary settings for a user."
type TemporarySettings {
    "A JSON string representing the temporary settings."
    contents: String!
}

"A time scope defined using a time interval (ex. 5 days)"
input TimeIntervalStepInput {
    "The time unit for the interval."
    unit: TimeIntervalStepUnit!
    "The value for the interval."
    value: Int!
}

"Time interval units."
enum TimeIntervalStepUnit {
    HOUR
    DAY
    WEEK
    MONTH
    YEAR
}

"A custom time scope for an insight data series."
input TimeScopeInput {
    "Sets a time scope using a step interval (intervals of time)."
    stepInterval: TimeIntervalStepInput
}

"Represents a terminally incomplete data point at a specific time, and optionally for a specific repository."
type TimeoutDatapointAlert implements IncompleteDatapointAlert {
    "The data point that is incomplete."
    time: DateTime!
}

"A file, directory, or other tree entry."
interface TreeEntry {
    "The full path (relative to the repository root) of this tree entry."
    path: String!
    "The base name (i.e., file name only) of this tree entry."
    name: String!
    "Whether this tree entry is a directory."
    isDirectory: Boolean!
    "The URL to this tree entry (using the input revision specifier, which may not be immutable)."
    url: String!
    "The canonical URL to this tree entry (using an immutable revision specifier)."
    canonicalURL: String!
    "The URLs to this tree entry on external services."
    externalURLs: [ExternalLink!]!
    "Symbols defined in this file or directory."
    symbols("Returns the first n symbols from the list." first: Int "Return symbols matching the query." query: String): SymbolConnection!
    "Submodule metadata if this tree points to a submodule"
    submodule: Submodule
    "Whether this tree entry is a single child"
    isSingleChild("Returns the first n files in the tree." first: Int "Recurse into sub-trees." recursive: Boolean = false "Recurse into sub-trees of single-child directories" recursiveSingleChild: Boolean = false): Boolean!
    "LSIF data for this tree entry."
    lsif("An optional filter for the name of the tool that produced the upload data." toolName: String): TreeEntryLSIFData
}

"LSIF data available for a tree entry (file OR directory, see GitBlobLSIFData for file-specific\nresolvers and GitTreeLSIFData for directory-specific resolvers.)"
interface TreeEntryLSIFData {
    "Code diagnostics provided through LSIF."
    diagnostics(first: Int): DiagnosticConnection!
}

"Information about software updates for Sourcegraph."
type UpdateCheck {
    "Whether an update check is currently in progress."
    pending: Boolean!
    "When the last update check was completed, or null if no update check has\nbeen completed (or performed) yet."
    checkedAt: DateTime
    "If an error occurred during the last update check, this message describes\nthe error."
    errorMessage: String
    "If an update is available, the version string of the updated version."
    updateVersionAvailable: String
}

"Partial update to apply to a subscription's Cody Gateway access. Omitted fields are not applied."
input UpdateCodyGatewayAccessInput {
    "Enable or disable Cody Gateway access."
    enabled: Boolean
    "Override default requests per time interval.\n\nSet to 0 to remove the override."
    chatCompletionsRateLimit: BigInt
    "Override default interval for rate limiting.\n\nSet to 0 to remove the override."
    chatCompletionsRateLimitIntervalSeconds: Int
    "Override the set of allowed models for chat completions\nfor this subscription."
    chatCompletionsAllowedModels: [String!]
    "Override default requests per time interval.\n\nSet to 0 to remove the override."
    codeCompletionsRateLimit: BigInt
    "Override default interval for rate limiting.\n\nSet to 0 to remove the override."
    codeCompletionsRateLimitIntervalSeconds: Int
    "Override the set of allowed models for chat completions\nfor this subscription."
    codeCompletionsAllowedModels: [String!]
    "Override default requests per time interval for embeddings generation.\n\nSet to 0 to remove the override."
    embeddingsRateLimit: BigInt
    "Override default interval for rate limiting for embeddings generation.\n\nSet to 0 to remove the override."
    embeddingsRateLimitIntervalSeconds: Int
    "Override the set of allowed models for embeddings generation for this subscription."
    embeddingsAllowedModels: [String!]
}

"Fields to update for an existing external service."
input UpdateExternalServiceInput {
    "The id of the external service to update."
    id: ID!
    "The updated display name, if provided."
    displayName: String
    "The updated config, if provided."
    config: String
}

"Input object for update insight series mutation."
input UpdateInsightSeriesInput {
    "Unique ID for the series."
    seriesId: String!
    "The desired activity state (enabled or disabled) for the series."
    enabled: Boolean
}

"Input object for updating a dashboard."
input UpdateInsightsDashboardInput {
    "Dashboard title."
    title: String
    "Permissions to grant to the dashboard."
    grants: InsightsPermissionGrantsInput
}

"Input for updating a line chart search insight."
input UpdateLineChartSearchInsightInput {
    "The complete list of data series on this line chart. Note: excluding a data series will remove it."
    dataSeries: [LineChartSearchInsightDataSeriesInput!]!
    "The scope of repositories for the insight, this scope will apply to all dataSeries unless another scope is provided by a series."
    repositoryScope: RepositoryScopeInput
    "The time scope for this insight, this scope will apply to all dataSeries unless another scope is provided by a series."
    timeScope: TimeScopeInput
    "The presentation options for this line chart."
    presentationOptions: LineChartOptionsInput!
    "The default values for filters and aggregates for this line chart."
    viewControls: InsightViewControlsInput!
}

"Input for updating a pie chart search insight"
input UpdatePieChartSearchInsightInput {
    "The query string."
    query: String!
    "The scope of repositories."
    repositoryScope: RepositoryScopeInput!
    "Options for this pie chart."
    presentationOptions: PieChartOptionsInput!
}

"Partial update to apply to a subscription. Omitted fields are not applied."
input UpdateProductSubscriptionInput {
    "Partial update to Cody Gateway access granted to this subscription."
    codyGatewayAccess: UpdateCodyGatewayAccessInput
}

"The state of a repository in the update queue."
type UpdateQueue {
    "The index of the repo in the update queue.\nUpdating repos are placed at the end of the queue until they finish updating\nso don't display this if updating is true."
    index: Int!
    "True if the repo is currently updating."
    updating: Boolean!
    "The total number of repos in the update queue (including updating repos)."
    total: Int!
}

"The state of a repository in the update schedule."
type UpdateSchedule {
    "The interval that was used when scheduling the current due time."
    intervalSeconds: Int!
    "The next time that the repo will be inserted into the update queue."
    due: DateTime!
    "The index of the repo in the schedule."
    index: Int!
    "The total number of repos in the schedule."
    total: Int!
}

"The payload for SettingsMutation.updateConfiguration."
type UpdateSettingsPayload {
    "An empty response."
    empty: EmptyResponse
}

"UpdateSignalConfigurationsInput represents the input for updating multiple signal configurations."
input UpdateSignalConfigurationsInput {
    "The signal configuration updates."
    configs: [OwnSignalConfigurationUpdate!]!
}

"Instance upgrade readiness information includes schema drifts and deprecated-but-unfinished out-of-band migrations."
type UpgradeReadiness {
    "The schema drift details."
    schemaDrift: [SchemaDriftSummary!]!
    "The list of deprecated-but-unfinished out-of-band migrations."
    requiredOutOfBandMigrations: [OutOfBandMigration!]!
}

"A user."
type User implements Node & SettingsSubject & Namespace & TeamMember {
    "The unique ID for the user."
    id: ID!
    "The user's username."
    username: String!
    "The user's primary email address.\nOnly the user and site admins can access this field."
    email: String! @deprecated(reason: "use emails instead")
    "The display name chosen by the user."
    displayName: String
    "The URL of the user's avatar image."
    avatarURL: String
    "The URL to the user's profile on Sourcegraph."
    url: String!
    "The URL to the user's settings."
    settingsURL: String
    "The date when the user account was created on Sourcegraph."
    createdAt: DateTime!
    "The date when the user account was last updated on Sourcegraph."
    updatedAt: DateTime
    "Whether the user is a site admin.\nOnly the user and site admins can access this field."
    siteAdmin: Boolean!
    "Whether the user account uses built in auth."
    builtinAuth: Boolean!
    "The latest settings for the user.\nOnly the user and site admins can access this field."
    latestSettings: Settings
    "All settings for this user, and the individual levels in the settings cascade (global > organization > user)\nthat were merged to produce the final merged settings.\nOnly the user and site admins can access this field."
    settingsCascade: SettingsCascade!
    "DEPRECATED"
    configurationCascade: ConfigurationCascade! @deprecated(reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release.")
    "The organizations that this user is a member of."
    organizations: OrgConnection!
    "This user's organization memberships."
    organizationMemberships: OrganizationMembershipConnection!
    "Whether the user has already accepted the terms of service or not."
    tosAccepted: Boolean!
    "Whether the user accepted to be searched in the users picker or not."
    searchable: Boolean!
    "The user's usage statistics on Sourcegraph."
    usageStatistics: UserUsageStatistics!
    "The user's events on Sourcegraph."
    eventLogs("Returns the first n event logs from the list." first: Int "Only return events matching this event name" eventName: String): EventLogsConnection!
    "The user's email addresses.\nOnly the user and site admins can access this field."
    emails: [UserEmail!]!
    "Whether the user has a verified email or not.\nOnly the user and site admins can access this field."
    hasVerifiedEmail: Boolean!
    "Whether the user has completed the post-signup flow.\nOnly the user and site admins can access this field."
    completedPostSignup: Boolean!
    "The user's verified primary email address (if any).\nOn dotcom only the user and site admins can access this field."
    primaryEmail: UserEmail
    "The user's access tokens (which grant to the holder the privileges of the user). This consists\nof all access tokens whose subject is this user.\nOnly the user and site admins can access this field."
    accessTokens("Returns the first n access tokens from the list." first: Int): AccessTokenConnection!
    "A list of external accounts that are associated with the user."
    externalAccounts("Returns the first n external accounts from the list." first: Int): ExternalAccountConnection!
    "The user's currently active session.\nOnly the currently authenticated user can access this field. Site admins are not able to access sessions for\nother users."
    session: Session!
    "Whether the viewer has admin privileges on this user. The user has admin privileges on their own user, and\nsite admins have admin privileges on all users."
    viewerCanAdminister: Boolean!
    "Whether the viewer can change the username of this user.\nThe user can change their username unless auth.disableUsernameChanges is set.\nSite admins can always change the username of any user."
    viewerCanChangeUsername: Boolean!
    "The user's survey responses.\nOnly the user and site admins can access this field."
    surveyResponses: [SurveyResponse!]!
    "The unique numeric ID for the user.\nFOR INTERNAL USE ONLY."
    databaseID: Int!
    "The name of this user namespace's component. For users, this is the username."
    namespaceName: String!
    "Whether the user is controlled externally through SCIM."
    scimControlled: Boolean!
    "EXPERIMENTAL: Collaborators who can be invited to Sourcegraph. This typically comes from a few\nrepositories this user has access to, and is derived from recent commit history of those."
    invitableCollaborators: [Person!]!
    "The list of all roles assigned to this user."
    roles("The limit argument for forward pagination." first: Int "The limit argument for backward pagination." last: Int "The cursor argument for forward pagination." after: String "The cursor argument for backward pagination." before: String): RoleConnection!
    "The list of permissions granted to this user based on their roles."
    permissions: PermissionConnection!
    "The configured override for the user to the completions request quota per day.\nNull, if not overwritten."
    completionsQuotaOverride: Int
    "The configured override for the user to the code completions request quota\nper day.\nNull, if not overwritten."
    codeCompletionsQuotaOverride: Int
    "The list of all available executor secrets for execution in this users namespace."
    executorSecrets("The scope for which secrets shall be returned." scope: ExecutorSecretScope! "Only return N records." first: Int = 50 "Opaque cursor for pagination." after: String): ExecutorSecretConnection!
    "All the teams this user is a direct member of."
    teams("Returns the first n teams from the list." first: Int "Opaque pagination cursor." after: String "Optionally apply a text search filter over the results." search: String): TeamConnection!
    "A list of batch changes applied under this user's namespace."
    batchChanges("Returns the first n batch changes from the list." first: Int = 50 "Opaque pagination cursor." after: String "Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`." state: BatchChangeState "Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it." states: [BatchChangeState!] "Only include batch changes that the viewer can administer." viewerCanAdminister: Boolean): BatchChangeConnection!
    "Returns a connection of configured external services accessible by this user, for usage with batch changes.\nThese are all code hosts configured on the Sourcegraph instance that are supported by batch changes. They are\nconnected to BatchChangesCredential resources, if one has been created for the code host connection before."
    batchChangesCodeHosts("Returns the first n code hosts from the list." first: Int = 50 "Opaque pagination cursor." after: String): BatchChangesCodeHostConnection!
    "The permissions information of the user over repositories.\nIt is null when there is no permissions data stored for the user."
    permissionsInfo: PermissionsInfo
    "A list of monitors owned by the user or her organization."
    monitors("Returns the first n monitors from the list." first: Int = 50 "Opaque pagination cursor." after: String): MonitorConnection!
}

"A period of time in which a set of users have been active."
enum UserActivePeriod {
    "Since today at 00:00 UTC."
    TODAY
    "Since the latest Monday at 00:00 UTC."
    THIS_WEEK
    "Since the first day of the current month at 00:00 UTC."
    THIS_MONTH
    "All time."
    ALL_TIME
}

"A list of users."
type UserConnection {
    "A list of users."
    nodes: [User!]!
    "The total count of users in the connection. This total count may be larger\nthan the number of nodes in this object when the result is paginated."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"A user's email address."
type UserEmail {
    "The email address."
    email: String!
    "Whether the email address is the user's primary email address. Currently this is defined as the earliest\nemail address associated with the user, preferring verified emails to unverified emails."
    isPrimary: Boolean!
    "Whether the email address has been verified by the user."
    verified: Boolean!
    "Whether the email address is pending verification."
    verificationPending: Boolean!
    "The user associated with this email address."
    user: User!
    "Whether the viewer has privileges to manually mark this email address as verified (without the user going\nthrough the normal verification process). Only site admins have this privilege."
    viewerCanManuallyVerify: Boolean!
}

"A user event."
enum UserEvent {
    PAGEVIEW
    SEARCHQUERY
    CODEINTEL
    CODEINTELREFS
    CODEINTELINTEGRATION
    CODEINTELINTEGRATIONREFS
    "Product stages"
    STAGEMANAGE
    STAGEPLAN
    STAGECODE
    STAGEREVIEW
    STAGEVERIFY
    STAGEPACKAGE
    STAGEDEPLOY
    STAGECONFIGURE
    STAGEMONITOR
    STAGESECURE
    STAGEAUTOMATE
}

"A user (identified either by username or email address) with its repository permission."
type UserPermission {
    "Depending on the bindID option in the permissions.userMapping site configuration property,\nthe elements of the list are either all usernames (bindID of \"username\") or all email\naddresses (bindID of \"email\")."
    bindID: String!
    "The highest level of repository permission."
    permission: RepositoryPermission!
}

"Input type of a user (identified either by username or email address) with its repository permission."
input UserPermissionInput {
    "Depending on the bindID option in the permissions.userMapping site configuration property,\nthe elements of the list are either all usernames (bindID of \"username\") or all email\naddresses (bindID of \"email\")."
    bindID: String!
    "The highest level of repository permission."
    permission: RepositoryPermission = READ
}

"A user (identified either by username or email address) with its sub-repository permissions."
input UserSubRepoPermission {
    "Depending on the bindID option in the permissions.userMapping site configuration property,\nthe elements of the list are either all usernames (bindID of \"username\") or all email\naddresses (bindID of \"email\")."
    bindID: String!
    "DEPRECATED\nAn array of paths that the user is allowed to access, in glob format."
    pathIncludes: [String!]
    "DEPRECATED\nAn array of paths that the user is not allowed to access, in glob format."
    pathExcludes: [String!]
    "An array of paths in glob format. Paths starting with a minus (-)\n(i.e. \"-\/dev\/private\") prevent access, otherwise paths grant access.\nThe last applicable path takes precedence.\nWhen paths is set, pathIncludes and pathExcludes are ignored."
    paths: [String!]
}

"UserUsageStatistics describes a user's usage statistics.\nThis information is visible to all viewers."
type UserUsageStatistics {
    "The number of search queries that the user has performed."
    searchQueries: Int!
    "The number of page views that the user has performed."
    pageViews: Int!
    "The number of code intelligence actions that the user has performed."
    codeIntelligenceActions: Int!
    "The number of find-refs actions that the user has performed."
    findReferencesActions: Int!
    "The last time the user was active (any action, any platform)."
    lastActiveTime: String
    "The last time the user was active on a code host integration."
    lastActiveCodeHostIntegrationTime: String
}

"A virtual file is an arbitrary file that is generated in memory."
type VirtualFile implements File2 {
    "The full path (relative to the root) of this file."
    path: String!
    "The base name (i.e., file name only) of this file."
    name: String!
    "False because this is a file, not a directory."
    isDirectory: Boolean!
    "The content of this file."
    content("Return file content starting at line \"startLine\". A value <= 0 will be the start of the file." startLine: Int "Return file content ending at line \"endLine\". A value < 0 or > totalLines will set endLine to the end of the file." endLine: Int): String!
    "The file size in bytes."
    byteSize: Int!
    "Total line count for the file. Returns 0 for binary files."
    totalLines: Int!
    "Whether or not it is binary."
    binary: Boolean!
    "The file rendered as rich HTML, or an empty string if it is not a supported\nrich file type.\nThis HTML string is already escaped and thus is always safe to render."
    richHTML("Return richHTML content starting at line \"startLine\". A value <= 0 will be the start of the file." startLine: Int "Return richHTML content ending at line \"endLine\". A value < 0 or > totalLines will set endLine to the end of the file." endLine: Int): String!
    "Not implemented."
    url: String!
    "Not implemented."
    canonicalURL: String!
    "Not impleemented."
    changelistURL: String
    "Not implemented."
    externalURLs: [ExternalLink!]!
    "Highlight the file."
    highlight(disableTimeout: Boolean! isLightTheme: Boolean "If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.\n2000 bytes is enabled. This may produce a significant amount of HTML\nwhich some browsers (such as Chrome, but not Firefox) may have trouble\nrendering efficiently." highlightLongLines: Boolean = false "Specifies which format\/highlighting technique to use." format: HighlightResponseFormat = HTML_HIGHLIGHT "Return highlight content starting at line \"startLine\". A value <= 0 will be the start of the file.\nWarning: Pagination only works with the HTML_PLAINTEXT format type at the moment." startLine: Int "Return highlight content ending at line \"endLine\". A value < 0 or > totalLines will set endLine to the end of the file.\nWarning: Pagination only works with the HTML_PLAINTEXT format type at the moment." endLine: Int): HighlightedFile!
}

"A preview entry to a repository to which the user has access."
union VisibleApplyPreviewTargets = VisibleApplyPreviewTargetsAttach | VisibleApplyPreviewTargetsUpdate | VisibleApplyPreviewTargetsDetach

"A preview entry where no changeset existed before matching the changeset spec."
type VisibleApplyPreviewTargetsAttach {
    "The changeset spec from this entry."
    changesetSpec: VisibleChangesetSpec!
}

"A preview entry where no changeset spec exists for the changeset currently in\nthe target batch change."
type VisibleApplyPreviewTargetsDetach {
    "The changeset from this entry."
    changeset: ExternalChangeset!
}

"A preview entry where a changeset matches the changeset spec."
type VisibleApplyPreviewTargetsUpdate {
    "The changeset spec from this entry."
    changesetSpec: VisibleChangesetSpec!
    "The changeset from this entry."
    changeset: ExternalChangeset!
}

"A workspace to which the requesting user has access."
type VisibleBatchSpecWorkspace implements BatchSpecWorkspace & Node {
    "The unique ID for the workspace."
    id: ID!
    "The repository to run over."
    repository: Repository!
    "Used for reverse querying."
    batchSpec: BatchSpec!
    "The branch to run over."
    branch: GitRef!
    "The path to run in."
    path: String!
    "If true, only the files within the workspace will be fetched."
    onlyFetchWorkspace: Boolean!
    "If true, this workspace has been skipped, because some rule forced this.\nFor now, the only one is a .batchignore file existing in the repository."
    ignored: Boolean!
    "If true, this workspace has been skipped, because the code host on which\nthe repository is hosted is not supported."
    unsupported: Boolean!
    "Whether we found a task cache result."
    cachedResultFound: Boolean!
    "How many steps had a cached result."
    stepCacheResultCount: Int!
    "Executor stages of running in this workspace. Null, if the execution hasn't\nstarted yet."
    stages: BatchSpecWorkspaceStages
    "List of steps that will need to run over this workspace."
    steps: [BatchSpecWorkspaceStep!]!
    "Get a specific step by its index. Index is 1-based."
    step(index: Int!): BatchSpecWorkspaceStep
    "If this workspace was resolved based on a search, this is the list of paths\nto files that have been included in the search results."
    searchResultPaths: [String!]!
    "The time when the workspace was enqueued for processing. Null, if not yet enqueued."
    queuedAt: DateTime
    "The time when the workspace started processing. Null, if not yet started."
    startedAt: DateTime
    "The time when the workspace finished processing. Null, if not yet finished."
    finishedAt: DateTime
    "Optional failure message, set when the execution failed."
    failureMessage: String
    "The current state the workspace is in."
    state: BatchSpecWorkspaceState!
    "Populated, when the execution is finished. This is where you get the combined\ndiffs."
    changesetSpecs: [VisibleChangesetSpec!]
    "The rank of this execution in the queue of the user. The value of this field is null if the\nexecution has started."
    placeInQueue: Int
    "The rank of this execution in the global queue. The value of this field is null if the\nexecution has started."
    placeInGlobalQueue: Int
    "The diff stat over all created changeset specs. Null, if not yet finished or\nfailed."
    diffStat: DiffStat
    "The executor that picked up this job. Null, if the executor has been pruned\nfrom the data set or if the job has not started yet.\nOnly available to site-admins."
    executor: Executor
}

"One preview entry in the list of all previews against a batch spec. Each mapping\nbetween changeset specs and current changesets yields one of these. It describes\nwhich operations are taken against which changeset spec and changeset to ensure the\ndesired state is met."
type VisibleChangesetApplyPreview {
    "The operations to take to achieve the desired state."
    operations: [ChangesetSpecOperation!]!
    "The delta between the current changeset state and what the new changeset spec\nenvisions the changeset to look like."
    delta: ChangesetSpecDelta!
    "The target entities in this preview entry."
    targets: VisibleApplyPreviewTargets!
}

"A changeset spec is an immutable description of the desired state of a changeset in a batch change. To\ncreate a changeset spec, use the createChangesetSpec mutation."
type VisibleChangesetSpec implements ChangesetSpec & Node {
    "The unique ID for a changeset spec.\n\nThe ID is unguessable (i.e., long and randomly generated, not sequential). This is important\neven though repository permissions also apply to viewers of changeset specs, because being\nallowed to view a repository should not entitle a person to view all not-yet-published\nchangesets for that repository. Consider a batch change to fix a security vulnerability: the\nbatch change author may prefer to prepare all of the changesets in private so that the window\nbetween revealing the problem and merging the fixes is as short as possible."
    id: ID!
    "The type of changeset spec."
    type: ChangesetSpecType!
    "The description of the changeset."
    description: ChangesetDescription!
    "The date, if any, when this changeset spec expires and is automatically purged. A changeset\nspec never expires (and this field is null) if its batch spec has been applied."
    expiresAt: DateTime
    "The fork the changeset will be pushed to, if any."
    forkTarget: ForkTarget
    "The workspace this resulted from. Null, if not run server-side."
    workspace: BatchSpecWorkspace
}

"Vulnerabilities synced from the GitHub Advisory Database."
type Vulnerability implements Node {
    "The ID of the vulnerability."
    id: ID!
    "The CVE identifier of the vulnerability (e.g., CVE-2023-123)."
    sourceID: String!
    "A short summary of the vulnerability."
    summary: String!
    "A longer description of the vulnerability."
    details: String!
    "Common Platform Enumeration identifiers related to this vulnerability."
    cpes: [String!]!
    "Common Weakness Enumeration identifiers related to this vulnerability."
    cwes: [String!]!
    "Other names this vulnerability is known by."
    aliases: [String!]!
    "Names of related vulnerabilities."
    related: [String!]!
    "The data source of this vulnerability."
    dataSource: String!
    "URLs indicating the source of this vulnerability."
    urls: [String!]!
    "A human-readable severity string."
    severity: String!
    "The Common Vulnerability Scoring System severity vector."
    cvssVector: String!
    "The Common Vulnerability Scoring System severity score."
    cvssScore: String!
    "The time this vulnerability was published."
    published: DateTime!
    "The last time this vulnerability was modified."
    modified: DateTime
    "The time this vulnerability was withdrawn."
    withdrawn: DateTime
    "A list of packages that are affected by this vulnerability."
    affectedPackages: [VulnerabilityAffectedPackage!]!
}

"A package affected by a vulnerability."
type VulnerabilityAffectedPackage {
    "The name of the package."
    packageName: String!
    "The language ecosystem."
    language: String!
    "A package namespace."
    namespace: String!
    "A list of constraints that identify affected versions of the package."
    versionConstraint: [String!]!
    "Whether or not there is a known fix."
    fixed: Boolean!
    "The version in which the fix was applied."
    fixedIn: String
    "A list of specific symbols affected by the vulnerability."
    affectedSymbols: [VulnerabilityAffectedSymbol!]!
}

"A specific symbol affected by a vulnerability."
type VulnerabilityAffectedSymbol {
    "A path to the document within the package source."
    path: String!
    "A list of symbols defined in that path."
    symbols: [String!]!
}

"A page of vulnerabilities."
type VulnerabilityConnection {
    "The vulnerabilities on the page."
    nodes: [Vulnerability!]!
    "The total number of vulnerabilities across all pages."
    totalCount: Int
    "Information on how to fetch the next page."
    pageInfo: PageInfo!
}

"A use of a known vulnerable-affected package.e"
type VulnerabilityMatch implements Node {
    "The match ID."
    id: ID!
    "The vulnerability."
    vulnerability: Vulnerability!
    "The affected package that is used by the associated index."
    affectedPackage: VulnerabilityAffectedPackage!
    "The index record that contains a direct use of the affected package."
    preciseIndex: PreciseIndex!
}

"A page of vulnerability matches."
type VulnerabilityMatchConnection {
    "The vulnerability matches on the page."
    nodes: [VulnerabilityMatch!]!
    "The total number of vulnerability matches across all pages."
    totalCount: Int
    "Information on how to fetch the next page."
    pageInfo: PageInfo!
}

"Vulnerability matches count group by repository."
type VulnerabilityMatchCountByRepository {
    "The id of the grouping."
    id: ID!
    "The repository name."
    repositoryName: String!
    "The vulnerability matches count."
    matchCount: Int!
}

"A page of vulnerability matches grouped by repository."
type VulnerabilityMatchCountByRepositoryConnection {
    "The vulnerability matches on the page."
    nodes: [VulnerabilityMatchCountByRepository!]!
    "The total number of vulnerability matches across all pages."
    totalCount: Int
    "Information on how to fetch the next page."
    pageInfo: PageInfo!
}

"A count of the severities of vulnerability matches."
type VulnerabilityMatchesSummaryCount {
    "The number of matches with a severity of \"CRITICAL\"."
    critical: Int!
    "The number of matches with a severity of \"HIGH\"."
    high: Int!
    "The number of matches with a severity of \"MEDIUM\"."
    medium: Int!
    "The number of matches with a severity of \"LOW\"."
    low: Int!
    "The number of repos with a severity"
    repository: Int!
}

"Represents an incoming webhook from a code host."
type Webhook implements Node {
    "The unique ID of the webhook."
    id: ID!
    "The user facing UUID of the webhook."
    uuid: String!
    "The URL of the webhook in the instance. This is the location where we expect to receive payloads."
    url: String!
    "Descriptive webhook name."
    name: String!
    "The kind of code host sending payloads. (eg. GitHub, GitLab)"
    codeHostKind: ExternalServiceKind!
    "The URN of the code host instance. (eg. https:\/\/gitlab.com)"
    codeHostURN: String!
    "Optional secret."
    secret: String
    "The last time this webhook was updated."
    updatedAt: DateTime!
    "The user who last updated this webhook.\nNull if the user was deleted or if the webhook hasn't been updated yet."
    updatedBy: User
    "When the webhook was created."
    createdAt: DateTime!
    "The user who created this webhook.\nNull if the user was deleted."
    createdBy: User
    "The logs related to this webhook."
    webhookLogs("Returns the first n webhook logs." first: Int "Opaque pagination cursor." after: String "Only include webhook logs that resulted in errors." onlyErrors: Boolean "Only include webhook logs on or after this time." since: DateTime "Only include webhook logs on or before this time." until: DateTime): WebhookLogConnection!
}

"A list of webhooks"
type WebhookConnection {
    "A list of webhooks."
    nodes: [Webhook!]!
    "The total number of webhooks in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"A single logged webhook delivery."
type WebhookLog implements Node {
    "The webhook log ID."
    id: ID!
    "The time the webhook was received at."
    receivedAt: DateTime!
    "The external service the webhook was matched to, if any."
    externalService: ExternalService
    "The HTTP status code returned from the webhook handler."
    statusCode: Int!
    "The received webhook request."
    request: WebhookLogRequest!
    "The response sent by the webhook handler."
    response: WebhookLogResponse!
}

"A list of logged webhook deliveries."
type WebhookLogConnection {
    "A list of webhook logs."
    nodes: [WebhookLog!]!
    "The total number of webhook logs in the connection."
    totalCount: Int!
    "Pagination information."
    pageInfo: PageInfo!
}

"A HTTP message (request or response) within a webhook log."
interface WebhookLogMessage {
    "The headers in the HTTP message."
    headers: [HTTPHeader!]!
    "The body content of the HTTP message."
    body: String!
}

"A HTTP request within a webhook log."
type WebhookLogRequest implements WebhookLogMessage {
    "The headers in the HTTP message."
    headers: [HTTPHeader!]!
    "The body content of the HTTP message."
    body: String!
    "The method used in the HTTP request."
    method: String!
    "The requested URL."
    url: String!
    "The HTTP version in use."
    version: String!
}

"A HTTP response within a webhook log."
type WebhookLogResponse implements WebhookLogMessage {
    "The headers in the HTTP message."
    headers: [HTTPHeader!]!
    "The body content of the HTTP message."
    body: String!
}

"Possible sort orderings for a workspace connection."
enum WorkspacesSortOrder {
    "Sort by repository name in ascending order."
    REPO_NAME_ASC
    "Sort by repository name in descending order."
    REPO_NAME_DESC
}

type _Service {
    sdl: String!
}

"Information about the indexserver that hosts the repo's index."
type repositoryIndexserverHost {
    "The hostname of the indexserver."
    name: String!
}